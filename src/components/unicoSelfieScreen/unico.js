/* eslint-disable */
/**
 * Skipped minification because the original files appears to be already minified.
 * Original file: /npm/unico-webframe@1.0.0/dist/unico-webframe.umd.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
 !(function (t, e) {
  'object' == typeof exports && 'undefined' != typeof module
    ? e(exports)
    : 'function' == typeof define && define.amd
    ? define(['exports'], e)
    : e(((t = 'undefined' != typeof globalThis ? globalThis : t || self).unicoWebframe = {}))
})(this, function (t) {
  'use strict'
  var u =
    'undefined' != typeof globalThis
      ? globalThis
      : 'undefined' != typeof window
      ? window
      : 'undefined' != typeof global
      ? global
      : 'undefined' != typeof self
      ? self
      : {}
  var e,
    i =
      ((function (a, s) {
        !function () {
          var k = ({ function: !0, object: !0 }[typeof window] && window) || this,
            n = s,
            t = a && !a.nodeType && a,
            e = n && t && 'object' == typeof u && u
          !e || (e.global !== e && e.window !== e && e.self !== e) || (k = e)
          var i = Math.pow(2, 53) - 1,
            T = /\bOpera/,
            e = Object.prototype,
            r = e.hasOwnProperty,
            D = e.toString
          function o(t) {
            return (t = String(t)).charAt(0).toUpperCase() + t.slice(1)
          }
          function O(t) {
            return (t = L(t)), /^(?:webOS|i(?:OS|P))/.test(t) ? t : o(t)
          }
          function F(t, e) {
            for (var n in t) r.call(t, n) && e(t[n], n, t)
          }
          function M(t) {
            return null == t ? o(t) : D.call(t).slice(8, -1)
          }
          function P(t) {
            return String(t).replace(/([ -])(?!$)/g, '$1?')
          }
          function B(n, r) {
            var o = null
            return (
              (function (t, e) {
                var n = -1,
                  r = t ? t.length : 0
                if ('number' == typeof r && -1 < r && r <= i) for (; ++n < r; ) e(t[n], n, t)
                else F(t, e)
              })(n, function (t, e) {
                o = r(o, t, e, n)
              }),
              o
            )
          }
          function L(t) {
            return String(t).replace(/^ +| +$/g, '')
          }
          function W(i) {
            var e = k,
              t = i && 'object' == typeof i && 'String' != M(i)
            t && ((e = i), (i = null))
            var n = e.navigator || {},
              r = n.userAgent || ''
            i = i || r
            var o,
              a,
              s = t ? !!n.likeChrome : /\bChrome\b/.test(i) && !/internal|\n/i.test(D.toString()),
              u = 'Object',
              c = t ? u : 'ScriptBridgingProxyObject',
              l = t ? u : 'Environment',
              h = t && e.java ? 'JavaPackage' : M(e.java),
              p = t ? u : 'RuntimeObject',
              d = /\bJava/.test(h) && e.java,
              f = d && M(e.environment) == l,
              v = d ? 'a' : 'α',
              m = d ? 'b' : 'β',
              g = e.document || {},
              y = e.operamini || e.opera,
              b = T.test((b = t && y ? y['[[Class]]'] : M(y))) ? b : (y = null),
              x = i,
              w = [],
              C = null,
              E = i == r,
              S = E && y && 'function' == typeof y.version && y.version(),
              _ = B(
                [
                  { label: 'EdgeHTML', pattern: 'Edge' },
                  'Trident',
                  { label: 'WebKit', pattern: 'AppleWebKit' },
                  'iCab',
                  'Presto',
                  'NetFront',
                  'Tasman',
                  'KHTML',
                  'Gecko',
                ],
                function (t, e) {
                  return t || (RegExp('\\b' + (e.pattern || P(e)) + '\\b', 'i').exec(i) && (e.label || e))
                },
              ),
              R = B(
                [
                  'Adobe AIR',
                  'Arora',
                  'Avant Browser',
                  'Breach',
                  'Camino',
                  'Electron',
                  'Epiphany',
                  'Fennec',
                  'Flock',
                  'Galeon',
                  'GreenBrowser',
                  'iCab',
                  'Iceweasel',
                  'K-Meleon',
                  'Konqueror',
                  'Lunascape',
                  'Maxthon',
                  { label: 'Microsoft Edge', pattern: '(?:Edge|Edg|EdgA|EdgiOS)' },
                  'Midori',
                  'Nook Browser',
                  'PaleMoon',
                  'PhantomJS',
                  'Raven',
                  'Rekonq',
                  'RockMelt',
                  { label: 'Samsung Internet', pattern: 'SamsungBrowser' },
                  'SeaMonkey',
                  { label: 'Silk', pattern: '(?:Cloud9|Silk-Accelerated)' },
                  'Sleipnir',
                  'SlimBrowser',
                  { label: 'SRWare Iron', pattern: 'Iron' },
                  'Sunrise',
                  'Swiftfox',
                  'Vivaldi',
                  'Waterfox',
                  'WebPositive',
                  { label: 'Yandex Browser', pattern: 'YaBrowser' },
                  { label: 'UC Browser', pattern: 'UCBrowser' },
                  'Opera Mini',
                  { label: 'Opera Mini', pattern: 'OPiOS' },
                  'Opera',
                  { label: 'Opera', pattern: 'OPR' },
                  'Chromium',
                  'Chrome',
                  { label: 'Chrome', pattern: '(?:HeadlessChrome)' },
                  { label: 'Chrome Mobile', pattern: '(?:CriOS|CrMo)' },
                  { label: 'Firefox', pattern: '(?:Firefox|Minefield)' },
                  { label: 'Firefox for iOS', pattern: 'FxiOS' },
                  { label: 'IE', pattern: 'IEMobile' },
                  { label: 'IE', pattern: 'MSIE' },
                  'Safari',
                ],
                function (t, e) {
                  return t || (RegExp('\\b' + (e.pattern || P(e)) + '\\b', 'i').exec(i) && (e.label || e))
                },
              ),
              I = A([
                { label: 'BlackBerry', pattern: 'BB10' },
                'BlackBerry',
                { label: 'Galaxy S', pattern: 'GT-I9000' },
                { label: 'Galaxy S2', pattern: 'GT-I9100' },
                { label: 'Galaxy S3', pattern: 'GT-I9300' },
                { label: 'Galaxy S4', pattern: 'GT-I9500' },
                { label: 'Galaxy S5', pattern: 'SM-G900' },
                { label: 'Galaxy S6', pattern: 'SM-G920' },
                { label: 'Galaxy S6 Edge', pattern: 'SM-G925' },
                { label: 'Galaxy S7', pattern: 'SM-G930' },
                { label: 'Galaxy S7 Edge', pattern: 'SM-G935' },
                'Google TV',
                'Lumia',
                'iPad',
                'iPod',
                'iPhone',
                'Kindle',
                { label: 'Kindle Fire', pattern: '(?:Cloud9|Silk-Accelerated)' },
                'Nexus',
                'Nook',
                'PlayBook',
                'PlayStation Vita',
                'PlayStation',
                'TouchPad',
                'Transformer',
                { label: 'Wii U', pattern: 'WiiU' },
                'Wii',
                'Xbox One',
                { label: 'Xbox 360', pattern: 'Xbox' },
                'Xoom',
              ]),
              u = B(
                {
                  Apple: { iPad: 1, iPhone: 1, iPod: 1 },
                  Alcatel: {},
                  Archos: {},
                  Amazon: { Kindle: 1, 'Kindle Fire': 1 },
                  Asus: { Transformer: 1 },
                  'Barnes & Noble': { Nook: 1 },
                  BlackBerry: { PlayBook: 1 },
                  Google: { 'Google TV': 1, Nexus: 1 },
                  HP: { TouchPad: 1 },
                  HTC: {},
                  Huawei: {},
                  Lenovo: {},
                  LG: {},
                  Microsoft: { Xbox: 1, 'Xbox One': 1 },
                  Motorola: { Xoom: 1 },
                  Nintendo: { 'Wii U': 1, Wii: 1 },
                  Nokia: { Lumia: 1 },
                  Oppo: {},
                  Samsung: { 'Galaxy S': 1, 'Galaxy S2': 1, 'Galaxy S3': 1, 'Galaxy S4': 1 },
                  Sony: { PlayStation: 1, 'PlayStation Vita': 1 },
                  Xiaomi: { Mi: 1, Redmi: 1 },
                },
                function (t, e, n) {
                  return (
                    t ||
                    ((e[I] || e[/^[a-z]+(?: +[a-z]+\b)*/i.exec(I)] || RegExp('\\b' + P(n) + '(?:\\b|\\w*\\d)', 'i').exec(i)) &&
                      n)
                  )
                },
              ),
              h = B(
                [
                  'Windows Phone',
                  'KaiOS',
                  'Android',
                  'CentOS',
                  { label: 'Chrome OS', pattern: 'CrOS' },
                  'Debian',
                  { label: 'DragonFly BSD', pattern: 'DragonFly' },
                  'Fedora',
                  'FreeBSD',
                  'Gentoo',
                  'Haiku',
                  'Kubuntu',
                  'Linux Mint',
                  'OpenBSD',
                  'Red Hat',
                  'SuSE',
                  'Ubuntu',
                  'Xubuntu',
                  'Cygwin',
                  'Symbian OS',
                  'hpwOS',
                  'webOS ',
                  'webOS',
                  'Tablet OS',
                  'Tizen',
                  'Linux',
                  'Mac OS X',
                  'Macintosh',
                  'Mac',
                  'Windows 98;',
                  'Windows ',
                ],
                function (t, e) {
                  var n,
                    r,
                    o = e.pattern || P(e)
                  return (
                    !t &&
                      (t = RegExp('\\b' + o + '(?:/[\\d.]+|[ \\w.]*)', 'i').exec(i)) &&
                      ((n = t),
                      (r = o),
                      (o = e.label || e),
                      (e = {
                        '10.0': '10',
                        6.4: '10 Technical Preview',
                        6.3: '8.1',
                        6.2: '8',
                        6.1: 'Server 2008 R2 / 7',
                        '6.0': 'Server 2008 / Vista',
                        5.2: 'Server 2003 / XP 64-bit',
                        5.1: 'XP',
                        5.01: '2000 SP1',
                        '5.0': '2000',
                        '4.0': 'NT',
                        '4.90': 'ME',
                      }),
                      r &&
                        o &&
                        /^Win/i.test(n) &&
                        !/^Windows Phone /i.test(n) &&
                        (e = e[/[\d.]+$/.exec(n)]) &&
                        (n = 'Windows ' + e),
                      (n = String(n)),
                      (t = n =
                        O(
                          (n = r && o ? n.replace(RegExp(r, 'i'), o) : n)
                            .replace(/ ce$/i, ' CE')
                            .replace(/\bhpw/i, 'web')
                            .replace(/\bMacintosh\b/, 'Mac OS')
                            .replace(/_PowerPC\b/i, ' OS')
                            .replace(/\b(OS X) [^ \d]+/i, '$1')
                            .replace(/\bMac (OS X)\b/, '$1')
                            .replace(/\/(\d)/, ' $1')
                            .replace(/_/g, '.')
                            .replace(/(?: BePC|[ .]*fc[ \d.]+)$/i, '')
                            .replace(/\bx86\.64\b/gi, 'x86_64')
                            .replace(/\b(Windows Phone) OS\b/, '$1')
                            .replace(/\b(Chrome OS \w+) [\d.]+\b/, '$1')
                            .split(' on ')[0],
                        ))),
                    t
                  )
                },
              )
            function A(t) {
              return B(t, function (t, e) {
                var n = e.pattern || P(e)
                return (
                  !t &&
                    (t =
                      RegExp('\\b' + n + ' *\\d+[.\\w_]*', 'i').exec(i) ||
                      RegExp('\\b' + n + ' *\\w+-[\\w]*', 'i').exec(i) ||
                      RegExp('\\b' + n + '(?:; *(?:[a-z]+[_-])?[a-z]+\\d+|[^ ();-]*)', 'i').exec(i)) &&
                    ((t = String(e.label && !RegExp(n, 'i').test(e.label) ? e.label : t).split('/'))[1] &&
                      !/[\d.]+/.test(t[0]) &&
                      (t[0] += ' ' + t[1]),
                    (e = e.label || e),
                    (t = O(
                      t[0]
                        .replace(RegExp(n, 'i'), e)
                        .replace(RegExp('; *(?:' + e + '[_-])?', 'i'), ' ')
                        .replace(RegExp('(' + e + ')[-_.]?(\\w)', 'i'), '$1 $2'),
                    ))),
                  t
                )
              })
            }
            function N(t) {
              return B(t, function (t, e) {
                return (
                  t || (RegExp(e + '(?:-[\\d.]+/|(?: for [\\w-]+)?[ /-])([\\d.]+[^ ();/_-]*)', 'i').exec(i) || 0)[1] || null
                )
              })
            }
            if (
              ((_ = _ && [_]),
              /\bAndroid\b/.test(h) &&
                !I &&
                (o = /\bAndroid[^;]*;(.*?)(?:Build|\) AppleWebKit)\b/i.exec(i)) &&
                (I = L(o[1]).replace(/^[a-z]{2}-[a-z]{2};\s*/i, '') || null),
              u && !I
                ? (I = A([u]))
                : u &&
                  I &&
                  (I = I.replace(RegExp('^(' + P(u) + ')[-_.\\s]', 'i'), u + ' ').replace(
                    RegExp('^(' + P(u) + ')[-_.]?(\\w)', 'i'),
                    u + ' $2',
                  )),
              (o = /\bGoogle TV\b/.exec(I)) && (I = o[0]),
              /\bSimulator\b/i.test(i) && (I = (I ? I + ' ' : '') + 'Simulator'),
              'Opera Mini' == R && /\bOPiOS\b/.test(i) && w.push('running in Turbo/Uncompressed mode'),
              'IE' == R && /\blike iPhone OS\b/.test(i)
                ? ((u = (o = W(i.replace(/like iPhone OS/, ''))).manufacturer), (I = o.product))
                : /^iP/.test(I)
                ? ((R = R || 'Safari'), (h = 'iOS' + ((o = / OS ([\d_]+)/i.exec(i)) ? ' ' + o[1].replace(/_/g, '.') : '')))
                : 'Konqueror' == R && /^Linux\b/i.test(h)
                ? (h = 'Kubuntu')
                : (u && 'Google' != u && ((/Chrome/.test(R) && !/\bMobile Safari\b/i.test(i)) || /\bVita\b/.test(I))) ||
                  (/\bAndroid\b/.test(h) && /^Chrome/.test(R) && /\bVersion\//i.test(i))
                ? ((R = 'Android Browser'), (h = /\bAndroid\b/.test(h) ? h : 'Android'))
                : 'Silk' == R
                ? (/\bMobi/i.test(i) || ((h = 'Android'), w.unshift('desktop mode')),
                  /Accelerated *= *true/i.test(i) && w.unshift('accelerated'))
                : 'UC Browser' == R && /\bUCWEB\b/.test(i)
                ? w.push('speed mode')
                : 'PaleMoon' == R && (o = /\bFirefox\/([\d.]+)\b/.exec(i))
                ? w.push('identifying as Firefox ' + o[1])
                : 'Firefox' == R && (o = /\b(Mobile|Tablet|TV)\b/i.exec(i))
                ? ((h = h || 'Firefox OS'), (I = I || o[1]))
                : !R || (o = !/\bMinefield\b/i.test(i) && /\b(?:Firefox|Safari)\b/.exec(R))
                ? (R && !I && /[\/,]|^[^(]+?\)/.test(i.slice(i.indexOf(o + '/') + 8)) && (R = null),
                  (o = I || u || h) &&
                    (I || u || /\b(?:Android|Symbian OS|Tablet OS|webOS)\b/.test(h)) &&
                    (R = /[a-z]+(?: Hat)?/i.exec(/\bAndroid\b/.test(h) ? h : o) + ' Browser'))
                : 'Electron' == R && (o = (/\bChrome\/([\d.]+)\b/.exec(i) || 0)[1]) && w.push('Chromium ' + o),
              (S =
                S ||
                N([
                  '(?:Cloud9|CriOS|CrMo|Edge|Edg|EdgA|EdgiOS|FxiOS|HeadlessChrome|IEMobile|Iron|Opera ?Mini|OPiOS|OPR|Raven|SamsungBrowser|Silk(?!/[\\d.]+$)|UCBrowser|YaBrowser)',
                  'Version',
                  P(R),
                  '(?:Firefox|Minefield|NetFront)',
                ])),
              (o =
                ('iCab' == _ && 3 < parseFloat(S)
                  ? 'WebKit'
                  : /\bOpera\b/.test(R) && (/\bOPR\b/.test(i) ? 'Blink' : 'Presto')) ||
                (/\b(?:Midori|Nook|Safari)\b/i.test(i) && !/^(?:Trident|EdgeHTML)$/.test(_) && 'WebKit') ||
                (!_ && /\bMSIE\b/i.test(i) && ('Mac OS' == h ? 'Tasman' : 'Trident')) ||
                ('WebKit' == _ && /\bPlayStation\b(?! Vita\b)/i.test(R) && 'NetFront')) && (_ = [o]),
              'IE' == R && (o = (/; *(?:XBLWP|ZuneWP)(\d+)/i.exec(i) || 0)[1])
                ? ((R += ' Mobile'), (h = 'Windows Phone ' + (/\+$/.test(o) ? o : o + '.x')), w.unshift('desktop mode'))
                : /\bWPDesktop\b/i.test(i)
                ? ((R = 'IE Mobile'),
                  (h = 'Windows Phone 8.x'),
                  w.unshift('desktop mode'),
                  (S = S || (/\brv:([\d.]+)/.exec(i) || 0)[1]))
                : 'IE' != R &&
                  'Trident' == _ &&
                  (o = /\brv:([\d.]+)/.exec(i)) &&
                  (R && w.push('identifying as ' + R + (S ? ' ' + S : '')), (R = 'IE'), (S = o[1])),
              E)
            ) {
              if (
                ((l = 'global'),
                (r = null != (t = e) ? typeof t[l] : 'number'),
                /^(?:boolean|number|string|undefined)$/.test(r) || ('object' == r && !t[l]))
              )
                M((o = e.runtime)) == c
                  ? ((R = 'Adobe AIR'), (h = o.flash.system.Capabilities.os))
                  : M((o = e.phantom)) == p
                  ? ((R = 'PhantomJS'), (S = (o = o.version || null) && o.major + '.' + o.minor + '.' + o.patch))
                  : 'number' == typeof g.documentMode && (o = /\bTrident\/(\d+)/i.exec(i))
                  ? ((S = [S, g.documentMode]),
                    (o = +o[1] + 4) != S[1] && (w.push('IE ' + S[1] + ' mode'), _ && (_[1] = ''), (S[1] = o)),
                    (S = 'IE' == R ? String(S[1].toFixed(1)) : S[0]))
                  : 'number' == typeof g.documentMode &&
                    /^(?:Chrome|Firefox)\b/.test(R) &&
                    (w.push('masking as ' + R + ' ' + S), (R = 'IE'), (S = '11.0'), (_ = ['Trident']), (h = 'Windows'))
              else if (
                (d &&
                  ((x = (o = d.lang.System).getProperty('os.arch')),
                  (h = h || o.getProperty('os.name') + ' ' + o.getProperty('os.version'))),
                f)
              ) {
                try {
                  ;(S = e.require('ringo/engine').version.join('.')), (R = 'RingoJS')
                } catch (t) {
                  ;(o = e.system) && o.global.system == e.system && ((R = 'Narwhal'), (h = h || o[0].os || null))
                }
                R = R || 'Rhino'
              } else
                'object' == typeof e.process &&
                  !e.process.browser &&
                  (o = e.process) &&
                  ('object' == typeof o.versions &&
                    ('string' == typeof o.versions.electron
                      ? (w.push('Node ' + o.versions.node), (R = 'Electron'), (S = o.versions.electron))
                      : 'string' == typeof o.versions.nw &&
                        (w.push('Chromium ' + S, 'Node ' + o.versions.node), (R = 'NW.js'), (S = o.versions.nw))),
                  R || ((R = 'Node.js'), (x = o.arch), (h = o.platform), (S = (S = /[\d.]+/.exec(o.version)) ? S[0] : null)))
              h = h && O(h)
            }
            if (
              (S &&
                (o =
                  /(?:[ab]|dp|pre|[ab]\d+pre)(?:\d+\+?)?$/i.exec(S) ||
                  /(?:alpha|beta)(?: ?\d)?/i.exec(i + ';' + (E && n.appMinorVersion)) ||
                  (/\bMinefield\b/i.test(i) && 'a')) &&
                ((C = /b/i.test(o) ? 'beta' : 'alpha'),
                (S = S.replace(RegExp(o + '\\+?$'), '') + ('beta' == C ? m : v) + (/\d+\+?/.exec(o) || ''))),
              'Fennec' == R || ('Firefox' == R && /\b(?:Android|Firefox OS|KaiOS)\b/.test(h)))
            )
              R = 'Firefox Mobile'
            else if ('Maxthon' == R && S) S = S.replace(/\.[\d.]+/, '.x')
            else if (/\bXbox\b/i.test(I))
              'Xbox 360' == I && (h = null), 'Xbox 360' == I && /\bIEMobile\b/.test(i) && w.unshift('mobile mode')
            else if (
              (!/^(?:Chrome|IE|Opera)$/.test(R) && (!R || I || /Browser|Mobi/.test(R))) ||
              ('Windows CE' != h && !/Mobi/i.test(i))
            )
              if ('IE' == R && E)
                try {
                  null === e.external && w.unshift('platform preview')
                } catch (t) {
                  w.unshift('embedded')
                }
              else
                (/\bBlackBerry\b/.test(I) || /\bBB10\b/.test(i)) &&
                (o = (RegExp(I.replace(/ +/g, ' *') + '/([.\\d]+)', 'i').exec(i) || 0)[1] || S)
                  ? ((h = ((o = [o, /BB10/.test(i)])[1] ? ((I = null), (u = 'BlackBerry')) : 'Device Software') + ' ' + o[0]),
                    (S = null))
                  : this != F &&
                    'Wii' != I &&
                    ((E && y) ||
                      (/Opera/.test(R) && /\b(?:MSIE|Firefox)\b/i.test(i)) ||
                      ('Firefox' == R && /\bOS X (?:\d+\.){2,}/.test(h)) ||
                      ('IE' == R &&
                        ((h && !/^Win/.test(h) && 5.5 < S) ||
                          (/\bWindows XP\b/.test(h) && 8 < S) ||
                          (8 == S && !/\bTrident\b/.test(i))))) &&
                    !T.test((o = W.call(F, i.replace(T, '') + ';'))) &&
                    o.name &&
                    ((o = 'ing as ' + o.name + ((o = o.version) ? ' ' + o : '')),
                    T.test(R)
                      ? (/\bIE\b/.test(o) && 'Mac OS' == h && (h = null), (o = 'identify' + o))
                      : ((o = 'mask' + o),
                        (R = b ? O(b.replace(/([a-z])([A-Z])/g, '$1 $2')) : 'Opera'),
                        /\bIE\b/.test(o) && (h = null),
                        E || (S = null)),
                    (_ = ['Presto']),
                    w.push(o))
            else R += ' Mobile'
            ;(o = (/\bAppleWebKit\/([\d.]+\+?)/i.exec(i) || 0)[1]) &&
              ((o = [parseFloat(o.replace(/\.(\d)$/, '.0$1')), o]),
              'Safari' == R && '+' == o[1].slice(-1)
                ? ((R = 'WebKit Nightly'), (C = 'alpha'), (S = o[1].slice(0, -1)))
                : (S != o[1] && S != (o[2] = (/\bSafari\/([\d.]+\+?)/i.exec(i) || 0)[1])) || (S = null),
              (o[1] = (/\b(?:Headless)?Chrome\/([\d.]+)/i.exec(i) || 0)[1]),
              537.36 == o[0] && 537.36 == o[2] && 28 <= parseFloat(o[1]) && 'WebKit' == _ && (_ = ['Blink']),
              (o =
                E && (s || o[1])
                  ? (_ && (_[1] = 'like Chrome'),
                    o[1] ||
                      ((o = o[0]) < 530
                        ? 1
                        : o < 532
                        ? 2
                        : o < 532.05
                        ? 3
                        : o < 533
                        ? 4
                        : o < 534.03
                        ? 5
                        : o < 534.07
                        ? 6
                        : o < 534.1
                        ? 7
                        : o < 534.13
                        ? 8
                        : o < 534.16
                        ? 9
                        : o < 534.24
                        ? 10
                        : o < 534.3
                        ? 11
                        : o < 535.01
                        ? 12
                        : o < 535.02
                        ? '13+'
                        : o < 535.07
                        ? 15
                        : o < 535.11
                        ? 16
                        : o < 535.19
                        ? 17
                        : o < 536.05
                        ? 18
                        : o < 536.1
                        ? 19
                        : o < 537.01
                        ? 20
                        : o < 537.11
                        ? '21+'
                        : o < 537.13
                        ? 23
                        : o < 537.18
                        ? 24
                        : o < 537.24
                        ? 25
                        : o < 537.36
                        ? 26
                        : 'Blink' != _
                        ? '27'
                        : '28'))
                  : (_ && (_[1] = 'like Safari'),
                    (o = o[0]) < 400
                      ? 1
                      : o < 500
                      ? 2
                      : o < 526
                      ? 3
                      : o < 533
                      ? 4
                      : o < 534
                      ? '4+'
                      : o < 535
                      ? 5
                      : o < 537
                      ? 6
                      : o < 538
                      ? 7
                      : o < 601
                      ? 8
                      : o < 602
                      ? 9
                      : o < 604
                      ? 10
                      : o < 606
                      ? 11
                      : o < 608
                      ? 12
                      : '12')),
              _ && (_[1] += ' ' + (o += 'number' == typeof o ? '.x' : /[.+]/.test(o) ? '' : '+')),
              'Safari' == R && (!S || 45 < parseInt(S))
                ? (S = o)
                : 'Chrome' == R && /\bHeadlessChrome/i.test(i) && w.unshift('headless')),
              'Opera' == R && (o = /\bzbov|zvav$/.exec(h))
                ? ((R += ' '),
                  w.unshift('desktop mode'),
                  'zvav' == o ? ((R += 'Mini'), (S = null)) : (R += 'Mobile'),
                  (h = h.replace(RegExp(' *' + o + '$'), '')))
                : 'Safari' == R && /\bChrome\b/.exec(_ && _[1])
                ? (w.unshift('desktop mode'),
                  (R = 'Chrome Mobile'),
                  (S = null),
                  (h = /\bOS X\b/.test(h) ? ((u = 'Apple'), 'iOS 4.3+') : null))
                : /\bSRWare Iron\b/.test(R) && !S && (S = N('Chrome')),
              (h = S && 0 == S.indexOf((o = /[\d.]+$/.exec(h))) && -1 < i.indexOf('/' + o + '-') ? L(h.replace(o, '')) : h) &&
                -1 != h.indexOf(R) &&
                !RegExp(R + ' OS').test(h) &&
                (h = h.replace(RegExp(' *' + P(R) + ' *'), '')),
              _ &&
                !/\b(?:Avant|Nook)\b/.test(R) &&
                (/Browser|Lunascape|Maxthon/.test(R) ||
                  ('Safari' != R && /^iOS/.test(h) && /\bSafari\b/.test(_[1])) ||
                  (/^(?:Adobe|Arora|Breach|Midori|Opera|Phantom|Rekonq|Rock|Samsung Internet|Sleipnir|SRWare Iron|Vivaldi|Web)/.test(
                    R,
                  ) &&
                    _[1])) &&
                (o = _[_.length - 1]) &&
                w.push(o),
              w.length && (w = ['(' + w.join('; ') + ')']),
              u && I && I.indexOf(u) < 0 && w.push('on ' + u),
              I && w.push((/^on /.test(w[w.length - 1]) ? '' : 'on ') + I),
              h &&
                ((o = / ([\d.+]+)$/.exec(h)),
                (a = o && '/' == h.charAt(h.length - o[0].length - 1)),
                (h = {
                  architecture: 32,
                  family: o && !a ? h.replace(o[0], '') : h,
                  version: o ? o[1] : null,
                  toString: function () {
                    var t = this.version
                    return this.family + (t && !a ? ' ' + t : '') + (64 == this.architecture ? ' 64-bit' : '')
                  },
                })),
              (o = /\b(?:AMD|IA|Win|WOW|x86_|x)64\b/i.exec(x)) && !/\bi686\b/i.test(x)
                ? (h && ((h.architecture = 64), (h.family = h.family.replace(RegExp(' *' + o), ''))),
                  R &&
                    (/\bWOW64\b/i.test(i) ||
                      (E && /\w(?:86|32)$/.test(n.cpuClass || n.platform) && !/\bWin64; x64\b/i.test(i))) &&
                    w.unshift('32-bit'))
                : h && /^OS X/.test(h.family) && 'Chrome' == R && 39 <= parseFloat(S) && (h.architecture = 64),
              (i = i || null)
            n = {}
            return (
              (n.description = i),
              (n.layout = _ && _[0]),
              (n.manufacturer = u),
              (n.name = R),
              (n.prerelease = C),
              (n.product = I),
              (n.ua = i),
              (n.version = R && S),
              (n.os = h || {
                architecture: null,
                family: null,
                version: null,
                toString: function () {
                  return 'null'
                },
              }),
              (n.parse = W),
              (n.toString = function () {
                return this.description || ''
              }),
              n.version && w.unshift(S),
              n.name && w.unshift(R),
              h && R && (h != String(h).split(' ')[0] || (h != R.split(' ')[0] && !I)) && w.push(I ? '(' + h + ')' : 'on ' + h),
              w.length && (n.description = w.join(' ')),
              n
            )
          }
          e = W()
          n && t
            ? F(e, function (t, e) {
                n[e] = t
              })
            : (k.platform = e)
        }.call(u)
      })((e = { exports: {} }), e.exports),
      e.exports),
    r = function (t, e) {
      return (r =
        Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array &&
          function (t, e) {
            t.__proto__ = e
          }) ||
        function (t, e) {
          for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
        })(t, e)
    }
  function n(t, e) {
    function n() {
      this.constructor = t
    }
    r(t, e), (t.prototype = null === e ? Object.create(e) : ((n.prototype = e.prototype), new n()))
  }
  function x(i, a, s, u) {
    return new (s = s || Promise)(function (t, e) {
      function n(t) {
        try {
          o(u.next(t))
        } catch (t) {
          e(t)
        }
      }
      function r(t) {
        try {
          o(u.throw(t))
        } catch (t) {
          e(t)
        }
      }
      function o(e) {
        e.done
          ? t(e.value)
          : new s(function (t) {
              t(e.value)
            }).then(n, r)
      }
      o((u = u.apply(i, a || [])).next())
    })
  }
  function w(n, r) {
    var o,
      i,
      a,
      s = {
        label: 0,
        sent: function () {
          if (1 & a[0]) throw a[1]
          return a[1]
        },
        trys: [],
        ops: [],
      },
      t = { next: e(0), throw: e(1), return: e(2) }
    return (
      'function' == typeof Symbol &&
        (t[Symbol.iterator] = function () {
          return this
        }),
      t
    )
    function e(e) {
      return function (t) {
        return (function (e) {
          if (o) throw new TypeError('Generator is already executing.')
          for (; s; )
            try {
              if (
                ((o = 1),
                i &&
                  (a = 2 & e[0] ? i.return : e[0] ? i.throw || ((a = i.return) && a.call(i), 0) : i.next) &&
                  !(a = a.call(i, e[1])).done)
              )
                return a
              switch (((i = 0), (e = a ? [2 & e[0], a.value] : e)[0])) {
                case 0:
                case 1:
                  a = e
                  break
                case 4:
                  return s.label++, { value: e[1], done: !1 }
                case 5:
                  s.label++, (i = e[1]), (e = [0])
                  continue
                case 7:
                  ;(e = s.ops.pop()), s.trys.pop()
                  continue
                default:
                  if (!(a = 0 < (a = s.trys).length && a[a.length - 1]) && (6 === e[0] || 2 === e[0])) {
                    s = 0
                    continue
                  }
                  if (3 === e[0] && (!a || (e[1] > a[0] && e[1] < a[3]))) {
                    s.label = e[1]
                    break
                  }
                  if (6 === e[0] && s.label < a[1]) {
                    ;(s.label = a[1]), (a = e)
                    break
                  }
                  if (a && s.label < a[2]) {
                    ;(s.label = a[2]), s.ops.push(e)
                    break
                  }
                  a[2] && s.ops.pop(), s.trys.pop()
                  continue
              }
              e = r.call(n, s)
            } catch (t) {
              ;(e = [6, t]), (i = 0)
            } finally {
              o = a = 0
            }
          if (5 & e[0]) throw e[1]
          return { value: e[0] ? e[1] : void 0, done: !0 }
        })([e, t])
      }
    }
  }
  var o =
    ((a.prototype.setPlatform = function (t, e) {
      null != this.platform &&
        console.warn('Platform ' + this.platformName + ' has already been set. Overwriting the platform with ' + e + '.'),
        (this.platformName = t),
        (this.platform = e)
    }),
    (a.prototype.registerFlag = function (t, e, n) {
      ;(this.flagRegistry[t] = { evaluationFn: e, setHook: n }),
        null != this.urlFlags[t] &&
          ((n = this.urlFlags[t]), console.warn('Setting feature override from URL ' + t + ': ' + n + '.'), this.set(t, n))
    }),
    (a.prototype.get = function (t) {
      return t in this.flags || (this.flags[t] = this.evaluateFlag(t)), this.flags[t]
    }),
    (a.prototype.getNumber = function (t) {
      return this.get(t)
    }),
    (a.prototype.getBool = function (t) {
      return this.get(t)
    }),
    (a.prototype.getFlags = function () {
      return this.flags
    }),
    Object.defineProperty(a.prototype, 'features', {
      get: function () {
        return this.flags
      },
      enumerable: !0,
      configurable: !0,
    }),
    (a.prototype.set = function (t, e) {
      if (null == this.flagRegistry[t]) throw new Error('Cannot set flag ' + t + ' as it has not been registered.')
      ;(this.flags[t] = e), null != this.flagRegistry[t].setHook && this.flagRegistry[t].setHook(e)
    }),
    (a.prototype.evaluateFlag = function (t) {
      if (null == this.flagRegistry[t]) throw new Error("Cannot evaluate flag '" + t + "': no evaluation function found.")
      return this.flagRegistry[t].evaluationFn()
    }),
    (a.prototype.setFlags = function (t) {
      this.flags = Object.assign({}, t)
    }),
    (a.prototype.reset = function () {
      ;(this.flags = {}), (this.urlFlags = {}), this.populateURLFlags()
    }),
    (a.prototype.populateURLFlags = function () {
      var a,
        t,
        n = this
      void 0 !== this.global &&
        void 0 !== this.global.location &&
        void 0 !== this.global.location.search &&
        ((t = this.global.location.search),
        (a = {}),
        t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, function (t) {
          for (var e, n, r, o = [], i = 1; i < arguments.length; i++) o[i - 1] = arguments[i]
          return (e = a), (n = o[0]), (r = o[1]), (e[decodeURIComponent(n)] = decodeURIComponent(r || '')), o.join('=')
        }),
        'tfjsflags' in (t = a) &&
          t.tfjsflags.split(',').forEach(function (t) {
            var e = t.split(':'),
              t = e[0],
              e = e[1]
            n.urlFlags[t] = (function (t, e) {
              if ('true' === (e = e.toLowerCase()) || 'false' === e) return 'true' === e
              if ('' + +e === e) return +e
              throw new Error('Could not parse value flag value ' + e + ' for flag ' + t + '.')
            })(t, e)
          }))
    }),
    a)
  function a(t) {
    ;(this.global = t), (this.flags = {}), (this.flagRegistry = {}), (this.urlFlags = {}), this.populateURLFlags()
  }
  var f = null,
    s = new Map(),
    c = new Map()
  function g(t, e) {
    e = p(t, e)
    return s.get(e)
  }
  function l(t) {
    for (var e = s.entries(), n = []; ; ) {
      var r = e.next(),
        o = r.done,
        r = r.value
      if (o) break
      ;(o = r[0]), (r = r[1])
      o.split('_')[0] === t && n.push(r)
    }
    return n
  }
  function h(t) {
    var e = t.kernelName,
      n = t.backendName,
      r = p(e, n)
    if (s.has(r)) throw new Error("The kernel '" + e + "' for backend '" + n + "' is already registered")
    s.set(r, t)
  }
  function p(t, e) {
    return e + '_' + t
  }
  function d(t) {
    for (var e, n, r = t.length; 0 < r; ) (n = (Math.random() * r) | 0), (e = t[--r]), (t[r] = t[n]), (t[n] = e)
  }
  function v(t, e, n) {
    return Math.max(t, Math.min(e, n))
  }
  function C(t) {
    return t % 2 == 0 ? t : t + 1
  }
  function m(t) {
    for (var e = 0, n = 0; n < t.length; n++) e += t[n]
    return e
  }
  function A(t, e) {
    if (!t) throw new Error('string' == typeof e ? e : e())
  }
  function y(t, e, n) {
    void 0 === n && (n = ''),
      A(S(t, e), function () {
        return n + ' Shapes ' + t + ' and ' + e + ' must match'
      })
  }
  function b(t) {
    A(null != t, function () {
      return 'The input to the tensor constructor must be a non-null value.'
    })
  }
  function E(t, e, n) {
    if ((void 0 === n && (n = !1), null == (e = void 0 === e ? [] : e) && (e = []), Array.isArray(t) || (z(t) && !n)))
      for (var r = 0; r < t.length; ++r) E(t[r], e, n)
    else e.push(t)
    return e
  }
  function D(t) {
    if (0 === t.length) return 1
    for (var e = t[0], n = 1; n < t.length; n++) e *= t[n]
    return e
  }
  function S(t, e) {
    if (t === e) return !0
    if (null == t || null == e) return !1
    if (t.length !== e.length) return !1
    for (var n = 0; n < t.length; n++) if (t[n] !== e[n]) return !1
    return !0
  }
  function N(t) {
    return t % 1 == 0
  }
  function _(t) {
    if (null != Math.tanh) return Math.tanh(t)
    if (t === 1 / 0) return 1
    if (t === -1 / 0) return -1
    t = Math.exp(2 * t)
    return (t - 1) / (t + 1)
  }
  function R(t) {
    var e = Math.ceil(Math.sqrt(t))
    return [e, Math.ceil(t / e)]
  }
  function I(t, e) {
    return e <= t.length ? t : t + ' '.repeat(e - t.length)
  }
  function k(i, a, s) {
    return (
      void 0 === a &&
        (a = function (t) {
          return 0
        }),
      new Promise(function (e, n) {
        var r = 0,
          o = function () {
            var t
            i() ? e() : ((t = a(++r)), null != s && s <= r ? n() : setTimeout(o, t))
          }
        o()
      })
    )
  }
  function T(t, e) {
    for (var n = 1, r = -1, o = 0; o < t.length; ++o)
      if (0 <= t[o]) n *= t[o]
      else if (-1 === t[o]) {
        if (-1 !== r) throw Error('Shapes can only have 1 implicit size. Found -1 at dim ' + r + ' and dim ' + o)
        r = o
      } else if (t[o] < 0) throw Error('Shapes can not be < 0. Found ' + t[o] + ' at dim ' + o)
    if (-1 === r) {
      if (0 < e && e !== n) throw Error('Size(' + e + ') must match the product of shape ' + t)
      return t
    }
    if (0 === n) throw Error('Cannot infer the missing size in [' + t + '] when there are 0 elements')
    if (e % n != 0) throw Error("The implicit shape can't be a fractional number. Got " + e + ' / ' + n)
    var i = t.slice()
    return (i[r] = e / n), i
  }
  function O(t, e) {
    var n = e.length
    return (
      A(
        (t =
          null == t
            ? e.map(function (t, e) {
                return e
              })
            : [].concat(t)).every(function (t) {
          return -n <= t && t < n
        }),
        function () {
          return 'All values in axis param must be in range [-' + n + ', ' + n + ') but got axis ' + t
        },
      ),
      A(t.every(N), function () {
        return 'All values in axis param must be integers but got axis ' + t
      }),
      t.map(function (t) {
        return t < 0 ? n + t : t
      })
    )
  }
  function F(t, e) {
    for (
      var n = [],
        r = [],
        o = null != e && Array.isArray(e) && 0 === e.length,
        i = null == e || o ? null : O(e, t).sort(),
        a = 0,
        s = 0;
      s < t.length;
      ++s
    ) {
      if (null != i) {
        if (i[a] === s && 1 !== t[s]) throw new Error("Can't squeeze axis " + s + " since its dim '" + t[s] + "' is not 1")
        ;(null == i[a] || i[a] > s) && 1 === t[s] && (n.push(t[s]), r.push(s)), i[a] <= s && a++
      }
      1 !== t[s] && (n.push(t[s]), r.push(s))
    }
    return { newShape: n, keptDims: r }
  }
  function M(t, e) {
    var n = null
    if (null == t || 'float32' === t) n = new Float32Array(e)
    else if ('int32' === t) n = new Int32Array(e)
    else {
      if ('bool' !== t) throw new Error('Unknown data type ' + t)
      n = new Uint8Array(e)
    }
    return n
  }
  function P(t, e) {
    var n = null
    if (null == t || 'float32' === t) n = new Float32Array(e)
    else if ('int32' === t) n = new Int32Array(e)
    else if ('bool' === t) n = new Uint8Array(e)
    else {
      if ('string' !== t) throw new Error('Unknown data type ' + t)
      n = new Array(e)
    }
    return n
  }
  function B(t, e) {
    for (var n = 0; n < t.length; n++) {
      var r = t[n]
      if (isNaN(r) || !isFinite(r)) throw Error('A tensor of type ' + e + ' being uploaded contains ' + r + '.')
    }
  }
  function L(t) {
    return 'bool' === t || 'complex64' === t || 'float32' === t || 'int32' === t || 'string' === t
  }
  function W(t, e) {
    return !(
      'complex64' === e ||
      ('float32' === e && 'complex64' !== t) ||
      ('int32' === e && 'float32' !== t && 'complex64' !== t) ||
      ('bool' === e && 'bool' === t)
    )
  }
  function z(t) {
    return t instanceof Float32Array || t instanceof Int32Array || t instanceof Uint8Array
  }
  function G(t) {
    if ('float32' === t || 'int32' === t) return 4
    if ('complex64' === t) return 8
    if ('bool' === t) return 1
    throw new Error('Unknown dtype ' + t)
  }
  function U(t) {
    if (null == t) return 0
    var e = 0
    return (
      t.forEach(function (t) {
        return (e += t.length)
      }),
      e
    )
  }
  function V(t) {
    return 'string' == typeof t || t instanceof String
  }
  function H(t) {
    return 'boolean' == typeof t
  }
  function j(t) {
    return 'number' == typeof t
  }
  function q(t) {
    return Array.isArray(t)
      ? q(t[0])
      : t instanceof Float32Array
      ? 'float32'
      : t instanceof Int32Array || t instanceof Uint8Array
      ? 'int32'
      : j(t)
      ? 'float32'
      : V(t)
      ? 'string'
      : H(t)
      ? 'bool'
      : 'float32'
  }
  function K(t) {
    return !!(t && t.constructor && t.call && t.apply)
  }
  function X(t, e) {
    for (var n = e; n < t; ++n) if (t % n == 0) return n
    return t
  }
  function $(t) {
    var e = t.length
    if (e < 2) return []
    var n = new Array(e - 1)
    n[e - 2] = t[e - 1]
    for (var r = e - 3; 0 <= r; --r) n[r] = n[r + 1] * t[r + 1]
    return n
  }
  function Y(t, e, n) {
    if ('string' === e) throw new Error('Cannot convert a string[] to a TypedArray')
    if (
      (Array.isArray(t) && (t = E(t)),
      n && B(t, e),
      (t instanceof Float32Array && 'float32' === e) ||
        (t instanceof Int32Array && 'int32' === e) ||
        (t instanceof Uint8Array && 'bool' === e))
    )
      return t
    if (null == e || 'float32' === e || 'complex64' === e) return new Float32Array(t)
    if ('int32' === e) return new Int32Array(t)
    if ('bool' !== e) throw new Error('Unknown data type ' + e)
    for (var r = new Uint8Array(t.length), o = 0; o < r.length; ++o) 0 !== Math.round(t[o]) && (r[o] = 1)
    return r
  }
  function J(t, e) {
    if (0 === t.length) return e[0]
    var n = t.reduce(function (t, e) {
      return t * e
    })
    if (0 === n) return []
    if (n !== e.length) throw new Error('[' + t + '] does not match the input size.')
    return (function t(e, n, r) {
      var o = new Array()
      if (1 === n.length) for (var i = n[0], a = 0; a < i; a++) o[a] = r[e + a]
      else
        for (
          var i = n[0],
            s = n.slice(1),
            u = s.reduce(function (t, e) {
              return t * e
            }),
            a = 0;
          a < i;
          a++
        )
          o[a] = t(e + a * u, s, r)
      return o
    })(0, t, e)
  }
  function Q(t, e) {
    for (var n = Z(t, e), r = 0; r < n.length; r++) n[r] = 1
    return n
  }
  function Z(t, e) {
    if (null == e || 'float32' === e || 'complex64' === e) return new Float32Array(t)
    if ('int32' === e) return new Int32Array(t)
    if ('bool' === e) return new Uint8Array(t)
    throw new Error('Unknown data type ' + e)
  }
  function tt() {
    return f.platform.now()
  }
  function et(e) {
    e.forEach(function (t) {
      A(Number.isInteger(t) && 0 <= t, function () {
        return 'Tensor must have a shape comprised of positive integers but got shape [' + e + '].'
      })
    })
  }
  function nt(t, e) {
    return (e = (e = void 0 === e ? 'utf-8' : e) || 'utf-8'), f.platform.encode(t, e)
  }
  function rt(t, e) {
    return (e = (e = void 0 === e ? 'utf-8' : e) || 'utf-8'), f.platform.decode(t, e)
  }
  function ot(t, e, n) {
    if (0 === e) return 0
    if (1 === e) return t[0]
    for (var r = t[t.length - 1], o = 0; o < t.length - 1; ++o) r += n[o] * t[o]
    return r
  }
  function it(t, e, n) {
    if (0 === e) return []
    if (1 === e) return [t]
    for (var r = new Array(e), o = 0; o < r.length - 1; ++o) (r[o] = Math.floor(t / n[o])), (t -= r[o] * n[o])
    return (r[r.length - 1] = t), r
  }
  Object.freeze({
    shuffle: d,
    clamp: v,
    nearestLargerEven: C,
    sum: m,
    randUniform: function (t, e) {
      var n = Math.random()
      return e * n + (1 - n) * t
    },
    distSquared: function (t, e) {
      for (var n = 0, r = 0; r < t.length; r++) {
        var o = Number(t[r]) - Number(e[r])
        n += o * o
      }
      return n
    },
    assert: A,
    assertShapesMatch: y,
    assertNonNull: b,
    flatten: E,
    sizeFromShape: D,
    isScalarShape: function (t) {
      return 0 === t.length
    },
    arraysEqual: S,
    isInt: N,
    tanh: _,
    sizeToSquarishShape: R,
    createShuffledIndices: function (t) {
      for (var e = new Uint32Array(t), n = 0; n < t; ++n) e[n] = n
      return d(e), e
    },
    rightPad: I,
    repeatedTry: k,
    inferFromImplicitShape: T,
    parseAxisParam: O,
    squeezeShape: F,
    getTypedArrayFromDType: M,
    getArrayFromDType: P,
    checkConversionForErrors: B,
    isValidDtype: L,
    hasEncodingLoss: W,
    isTypedArray: z,
    bytesPerElement: G,
    bytesFromStringArray: U,
    isString: V,
    isBoolean: H,
    isNumber: j,
    inferDtype: q,
    isFunction: K,
    nearestDivisor: X,
    computeStrides: $,
    toTypedArray: Y,
    toNestedArray: J,
    makeOnesTypedArray: Q,
    makeZerosTypedArray: Z,
    now: tt,
    assertNonNegativeIntegerDimensions: et,
    fetch: function (t, e) {
      return f.platform.fetch(t, e)
    },
    encodeString: nt,
    decodeString: rt,
    locToIndex: ot,
    indexToLoc: it,
  })
  var at =
    ((st.prototype.profileKernel = function (o, i, t) {
      var e,
        a = this,
        s = this.backendTimer.time(function () {
          e = t()
        })
      return (
        e.forEach(function (r) {
          r.data().then(function (n) {
            !(function (t, e, n) {
              if ('float32' === e)
                for (var r = 0; r < t.length; r++) {
                  var o = t[r]
                  if (isNaN(o) || !isFinite(o)) return console.warn('Found ' + o + " in the result of '" + n + "'")
                }
            })(n, r.dtype, o),
              s.then(function (t) {
                var e = ''
                null != t.getExtraProfileInfo && (e = t.getExtraProfileInfo()),
                  a.logger.logKernelProfile(o, r, n, t.kernelMs, i, e)
              })
          })
        }),
        e
      )
    }),
    st)
  function st(t, e) {
    ;(this.backendTimer = t), null == (this.logger = e) && (this.logger = new ut())
  }
  var ut =
    ((ct.prototype.logKernelProfile = function (t, e, n, r, o, i) {
      var a,
        s = 'number' == typeof r ? I(r + 'ms', 9) : r.error,
        u = I(t, 25),
        c = e.rank,
        r = e.size,
        t = I(e.shape.toString(), 14),
        l = ''
      for (a in o) {
        var h = o[a].shape || e.shape,
          p = h.length
        l += a + ': ' + p + 'D ' + (0 < p ? h : '') + ' '
      }
      console.log(
        '%c' + u + '\t%c' + s + '\t%c' + c + 'D ' + t + '\t%c' + r + '\t%c' + l + '\t%c' + i,
        'font-weight:bold',
        'color:red',
        'color:blue',
        'color: orange',
        'color: green',
        'color: steelblue',
      )
    }),
    ct)
  function ct() {}
  var lt = 7
  function ht(t, e, n) {
    return I(
      Array.isArray(t)
        ? parseFloat(t[0].toFixed(lt)) + ' + ' + parseFloat(t[1].toFixed(lt)) + 'j'
        : V(t)
        ? "'" + t + "'"
        : 'bool' === n
        ? pt(t)
        : parseFloat(t.toFixed(lt)).toString(),
      e,
    )
  }
  function pt(t) {
    return 0 === t ? 'false' : 'true'
  }
  function dt(t) {
    for (var e = [], n = 0; n < t.length; n += 2) e.push([t[n], t[n + 1]])
    return e
  }
  var ft =
      ((yt.prototype.set = function (t) {
        for (var e = this, n = [], r = 1; r < arguments.length; r++) n[r - 1] = arguments[r]
        A((n = 0 === n.length ? [0] : n).length === this.rank, function () {
          return 'The number of provided coordinates (' + n.length + ') must match the rank (' + e.rank + ')'
        })
        var o = this.locToIndex(n)
        this.values[o] = t
      }),
      (yt.prototype.get = function () {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e]
        for (var n = 0, r = 0, o = (t = 0 === t.length ? [0] : t); r < o.length; r++) {
          var i = o[r]
          if (i < 0 || i >= this.shape[n]) {
            i = 'Requested out of range element at ' + t + '.   Buffer shape=' + this.shape
            throw new Error(i)
          }
          n++
        }
        for (var a = t[t.length - 1], s = 0; s < t.length - 1; ++s) a += this.strides[s] * t[s]
        return this.values[a]
      }),
      (yt.prototype.locToIndex = function (t) {
        if (0 === this.rank) return 0
        if (1 === this.rank) return t[0]
        for (var e = t[t.length - 1], n = 0; n < t.length - 1; ++n) e += this.strides[n] * t[n]
        return e
      }),
      (yt.prototype.indexToLoc = function (t) {
        if (0 === this.rank) return []
        if (1 === this.rank) return [t]
        for (var e = new Array(this.shape.length), n = 0; n < e.length - 1; ++n)
          (e[n] = Math.floor(t / this.strides[n])), (t -= e[n] * this.strides[n])
        return (e[e.length - 1] = t), e
      }),
      Object.defineProperty(yt.prototype, 'rank', {
        get: function () {
          return this.shape.length
        },
        enumerable: !0,
        configurable: !0,
      }),
      (yt.prototype.toTensor = function () {
        return vt().makeTensor(this.values, this.shape, this.dtype)
      }),
      yt),
    vt = null,
    mt = null,
    gt = null
  function yt(t, e, n) {
    var r,
      o = this
    if (
      ((this.dtype = e),
      (this.shape = t.slice()),
      (this.size = D(t)),
      null != n &&
        A((r = n.length) === this.size, function () {
          return "Length of values '" + r + "' does not match the size inferred by the shape '" + o.size + "'."
        }),
      'complex64' === e)
    )
      throw new Error(
        'complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).',
      )
    ;(this.values = n || P(e, this.size)), (this.strides = $(t))
  }
  var bt =
    ((xt.prototype.flatten = function () {
      return this.throwIfDisposed(), this.as1D()
    }),
    (xt.prototype.asScalar = function () {
      return (
        this.throwIfDisposed(),
        A(1 === this.size, function () {
          return 'The array must have only 1 element.'
        }),
        this.reshape([])
      )
    }),
    (xt.prototype.as1D = function () {
      return this.throwIfDisposed(), this.reshape([this.size])
    }),
    (xt.prototype.as2D = function (t, e) {
      return this.throwIfDisposed(), this.reshape([t, e])
    }),
    (xt.prototype.as3D = function (t, e, n) {
      return this.throwIfDisposed(), this.reshape([t, e, n])
    }),
    (xt.prototype.as4D = function (t, e, n, r) {
      return this.throwIfDisposed(), this.reshape([t, e, n, r])
    }),
    (xt.prototype.as5D = function (t, e, n, r, o) {
      return this.throwIfDisposed(), this.reshape([t, e, n, r, o])
    }),
    (xt.prototype.asType = function (t) {
      return this.throwIfDisposed(), mt.cast(this, t)
    }),
    Object.defineProperty(xt.prototype, 'rank', {
      get: function () {
        return this.shape.length
      },
      enumerable: !0,
      configurable: !0,
    }),
    (xt.prototype.buffer = function () {
      return x(this, void 0, void 0, function () {
        var e
        return w(this, function (t) {
          switch (t.label) {
            case 0:
              return [4, this.data()]
            case 1:
              return (e = t.sent()), [2, mt.buffer(this.shape, this.dtype, e)]
          }
        })
      })
    }),
    (xt.prototype.bufferSync = function () {
      return mt.buffer(this.shape, this.dtype, this.dataSync())
    }),
    (xt.prototype.array = function () {
      return x(this, void 0, void 0, function () {
        var e
        return w(this, function (t) {
          switch (t.label) {
            case 0:
              return [4, this.data()]
            case 1:
              return (e = t.sent()), [2, J(this.shape, e)]
          }
        })
      })
    }),
    (xt.prototype.arraySync = function () {
      return J(this.shape, this.dataSync())
    }),
    (xt.prototype.data = function () {
      return x(this, void 0, void 0, function () {
        var e, n
        return w(this, function (t) {
          switch (t.label) {
            case 0:
              return this.throwIfDisposed(), (e = vt().read(this.dataId)), 'string' !== this.dtype ? [3, 2] : [4, e]
            case 1:
              n = t.sent()
              try {
                return [
                  2,
                  n.map(function (t) {
                    return rt(t)
                  }),
                ]
              } catch (t) {
                throw new Error('Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().')
              }
              t.label = 2
            case 2:
              return [2, e]
          }
        })
      })
    }),
    (xt.prototype.dataSync = function () {
      this.throwIfDisposed()
      var t = vt().readSync(this.dataId)
      if ('string' === this.dtype)
        try {
          return t.map(function (t) {
            return rt(t)
          })
        } catch (t) {
          throw new Error('Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().')
        }
      return t
    }),
    (xt.prototype.bytes = function () {
      return x(this, void 0, void 0, function () {
        var e
        return w(this, function (t) {
          switch (t.label) {
            case 0:
              return this.throwIfDisposed(), [4, vt().read(this.dataId)]
            case 1:
              return (e = t.sent()), 'string' === this.dtype ? [2, e] : [2, new Uint8Array(e.buffer)]
          }
        })
      })
    }),
    (xt.prototype.dispose = function () {
      this.isDisposed || (vt().disposeTensor(this), (this.isDisposedInternal = !0))
    }),
    Object.defineProperty(xt.prototype, 'isDisposed', {
      get: function () {
        return this.isDisposedInternal
      },
      enumerable: !0,
      configurable: !0,
    }),
    (xt.prototype.throwIfDisposed = function () {
      if (this.isDisposed) throw new Error('Tensor is disposed.')
    }),
    (xt.prototype.toFloat = function () {
      return this.asType('float32')
    }),
    (xt.prototype.toInt = function () {
      return this.asType('int32')
    }),
    (xt.prototype.toBool = function () {
      return this.asType('bool')
    }),
    (xt.prototype.print = function (t) {
      return void 0 === t && (t = !1), mt.print(this, t)
    }),
    (xt.prototype.reshape = function (t) {
      return this.throwIfDisposed(), mt.reshape(this, t)
    }),
    (xt.prototype.reshapeAs = function (t) {
      return this.throwIfDisposed(), this.reshape(t.shape)
    }),
    (xt.prototype.expandDims = function (t) {
      return void 0 === t && (t = 0), mt.expandDims(this, t)
    }),
    (xt.prototype.cumsum = function (t, e, n) {
      return void 0 === t && (t = 0), void 0 === e && (e = !1), void 0 === n && (n = !1), mt.cumsum(this, t, e, n)
    }),
    (xt.prototype.squeeze = function (t) {
      return this.throwIfDisposed(), mt.squeeze(this, t)
    }),
    (xt.prototype.clone = function () {
      return this.throwIfDisposed(), mt.clone(this)
    }),
    (xt.prototype.oneHot = function (t, e, n) {
      return this.throwIfDisposed(), mt.oneHot(this, t, e, n)
    }),
    (xt.prototype.toString = function (t) {
      return (
        void 0 === t && (t = !1),
        (e = this.dataSync()),
        (n = this.shape),
        (r = this.dtype),
        (o = t),
        (i = $(n)),
        (a = (function (t, e, n, r) {
          var o = D(e),
            i = r[r.length - 1],
            a = new Array(i).fill(0),
            e = e.length,
            s = 'complex64' === n ? dt(t) : t
          if (1 < e)
            for (var u = 0; u < o / i; u++)
              for (var c = u * i, l = 0; l < i; l++) a[l] = Math.max(a[l], ht(s[c + l], 0, n).length)
          return a
        })(e, n, r, i)),
        (t = n.length),
        (i = (function t(e, n, r, o, i, a) {
          void 0 === a && (a = !0)
          var s = 'complex64' === r ? 2 : 1,
            u = n[0],
            c = n.length
          if (0 === c) return 'complex64' === r ? [ht(dt(e)[0], 0, r)] : 'bool' === r ? [pt(e[0])] : [e[0].toString()]
          if (1 === c) {
            if (20 < u) {
              var l = 3 * s,
                h = Array.from(e.slice(0, l)),
                l = Array.from(e.slice((u - 3) * s, u * s))
              return (
                'complex64' === r && ((h = dt(h)), (l = dt(l))),
                [
                  '[' +
                    h
                      .map(function (t, e) {
                        return ht(t, i[e], r)
                      })
                      .join(', ') +
                    ', ..., ' +
                    l
                      .map(function (t, e) {
                        return ht(t, i[u - 3 + e], r)
                      })
                      .join(', ') +
                    ']',
                ]
              )
            }
            return [
              '[' +
                ('complex64' === r ? dt(e) : Array.from(e))
                  .map(function (t, e) {
                    return ht(t, i[e], r)
                  })
                  .join(', ') +
                ']',
            ]
          }
          var p = n.slice(1),
            d = o.slice(1),
            f = o[0] * s,
            v = []
          if (20 < u) {
            for (var m = 0; m < 3; m++) {
              var g = (y = m * f) + f
              v.push.apply(v, t(e.slice(y, g), p, r, d, i, !1))
            }
            for (v.push('...'), m = u - 3; m < u; m++)
              (g = (y = m * f) + f), v.push.apply(v, t(e.slice(y, g), p, r, d, i, m === u - 1))
          } else
            for (m = 0; m < u; m++) {
              var y,
                g = (y = m * f) + f
              v.push.apply(v, t(e.slice(y, g), p, r, d, i, m === u - 1))
            }
          var b = 2 === c ? ',' : ''
          for (v[0] = '[' + v[0] + b, m = 1; m < v.length - 1; m++) v[m] = ' ' + v[m] + b
          for (var x = ',\n', m = 2; m < c; m++) x += '\n'
          return (v[v.length - 1] = ' ' + v[v.length - 1] + ']' + (a ? '' : x)), v
        })(e, n, r, i, a)),
        (a = ['Tensor']),
        o && (a.push('  dtype: ' + r), a.push('  rank: ' + t), a.push('  shape: [' + n + ']'), a.push('  values:')),
        a.push(
          i
            .map(function (t) {
              return '    ' + t
            })
            .join('\n'),
        ),
        a.join('\n')
      )
      var e, n, r, o, i, a
    }),
    (xt.prototype.tile = function (t) {
      return this.throwIfDisposed(), mt.tile(this, t)
    }),
    (xt.prototype.gather = function (t, e) {
      return void 0 === e && (e = 0), this.throwIfDisposed(), mt.gather(this, t, e)
    }),
    (xt.prototype.matMul = function (t, e, n) {
      return void 0 === e && (e = !1), void 0 === n && (n = !1), this.throwIfDisposed(), mt.matMul(this, t, e, n)
    }),
    (xt.prototype.dot = function (t) {
      return this.throwIfDisposed(), mt.dot(this, t)
    }),
    (xt.prototype.norm = function (t, e, n) {
      return (
        void 0 === t && (t = 'euclidean'),
        void 0 === e && (e = null),
        void 0 === n && (n = !1),
        this.throwIfDisposed(),
        mt.norm(this, t, e, n)
      )
    }),
    (xt.prototype.slice = function (t, e) {
      return this.throwIfDisposed(), mt.slice(this, t, e)
    }),
    (xt.prototype.reverse = function (t) {
      return this.throwIfDisposed(), mt.reverse(this, t)
    }),
    (xt.prototype.concat = function (t, e) {
      return void 0 === e && (e = 0), this.throwIfDisposed(), t instanceof xt && (t = [t]), mt.concat([this].concat(t), e)
    }),
    (xt.prototype.split = function (t, e) {
      return void 0 === e && (e = 0), this.throwIfDisposed(), mt.split(this, t, e)
    }),
    (xt.prototype.stack = function (t, e) {
      return void 0 === e && (e = 0), mt.stack([this, t], e)
    }),
    (xt.prototype.unstack = function (t) {
      return void 0 === t && (t = 0), mt.unstack(this, t)
    }),
    (xt.prototype.pad = function (t, e) {
      return void 0 === e && (e = 0), mt.pad(this, t, e)
    }),
    (xt.prototype.batchNormalization = function (t, e, n, r, o) {
      return (
        void 0 === n && (n = 0.001),
        gt(
          'tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon',
        ),
        this.batchNorm(t, e, o, r, n)
      )
    }),
    (xt.prototype.batchNorm = function (t, e, n, r, o) {
      return void 0 === o && (o = 0.001), this.throwIfDisposed(), mt.batchNorm(this, t, e, n, r, o)
    }),
    (xt.prototype.all = function (t, e) {
      return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), mt.all(this, t, e)
    }),
    (xt.prototype.any = function (t, e) {
      return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), mt.any(this, t, e)
    }),
    (xt.prototype.logSumExp = function (t, e) {
      return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), mt.logSumExp(this, t, e)
    }),
    (xt.prototype.sum = function (t, e) {
      return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), mt.sum(this, t, e)
    }),
    (xt.prototype.prod = function (t, e) {
      return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), mt.prod(this, t, e)
    }),
    (xt.prototype.mean = function (t, e) {
      return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), mt.mean(this, t, e)
    }),
    (xt.prototype.min = function (t, e) {
      return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), mt.min(this, t, e)
    }),
    (xt.prototype.max = function (t, e) {
      return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), mt.max(this, t, e)
    }),
    (xt.prototype.argMin = function (t) {
      return void 0 === t && (t = null), this.throwIfDisposed(), mt.argMin(this, t)
    }),
    (xt.prototype.argMax = function (t) {
      return void 0 === t && (t = null), this.throwIfDisposed(), mt.argMax(this, t)
    }),
    (xt.prototype.cast = function (t) {
      return this.throwIfDisposed(), mt.cast(this, t)
    }),
    (xt.prototype.add = function (t) {
      return this.throwIfDisposed(), mt.add(this, t)
    }),
    (xt.prototype.addStrict = function (t) {
      return this.throwIfDisposed(), mt.addStrict(this, t)
    }),
    (xt.prototype.atan2 = function (t) {
      return this.throwIfDisposed(), mt.atan2(this, t)
    }),
    (xt.prototype.sub = function (t) {
      return this.throwIfDisposed(), mt.sub(this, t)
    }),
    (xt.prototype.subStrict = function (t) {
      return this.throwIfDisposed(), mt.subStrict(this, t)
    }),
    (xt.prototype.pow = function (t) {
      return this.throwIfDisposed(), mt.pow(this, t)
    }),
    (xt.prototype.powStrict = function (t) {
      return this.throwIfDisposed(), mt.powStrict(this, t)
    }),
    (xt.prototype.mul = function (t) {
      return this.throwIfDisposed(), mt.mul(this, t)
    }),
    (xt.prototype.mulStrict = function (t) {
      return this.throwIfDisposed(), mt.mulStrict(this, t)
    }),
    (xt.prototype.div = function (t) {
      return this.throwIfDisposed(), mt.div(this, t)
    }),
    (xt.prototype.divNoNan = function (t) {
      return this.throwIfDisposed(), mt.divNoNan(this, t)
    }),
    (xt.prototype.floorDiv = function (t) {
      return this.throwIfDisposed(), mt.floorDiv(this, t)
    }),
    (xt.prototype.divStrict = function (t) {
      return this.throwIfDisposed(), mt.divStrict(this, t)
    }),
    (xt.prototype.minimum = function (t) {
      return this.throwIfDisposed(), mt.minimum(this, t)
    }),
    (xt.prototype.minimumStrict = function (t) {
      return this.throwIfDisposed(), mt.minimumStrict(this, t)
    }),
    (xt.prototype.maximum = function (t) {
      return this.throwIfDisposed(), mt.maximum(this, t)
    }),
    (xt.prototype.maximumStrict = function (t) {
      return this.throwIfDisposed(), mt.maximumStrict(this, t)
    }),
    (xt.prototype.mod = function (t) {
      return this.throwIfDisposed(), mt.mod(this, t)
    }),
    (xt.prototype.modStrict = function (t) {
      return this.throwIfDisposed(), mt.modStrict(this, t)
    }),
    (xt.prototype.squaredDifferenceStrict = function (t) {
      return this.throwIfDisposed(), mt.squaredDifferenceStrict(this, t)
    }),
    (xt.prototype.transpose = function (t) {
      return this.throwIfDisposed(), mt.transpose(this, t)
    }),
    (xt.prototype.notEqual = function (t) {
      return this.throwIfDisposed(), mt.notEqual(this, t)
    }),
    (xt.prototype.notEqualStrict = function (t) {
      return this.throwIfDisposed(), mt.notEqualStrict(this, t)
    }),
    (xt.prototype.less = function (t) {
      return this.throwIfDisposed(), mt.less(this, t)
    }),
    (xt.prototype.lessStrict = function (t) {
      return this.throwIfDisposed(), mt.lessStrict(this, t)
    }),
    (xt.prototype.equal = function (t) {
      return this.throwIfDisposed(), mt.equal(this, t)
    }),
    (xt.prototype.equalStrict = function (t) {
      return this.throwIfDisposed(), mt.equalStrict(this, t)
    }),
    (xt.prototype.lessEqual = function (t) {
      return this.throwIfDisposed(), mt.lessEqual(this, t)
    }),
    (xt.prototype.lessEqualStrict = function (t) {
      return this.throwIfDisposed(), mt.lessEqualStrict(this, t)
    }),
    (xt.prototype.greater = function (t) {
      return this.throwIfDisposed(), mt.greater(this, t)
    }),
    (xt.prototype.greaterStrict = function (t) {
      return this.throwIfDisposed(), mt.greaterStrict(this, t)
    }),
    (xt.prototype.greaterEqual = function (t) {
      return this.throwIfDisposed(), mt.greaterEqual(this, t)
    }),
    (xt.prototype.greaterEqualStrict = function (t) {
      return this.throwIfDisposed(), mt.greaterEqualStrict(this, t)
    }),
    (xt.prototype.logicalAnd = function (t) {
      return this.throwIfDisposed(), mt.logicalAnd(this, t)
    }),
    (xt.prototype.logicalOr = function (t) {
      return this.throwIfDisposed(), mt.logicalOr(this, t)
    }),
    (xt.prototype.logicalNot = function () {
      return this.throwIfDisposed(), mt.logicalNot(this)
    }),
    (xt.prototype.logicalXor = function (t) {
      return this.throwIfDisposed(), mt.logicalXor(this, t)
    }),
    (xt.prototype.where = function (t, e) {
      return this.throwIfDisposed(), mt.where(t, this, e)
    }),
    (xt.prototype.neg = function () {
      return this.throwIfDisposed(), mt.neg(this)
    }),
    (xt.prototype.ceil = function () {
      return this.throwIfDisposed(), mt.ceil(this)
    }),
    (xt.prototype.floor = function () {
      return this.throwIfDisposed(), mt.floor(this)
    }),
    (xt.prototype.sign = function () {
      return this.throwIfDisposed(), mt.sign(this)
    }),
    (xt.prototype.isNaN = function () {
      return this.throwIfDisposed(), mt.isNaN(this)
    }),
    (xt.prototype.isInf = function () {
      return this.throwIfDisposed(), mt.isInf(this)
    }),
    (xt.prototype.isFinite = function () {
      return this.throwIfDisposed(), mt.isFinite(this)
    }),
    (xt.prototype.exp = function () {
      return this.throwIfDisposed(), mt.exp(this)
    }),
    (xt.prototype.expm1 = function () {
      return this.throwIfDisposed(), mt.expm1(this)
    }),
    (xt.prototype.log = function () {
      return this.throwIfDisposed(), mt.log(this)
    }),
    (xt.prototype.log1p = function () {
      return this.throwIfDisposed(), mt.log1p(this)
    }),
    (xt.prototype.sqrt = function () {
      return this.throwIfDisposed(), mt.sqrt(this)
    }),
    (xt.prototype.rsqrt = function () {
      return this.throwIfDisposed(), mt.rsqrt(this)
    }),
    (xt.prototype.square = function () {
      return this.throwIfDisposed(), mt.square(this)
    }),
    (xt.prototype.reciprocal = function () {
      return this.throwIfDisposed(), mt.reciprocal(this)
    }),
    (xt.prototype.abs = function () {
      return this.throwIfDisposed(), mt.abs(this)
    }),
    (xt.prototype.clipByValue = function (t, e) {
      return this.throwIfDisposed(), mt.clipByValue(this, t, e)
    }),
    (xt.prototype.relu = function () {
      return this.throwIfDisposed(), mt.relu(this)
    }),
    (xt.prototype.relu6 = function () {
      return this.throwIfDisposed(), mt.relu6(this)
    }),
    (xt.prototype.elu = function () {
      return this.throwIfDisposed(), mt.elu(this)
    }),
    (xt.prototype.selu = function () {
      return this.throwIfDisposed(), mt.selu(this)
    }),
    (xt.prototype.leakyRelu = function (t) {
      return void 0 === t && (t = 0.2), this.throwIfDisposed(), mt.leakyRelu(this, t)
    }),
    (xt.prototype.prelu = function (t) {
      return this.throwIfDisposed(), mt.prelu(this, t)
    }),
    (xt.prototype.sigmoid = function () {
      return this.throwIfDisposed(), mt.sigmoid(this)
    }),
    (xt.prototype.logSigmoid = function () {
      return this.throwIfDisposed(), mt.logSigmoid(this)
    }),
    (xt.prototype.softplus = function () {
      return this.throwIfDisposed(), mt.softplus(this)
    }),
    (xt.prototype.zerosLike = function () {
      return this.throwIfDisposed(), mt.zerosLike(this)
    }),
    (xt.prototype.onesLike = function () {
      return this.throwIfDisposed(), mt.onesLike(this)
    }),
    (xt.prototype.sin = function () {
      return this.throwIfDisposed(), mt.sin(this)
    }),
    (xt.prototype.cos = function () {
      return this.throwIfDisposed(), mt.cos(this)
    }),
    (xt.prototype.tan = function () {
      return this.throwIfDisposed(), mt.tan(this)
    }),
    (xt.prototype.asin = function () {
      return this.throwIfDisposed(), mt.asin(this)
    }),
    (xt.prototype.acos = function () {
      return this.throwIfDisposed(), mt.acos(this)
    }),
    (xt.prototype.atan = function () {
      return this.throwIfDisposed(), mt.atan(this)
    }),
    (xt.prototype.sinh = function () {
      return this.throwIfDisposed(), mt.sinh(this)
    }),
    (xt.prototype.cosh = function () {
      return this.throwIfDisposed(), mt.cosh(this)
    }),
    (xt.prototype.tanh = function () {
      return this.throwIfDisposed(), mt.tanh(this)
    }),
    (xt.prototype.asinh = function () {
      return this.throwIfDisposed(), mt.asinh(this)
    }),
    (xt.prototype.acosh = function () {
      return this.throwIfDisposed(), mt.acosh(this)
    }),
    (xt.prototype.atanh = function () {
      return this.throwIfDisposed(), mt.atanh(this)
    }),
    (xt.prototype.erf = function () {
      return this.throwIfDisposed(), mt.erf(this)
    }),
    (xt.prototype.round = function () {
      return this.throwIfDisposed(), mt.round(this)
    }),
    (xt.prototype.step = function (t) {
      return void 0 === t && (t = 0), this.throwIfDisposed(), mt.step(this, t)
    }),
    (xt.prototype.softmax = function (t) {
      return void 0 === t && (t = -1), this.throwIfDisposed(), mt.softmax(this, t)
    }),
    (xt.prototype.logSoftmax = function (t) {
      return void 0 === t && (t = -1), this.throwIfDisposed(), mt.logSoftmax(this, t)
    }),
    (xt.prototype.resizeBilinear = function (t, e) {
      return void 0 === e && (e = !1), this.throwIfDisposed(), mt.image.resizeBilinear(this, t, e)
    }),
    (xt.prototype.resizeNearestNeighbor = function (t, e) {
      return void 0 === e && (e = !1), this.throwIfDisposed(), mt.image.resizeNearestNeighbor(this, t, e)
    }),
    (xt.prototype.conv1d = function (t, e, n, r, o, i) {
      return void 0 === r && (r = 'NWC'), void 0 === o && (o = 1), this.throwIfDisposed(), mt.conv1d(this, t, e, n, r, o, i)
    }),
    (xt.prototype.conv2d = function (t, e, n, r, o, i) {
      return (
        void 0 === r && (r = 'NHWC'), void 0 === o && (o = [1, 1]), this.throwIfDisposed(), mt.conv2d(this, t, e, n, r, o, i)
      )
    }),
    (xt.prototype.conv2dTranspose = function (t, e, n, r, o) {
      return this.throwIfDisposed(), mt.conv2dTranspose(this, t, e, n, r, o)
    }),
    (xt.prototype.depthwiseConv2D = function (t, e, n, r, o, i) {
      return (
        void 0 === r && (r = 'NHWC'),
        void 0 === o && (o = [1, 1]),
        this.throwIfDisposed(),
        mt.depthwiseConv2d(this, t, e, n, r, o, i)
      )
    }),
    (xt.prototype.separableConv2d = function (t, e, n, r, o, i) {
      return (
        void 0 === o && (o = [1, 1]),
        void 0 === i && (i = 'NHWC'),
        this.throwIfDisposed(),
        mt.separableConv2d(this, t, e, n, r, o, i)
      )
    }),
    (xt.prototype.avgPool = function (t, e, n, r) {
      return this.throwIfDisposed(), mt.avgPool(this, t, e, n, r)
    }),
    (xt.prototype.maxPool = function (t, e, n, r) {
      return this.throwIfDisposed(), mt.maxPool(this, t, e, n, r)
    }),
    (xt.prototype.localResponseNormalization = function (t, e, n, r) {
      return (
        void 0 === t && (t = 5),
        void 0 === e && (e = 1),
        void 0 === n && (n = 1),
        void 0 === r && (r = 0.5),
        mt.localResponseNormalization(this, t, e, n, r)
      )
    }),
    (xt.prototype.pool = function (t, e, n, r, o) {
      return this.throwIfDisposed(), mt.pool(this, t, e, n, r, o)
    }),
    (xt.prototype.variable = function (t, e, n) {
      return void 0 === t && (t = !0), this.throwIfDisposed(), vt().makeVariable(this, t, e, n)
    }),
    (xt.prototype.unsortedSegmentSum = function (t, e) {
      return this.throwIfDisposed(), mt.unsortedSegmentSum(this, t, e)
    }),
    (xt.prototype.batchToSpaceND = function (t, e) {
      return this.throwIfDisposed(), mt.batchToSpaceND(this, t, e)
    }),
    (xt.prototype.spaceToBatchND = function (t, e) {
      return this.throwIfDisposed(), mt.spaceToBatchND(this, t, e)
    }),
    (xt.prototype.topk = function (t, e) {
      return void 0 === t && (t = 1), void 0 === e && (e = !0), this.throwIfDisposed(), mt.topk(this, t, e)
    }),
    (xt.prototype.stridedSlice = function (t, e, n, r, o, i, a, s) {
      return (
        void 0 === r && (r = 0),
        void 0 === o && (o = 0),
        void 0 === i && (i = 0),
        void 0 === a && (a = 0),
        void 0 === s && (s = 0),
        this.throwIfDisposed(),
        mt.stridedSlice(this, t, e, n, r, o, i, a, s)
      )
    }),
    (xt.prototype.depthToSpace = function (t, e) {
      return this.throwIfDisposed(), mt.depthToSpace(this, t, e)
    }),
    (xt.prototype.fft = function () {
      return this.throwIfDisposed(), mt.spectral.fft(this)
    }),
    (xt.prototype.ifft = function () {
      return this.throwIfDisposed(), mt.spectral.ifft(this)
    }),
    (xt.prototype.rfft = function () {
      return this.throwIfDisposed(), mt.spectral.rfft(this)
    }),
    (xt.prototype.irfft = function () {
      return this.throwIfDisposed(), mt.spectral.irfft(this)
    }),
    xt)
  function xt(t, e, n, r) {
    ;(this.kept = !1),
      (this.isDisposedInternal = !1),
      (this.shape = t.slice()),
      (this.dtype = e || 'float32'),
      (this.size = D(t)),
      (this.strides = $(t)),
      (this.dataId = n),
      (this.id = r),
      (this.rankType = this.rank < 5 ? this.rank.toString() : 'higher')
  }
  Object.defineProperty(bt, Symbol.hasInstance, {
    value: function (t) {
      return !!t && null != t.dataId && null != t.shape && null != t.dtype
    },
  })
  var wt,
    Ct =
      (n(Et, (wt = bt)),
      (Et.prototype.assign = function (t) {
        if (t.dtype !== this.dtype)
          throw new Error('dtype of the new value (' + t.dtype + ') and previous value (' + this.dtype + ') must match')
        if (!S(t.shape, this.shape))
          throw new Error('shape of the new value (' + t.shape + ') and previous value (' + this.shape + ') must match')
        vt().disposeTensor(this), (this.dataId = t.dataId), vt().incRef(this, null)
      }),
      (Et.prototype.dispose = function () {
        vt().disposeVariable(this), (this.isDisposedInternal = !0)
      }),
      Et)
  function Et(t, e, n, r) {
    r = wt.call(this, t.shape, t.dtype, t.dataId, r) || this
    return (r.trainable = e), (r.name = n), r
  }
  Object.defineProperty(Ct, Symbol.hasInstance, {
    value: function (t) {
      return t instanceof bt && null != t.assign && t.assign instanceof Function
    },
  }),
    ((jc = {}).R0 = 'R0'),
    (jc.R1 = 'R1'),
    (jc.R2 = 'R2'),
    (jc.R3 = 'R3'),
    (jc.R4 = 'R4'),
    (jc.R5 = 'R5'),
    (jc.R6 = 'R6'),
    ((qc = tl = tl || {}).float32 = 'float32'),
    (qc.int32 = 'int32'),
    (qc.bool = 'int32'),
    (qc.complex64 = 'complex64'),
    ((Kc = el = el || {}).float32 = 'float32'),
    (Kc.int32 = 'int32'),
    (Kc.bool = 'bool'),
    (Kc.complex64 = 'complex64'),
    ((Xc = Zc = Zc || {}).float32 = 'float32'),
    (Xc.int32 = 'float32'),
    (Xc.bool = 'float32'),
    (Xc.complex64 = 'complex64'),
    (($c = nl = nl || {}).float32 = 'complex64'),
    ($c.int32 = 'complex64'),
    ($c.bool = 'complex64'),
    ($c.complex64 = 'complex64')
  var St,
    _t = { float32: Zc, int32: tl, bool: el, complex64: nl }
  function Rt(t, e) {
    if ('string' !== t && 'string' !== e) return _t[t][e]
    if ('string' === t && 'string' === e) return 'string'
    throw new Error('Can not upcast ' + t + ' with ' + e)
  }
  function It(t) {
    return Rt(t, 'int32')
  }
  function At(t, e) {
    if (t.dtype === e.dtype) return [t, e]
    var n = Rt(t.dtype, e.dtype)
    return [t.cast(n), e.cast(n)]
  }
  function Nt(t, e) {
    A(t.dtype === e.dtype, function () {
      return 'The dtypes of the first(' + t.dtype + ') and second(' + e.dtype + ') input must match'
    })
  }
  function kt(t) {
    var e = []
    return (
      (function t(e, n, r) {
        if (null != e) {
          if (e instanceof bt) return n.push(e), 0
          if (((o = e), Array.isArray(o) || 'object' == typeof o)) {
            var o,
              i,
              a = e
            for (i in a) {
              var s = a[i]
              r.has(s) || (r.add(s), t(s, n, r))
            }
          }
        }
      })(t, e, new Set()),
      e
    )
  }
  Object.freeze({
    makeTypesMatch: At,
    assertTypesMatch: Nt,
    isTensorInList: function (e, t) {
      return t.some(function (t) {
        return t.id === e.id
      })
    },
    getTensorsInContainer: kt,
  })
  var Tt =
      ((Ft.prototype.dispose = function () {
        for (var t in this.registeredVariables) this.registeredVariables[t].dispose()
      }),
      Ft),
    Dt =
      ((Ot.prototype.ready = function () {
        return x(this, void 0, void 0, function () {
          var e, n, r
          return w(this, function (t) {
            switch (t.label) {
              case 0:
                if (null != this.pendingBackendInit) return [2, this.pendingBackendInit.then(function () {})]
                if (null != this.backendInstance) return [2]
                ;(e = this.getSortedBackends()), (n = 0), (t.label = 1)
              case 1:
                return n < e.length ? ((r = e[n]), [4, this.initializeBackend(r).success]) : [3, 5]
              case 2:
                return t.sent() ? [4, this.setBackend(r)] : [3, 4]
              case 3:
                return t.sent(), [2]
              case 4:
                return n++, [3, 1]
              case 5:
                throw new Error('Could not initialize any backends, all backend initializations failed.')
            }
          })
        })
      }),
      Object.defineProperty(Ot.prototype, 'backend', {
        get: function () {
          if (null != this.pendingBackendInit)
            throw new Error(
              "Backend '" +
                this.backendName +
                "' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods",
            )
          if (null == this.backendInstance) {
            var t = this.initializeBackendsAndReturnBest(),
              e = t.name
            if (t.asyncInit)
              throw new Error(
                "The highest priority backend '" +
                  e +
                  "' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods",
              )
            this.setBackend(e)
          }
          return this.backendInstance
        },
        enumerable: !0,
        configurable: !0,
      }),
      (Ot.prototype.backendNames = function () {
        return Object.keys(this.registryFactory)
      }),
      (Ot.prototype.findBackend = function (t) {
        if (!(t in this.registry)) {
          if (!(t in this.registryFactory)) return null
          if (this.initializeBackend(t).asyncInit) return null
        }
        return this.registry[t]
      }),
      (Ot.prototype.findBackendFactory = function (t) {
        return t in this.registryFactory ? this.registryFactory[t].factory : null
      }),
      (Ot.prototype.registerBackend = function (t, e, n) {
        return (
          void 0 === n && (n = 1),
          t in this.registryFactory
            ? (console.warn(t + ' backend was already registered. Reusing existing backend factory.'), !1)
            : ((this.registryFactory[t] = { factory: e, priority: n }), !0)
        )
      }),
      (Ot.prototype.setBackend = function (o) {
        return x(this, void 0, void 0, function () {
          var e, n, r
          return w(this, function (t) {
            switch (t.label) {
              case 0:
                if (null == this.registryFactory[o]) throw new Error("Backend name '" + o + "' not found in registry")
                return (
                  (this.backendName = o),
                  null != this.registry[o]
                    ? [3, 4]
                    : ((this.backendInstance = null),
                      (e = this.initializeBackend(o)),
                      (n = e.success),
                      e.asyncInit ? [4, n] : [3, 2])
                )
              case 1:
                return (r = t.sent()), [3, 3]
              case 2:
                ;(r = n), (t.label = 3)
              case 3:
                if (!r) return [2, !1]
                t.label = 4
              case 4:
                return (
                  (this.backendInstance = this.registry[o]),
                  this.setupRegisteredKernels(),
                  (this.profiler = new at(this.backendInstance)),
                  [2, !0]
                )
            }
          })
        })
      }),
      (Ot.prototype.setupRegisteredKernels = function () {
        var e = this
        l(this.backendName).forEach(function (t) {
          null != t.setupFunc && t.setupFunc(e.backendInstance)
        })
      }),
      (Ot.prototype.disposeRegisteredKernels = function (e) {
        var n = this
        l(e).forEach(function (t) {
          null != t.disposeFunc && t.disposeFunc(n.registry[e])
        })
      }),
      (Ot.prototype.initializeBackend = function (e) {
        var n = this,
          t = this.registryFactory[e]
        if (null == t) throw new Error('Cannot initialize backend ' + e + ', no registration found.')
        try {
          var r = t.factory()
          if (Promise.resolve(r) !== r) return (this.registry[e] = r), { success: !0, asyncInit: !1 }
          var o = ++this.pendingBackendInitId,
            r = r
              .then(function (t) {
                return !(o < n.pendingBackendInitId || ((n.registry[e] = t), (n.pendingBackendInit = null)))
              })
              .catch(function (t) {
                return !(
                  o < n.pendingBackendInitId ||
                  ((n.pendingBackendInit = null),
                  console.warn('Initialization of backend ' + e + ' failed'),
                  console.warn(t.stack || t.message),
                  1)
                )
              })
          return { success: (this.pendingBackendInit = r), asyncInit: !0 }
        } catch (n) {
          return (
            console.warn('Initialization of backend ' + e + ' failed'),
            console.warn(n.stack || n.message),
            { success: !1, asyncInit: !1 }
          )
        }
      }),
      (Ot.prototype.removeBackend = function (t) {
        if (!(t in this.registryFactory)) throw new Error(t + ' backend not found in registry')
        this.backendName === t && null != this.pendingBackendInit && this.pendingBackendInitId++,
          t in this.registry && (this.disposeRegisteredKernels(t), this.registry[t].dispose(), delete this.registry[t]),
          delete this.registryFactory[t],
          this.backendName === t && ((this.pendingBackendInit = null), (this.backendName = null), (this.backendInstance = null))
      }),
      (Ot.prototype.getSortedBackends = function () {
        var n = this
        if (0 === Object.keys(this.registryFactory).length) throw new Error('No backend found in registry.')
        return Object.keys(this.registryFactory).sort(function (t, e) {
          return n.registryFactory[e].priority - n.registryFactory[t].priority
        })
      }),
      (Ot.prototype.initializeBackendsAndReturnBest = function () {
        for (var t = this.getSortedBackends(), e = 0; e < t.length; e++) {
          var n = t[e],
            r = this.initializeBackend(n),
            o = r.success,
            r = r.asyncInit
          if (r || o) return { name: n, asyncInit: r }
        }
        throw new Error('Could not initialize any backends, all backend initializations failed.')
      }),
      (Ot.prototype.moveData = function (t, e) {
        var n = this.state.tensorInfo.get(e),
          r = n.backend,
          o = this.readSync(e)
        r.disposeData(e),
          (n.backend = t).move(e, o, n.shape, n.dtype),
          this.shouldCheckForMemLeaks() && this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++
      }),
      (Ot.prototype.tidy = function (t, e) {
        var n,
          r = this,
          o = null
        if (null == e) {
          if ('function' != typeof t) throw new Error('Please provide a function to tidy()')
          e = t
        } else {
          if ('string' != typeof t && !(t instanceof String))
            throw new Error('When calling with two arguments, the first argument to tidy() must be a string')
          if ('function' != typeof e)
            throw new Error('When calling with two arguments, the 2nd argument to tidy() must be a function')
          o = t
        }
        return this.scopedRun(
          function () {
            return r.startScope(o)
          },
          function () {
            return r.endScope(n)
          },
          function () {
            return (n = e()) instanceof Promise && console.error('Cannot return a Promise inside of tidy.'), n
          },
        )
      }),
      (Ot.prototype.scopedRun = function (t, e, n) {
        t()
        try {
          var r = n()
          return e(), r
        } catch (t) {
          throw (e(), t)
        }
      }),
      (Ot.prototype.nextTensorId = function () {
        return Ot.nextTensorId++
      }),
      (Ot.prototype.nextVariableId = function () {
        return Ot.nextVariableId++
      }),
      (Ot.prototype.clone = function (t) {
        var e = this.makeTensorFromDataId(t.dataId, t.shape, t.dtype),
          t = { x: t }
        return (
          this.addTapeNode(
            this.state.activeScope.name,
            t,
            [e],
            function (t) {
              return {
                x: function () {
                  return t.toFloat()
                },
              }
            },
            [],
          ),
          e
        )
      }),
      (Ot.prototype.runKernel = function (t, e, n, r, o) {
        return this.runKernelFunc(null, e, null, t, n, r, o)
      }),
      (Ot.prototype.shouldCheckForMemLeaks = function () {
        return this.ENV.getBool('IS_TEST')
      }),
      (Ot.prototype.checkKernelForMemLeak = function (t, e, n) {
        var r = this.backend.numDataIds(),
          o = 0
        n.forEach(function (t) {
          o += 'complex64' === t.dtype ? 3 : 1
        })
        ;(n = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]), (n = r - e - o - n)
        if (0 < n)
          throw new Error(
            "Backend '" + this.backendName + "' has an internal memory leak (" + n + " data ids) after running '" + t + "'",
          )
      }),
      (Ot.prototype.runKernelFunc = function (n, r, t, o, i, a, s) {
        var e,
          u = this
        void 0 === a && (a = []), void 0 === s && (s = [])
        var c = [],
          l = this.isTapeOn()
        null == o && (o = null != this.state.activeScope ? this.state.activeScope.name : '')
        function h(t) {
          l &&
            (c = t.map(function (t) {
              return u.keep(u.clone(t))
            }))
        }
        var p = this.state.numBytes,
          d = this.state.numTensors
        this.shouldCheckForMemLeaks() && this.state.numDataMovesStack.push(0)
        var f,
          v = g(o, this.backendName),
          m =
            null != v
              ? function () {
                  var t = u.backend.numDataIds()
                  f = v.kernelFunc({ inputs: r, attrs: i, backend: u.backend })
                  var e = Array.isArray(f) ? f : [f]
                  u.shouldCheckForMemLeaks() && u.checkKernelForMemLeak(o, t, e)
                  ;(t = e.map(function (t) {
                    var e = t.dataId,
                      n = t.shape,
                      t = t.dtype
                    return u.makeTensorFromDataId(e, n, t)
                  })),
                    (e = t.filter(function (t, e) {
                      return s[e]
                    }))
                  return h((a || []).slice().concat(e)), t
                }
              : function () {
                  var t = u.backend.numDataIds()
                  f = u.tidy(function () {
                    return n(u.backend, h)
                  })
                  var e = Array.isArray(f) ? f : [f]
                  return u.shouldCheckForMemLeaks() && u.checkKernelForMemLeak(o, t, e), e
                }
        return (
          this.scopedRun(
            function () {
              return u.state.kernelDepth++
            },
            function () {
              return u.state.kernelDepth--
            },
            function () {
              e = u.ENV.getBool('DEBUG')
                ? u.profiler.profileKernel(o, r, function () {
                    return m()
                  })
                : m()
            },
          ),
          l && this.addTapeNode(o, r, e, t, c),
          this.state.profiling &&
            this.state.activeProfile.kernels.push({
              name: o,
              bytesAdded: this.state.numBytes - p,
              totalBytesSnapshot: this.state.numBytes,
              tensorsAdded: this.state.numTensors - d,
              totalTensorsSnapshot: this.state.numTensors,
              inputShapes: Object.keys(r).map(function (t) {
                return r[t].shape
              }),
              outputShapes: e.map(function (t) {
                return t.shape
              }),
            }),
          Array.isArray(f) ? e : e[0]
        )
      }),
      (Ot.prototype.makeTensor = function (t, e, n, r) {
        if (null == t) throw new Error('Values passed to engine.makeTensor() are null')
        ;(n = n || 'float32'), (r = r || this.backend)
        var o = t
        'string' === n &&
          V(t[0]) &&
          (o = t.map(function (t) {
            return nt(t)
          }))
        ;(t = r.write(o, e, n)), (e = new bt(e, n, t, this.nextTensorId()))
        return (
          this.incRef(e, r),
          'string' === n &&
            ((t = this.state.tensorInfo.get(t)), (o = U(o)), (this.state.numBytes += o - t.bytes), (t.bytes = o)),
          e
        )
      }),
      (Ot.prototype.makeTensorFromDataId = function (t, e, n, r) {
        t = new bt(e, (n = n || 'float32'), t, this.nextTensorId())
        return this.incRef(t, r), t
      }),
      (Ot.prototype.makeVariable = function (t, e, n, r) {
        void 0 === e && (e = !0), (n = n || this.nextVariableId().toString()), null != r && r !== t.dtype && (t = t.asType(r))
        n = new Ct(t, e, n, this.nextTensorId())
        if (null != this.state.registeredVariables[n.name])
          throw new Error('Variable with name ' + n.name + ' was already registered')
        return (this.state.registeredVariables[n.name] = n), this.incRef(n, this.backend), n
      }),
      (Ot.prototype.incRef = function (t, e) {
        var n = this.state.tensorInfo.has(t.dataId) ? this.state.tensorInfo.get(t.dataId).refCount : 0
        this.state.numTensors++,
          'string' === t.dtype && this.state.numStringTensors++,
          0 === n &&
            (this.state.numDataBuffers++,
            (n = 0),
            'complex64' !== t.dtype && 'string' !== t.dtype && (n = t.size * G(t.dtype)),
            this.state.tensorInfo.set(t.dataId, {
              backend: e || this.backend,
              dtype: t.dtype,
              shape: t.shape,
              bytes: n,
              refCount: 0,
            }),
            (this.state.numBytes += n)),
          this.state.tensorInfo.get(t.dataId).refCount++,
          t instanceof Ct || this.track(t)
      }),
      (Ot.prototype.disposeTensor = function (t) {
        var e
        this.state.tensorInfo.has(t.dataId) &&
          (this.state.numTensors--,
          'string' === t.dtype && this.state.numStringTensors--,
          (e = this.state.tensorInfo.get(t.dataId)).refCount <= 1
            ? ('complex64' !== t.dtype && (this.state.numBytes -= e.bytes),
              this.state.numDataBuffers--,
              e.backend.disposeData(t.dataId),
              this.state.tensorInfo.delete(t.dataId))
            : this.state.tensorInfo.get(t.dataId).refCount--)
      }),
      (Ot.prototype.disposeVariables = function () {
        for (var t in this.state.registeredVariables) {
          t = this.state.registeredVariables[t]
          this.disposeVariable(t)
        }
      }),
      (Ot.prototype.disposeVariable = function (t) {
        this.disposeTensor(t), null != this.state.registeredVariables[t.name] && delete this.state.registeredVariables[t.name]
      }),
      (Ot.prototype.memory = function () {
        var t = this.backend.memory()
        return (
          (t.numTensors = this.state.numTensors),
          (t.numDataBuffers = this.state.numDataBuffers),
          (t.numBytes = this.state.numBytes),
          0 < this.state.numStringTensors &&
            ((t.unreliable = !0),
            null == t.reasons && (t.reasons = []),
            t.reasons.push('Memory usage by string tensors is approximate (2 bytes per character)')),
          t
        )
      }),
      (Ot.prototype.profile = function (r) {
        return x(this, void 0, void 0, function () {
          var e, n
          return w(this, function (t) {
            return (
              (this.state.profiling = !0),
              (e = this.state.numBytes),
              (n = this.state.numTensors),
              (this.state.activeProfile.kernels = []),
              (this.state.activeProfile.result = r()),
              (this.state.profiling = !1),
              (this.state.activeProfile.peakBytes = Math.max.apply(
                Math,
                this.state.activeProfile.kernels.map(function (t) {
                  return t.totalBytesSnapshot
                }),
              )),
              (this.state.activeProfile.newBytes = this.state.numBytes - e),
              (this.state.activeProfile.newTensors = this.state.numTensors - n),
              [2, this.state.activeProfile]
            )
          })
        })
      }),
      (Ot.prototype.isTapeOn = function () {
        return 0 < this.state.gradientDepth && 0 === this.state.kernelDepth
      }),
      (Ot.prototype.addTapeNode = function (t, e, n, r, o) {
        var i = this,
          e = { id: this.state.nextTapeNodeId++, kernelName: t, inputs: e, outputs: n, saved: o },
          t = ((t = t), c.get(t))
        null != (r = null != t ? t.gradFunc : r) &&
          (e.gradient = function (t) {
            return (
              (t = t.map(function (t, e) {
                if (null != t) return t
                ;(t = n[e]), (e = Z(t.size, t.dtype))
                return i.makeTensor(e, t.shape, t.dtype)
              })),
              r(1 < t.length ? t : t[0], o)
            )
          }),
          this.state.activeTape.push(e)
      }),
      (Ot.prototype.keep = function (t) {
        return (t.kept = !0), t
      }),
      (Ot.prototype.startTape = function () {
        0 === this.state.gradientDepth && (this.state.activeTape = []), this.state.gradientDepth++
      }),
      (Ot.prototype.endTape = function () {
        this.state.gradientDepth--
      }),
      (Ot.prototype.startScope = function (t) {
        var e = { track: [], name: 'unnamed scope', id: this.state.nextScopeId++ }
        t && (e.name = t), this.state.scopeStack.push(e), (this.state.activeScope = e)
      }),
      (Ot.prototype.endScope = function (t) {
        for (
          var e = this,
            t = kt(t),
            n = new Set(
              t.map(function (t) {
                return t.id
              }),
            ),
            r = 0;
          r < this.state.activeScope.track.length;
          r++
        ) {
          var o = this.state.activeScope.track[r]
          o.kept || n.has(o.id) || o.dispose()
        }
        var i = this.state.scopeStack.pop()
        ;(this.state.activeScope =
          0 === this.state.scopeStack.length ? null : this.state.scopeStack[this.state.scopeStack.length - 1]),
          t.forEach(function (t) {
            t.kept || t.scopeId !== i.id || e.track(t)
          })
      }),
      (Ot.prototype.gradients = function (t, r, o, e) {
        var u = this
        if (
          (void 0 === e && (e = !1),
          A(0 < r.length, function () {
            return 'gradients() received an empty list of xs.'
          }),
          null != o && 'float32' !== o.dtype)
        )
          throw new Error("dy must have 'float32' dtype, but has '" + o.dtype + "'")
        var i = this.scopedRun(
          function () {
            return u.startTape()
          },
          function () {
            return u.endTape()
          },
          function () {
            return u.tidy('forward', t)
          },
        )
        A(i instanceof bt, function () {
          return 'The result y returned by f() must be a tensor.'
        })
        var a = (function (t, e, n) {
          for (var r = {}, o = {}, i = 0; i < e.length; i++) r[e[i].id] = !0
          for (i = 0; i < t.length; i++) {
            var a = (d = t[i]).inputs
            for (p in a) {
              for (var s = a[p], u = !1, c = 0; c < e.length; c++)
                if (r[s.id]) {
                  d.outputs.forEach(function (t) {
                    return (r[t.id] = !0)
                  }),
                    (u = !0),
                    (o[d.id] = !0)
                  break
                }
              if (u) break
            }
          }
          var l = {}
          l[n.id] = !0
          for (var h = {}, i = t.length - 1; 0 <= i; i--)
            for (a = (d = t[i]).inputs, c = 0; c < d.outputs.length; c++)
              if (l[d.outputs[c].id]) {
                for (var p in a) (l[a[p].id] = !0), (h[d.id] = !0)
                break
              }
          var d,
            f = []
          for (i = 0; i < t.length; i++)
            if (o[(d = t[i]).id] && h[d.id]) {
              var v = {}
              for (p in d.inputs) {
                var m = d.inputs[p]
                r[m.id] && (v[p] = m)
              }
              var g = Object.assign({}, d)
              ;(g.inputs = v), (g.outputs = d.outputs), f.push(g)
            }
          return f
        })(this.state.activeTape, r, i)
        if (!e && 0 === a.length && 0 < r.length)
          throw new Error(
            'Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.',
          )
        return this.tidy('backward', function () {
          var t,
            e = {}
          ;(e[i.id] = null == o ? ((t = Q(D((n = i.shape)), 'float32')), Pt.makeTensor(t, n, 'float32')) : o),
            (function (a, s) {
              for (
                var t = function (t) {
                    var o = s[t],
                      e = []
                    if (
                      (o.outputs.forEach(function (t) {
                        t = a[t.id]
                        null != t ? e.push(t) : e.push(null)
                      }),
                      null == o.gradient)
                    )
                      throw new Error('Cannot compute gradient: gradient function not found for ' + o.kernelName + '.')
                    function n(t) {
                      if (!(t in i))
                        throw new Error(
                          'Cannot backprop through input ' + t + '. Available gradients found: ' + Object.keys(i) + '.',
                        )
                      var e = u.tidy(function () {
                        return i[t]()
                      })
                      if ('float32' !== e.dtype)
                        throw new Error(
                          'Error in gradient for op ' +
                            o.kernelName +
                            '. The gradient of input ' +
                            t +
                            " must have 'float32' dtype, but has '" +
                            e.dtype +
                            "'",
                        )
                      var n,
                        r = o.inputs[t]
                      if (!S(e.shape, r.shape))
                        throw new Error(
                          'Error in gradient for op ' +
                            o.kernelName +
                            ". The gradient of input '" +
                            t +
                            "' has shape '" +
                            e.shape +
                            "', which does not match the shape of the input '" +
                            r.shape +
                            "'",
                        )
                      null == a[r.id] ? (a[r.id] = e) : ((n = a[r.id]), (a[r.id] = n.add(e)), n.dispose())
                    }
                    var r,
                      i = o.gradient(e)
                    for (r in o.inputs) n(r)
                  },
                  e = s.length - 1;
                0 <= e;
                e--
              )
                t(e)
            })(e, a)
          var n = r.map(function (t) {
            return e[t.id]
          })
          return (
            0 === u.state.gradientDepth &&
              (u.state.activeTape.forEach(function (t) {
                for (var e = 0, n = t.saved; e < n.length; e++) n[e].dispose()
              }),
              (u.state.activeTape = null)),
            { value: i, grads: n }
          )
        })
      }),
      (Ot.prototype.customGrad = function (i) {
        var e = this
        return (
          A(K(i), function () {
            return 'The f passed in customGrad(f) must be a function.'
          }),
          function () {
            for (var r, o = [], t = 0; t < arguments.length; t++) o[t] = arguments[t]
            A(
              o.every(function (t) {
                return t instanceof bt
              }),
              function () {
                return 'The args passed in customGrad(f)(x1, x2,...) must all be tensors'
              },
            )
            var n = {}
            return (
              o.forEach(function (t, e) {
                n[e] = t
              }),
              e.runKernelFunc(
                function (t, e) {
                  return (
                    A((r = i.apply(void 0, o.concat([e]))).value instanceof bt, function () {
                      return 'The function f passed in customGrad(f) must return an object where `obj.value` is a tensor'
                    }),
                    A(K(r.gradFunc), function () {
                      return 'The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.'
                    }),
                    r.value
                  )
                },
                n,
                function (t, e) {
                  ;(e = r.gradFunc(t, e)), (e = Array.isArray(e) ? e : [e])
                  A(e.length === o.length, function () {
                    return 'The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).'
                  }),
                    A(
                      e.every(function (t) {
                        return t instanceof bt
                      }),
                      function () {
                        return 'The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.'
                      },
                    )
                  var n = {}
                  return (
                    e.forEach(function (t, e) {
                      n[e] = function () {
                        return t
                      }
                    }),
                    n
                  )
                },
              )
            )
          }
        )
      }),
      (Ot.prototype.readSync = function (t) {
        return this.state.tensorInfo.get(t).backend.readSync(t)
      }),
      (Ot.prototype.read = function (t) {
        return this.state.tensorInfo.get(t).backend.read(t)
      }),
      (Ot.prototype.time = function (r) {
        return x(this, void 0, void 0, function () {
          var e, n
          return w(this, function (t) {
            switch (t.label) {
              case 0:
                return (e = tt()), [4, this.backend.time(r)]
              case 1:
                return ((n = t.sent()).wallMs = tt() - e), [2, n]
            }
          })
        })
      }),
      (Ot.prototype.track = function (t) {
        return (
          null != this.state.activeScope && ((t.scopeId = this.state.activeScope.id), this.state.activeScope.track.push(t)), t
        )
      }),
      Object.defineProperty(Ot.prototype, 'registeredVariables', {
        get: function () {
          return this.state.registeredVariables
        },
        enumerable: !0,
        configurable: !0,
      }),
      (Ot.prototype.reset = function () {
        for (var t in (this.pendingBackendInitId++,
        this.state.dispose(),
        this.ENV.reset(),
        (this.state = new Tt()),
        this.registry))
          this.disposeRegisteredKernels(t), this.registry[t].dispose(), delete this.registry[t]
        ;(this.backendName = null), (this.backendInstance = null), (this.pendingBackendInit = null)
      }),
      (Ot.nextTensorId = 0),
      (Ot.nextVariableId = 0),
      Ot)
  function Ot(t) {
    ;(this.ENV = t), (this.registry = {}), (this.registryFactory = {}), (this.pendingBackendInitId = 0), (this.state = new Tt())
  }
  function Ft() {
    ;(this.registeredVariables = {}),
      (this.nextTapeNodeId = 0),
      (this.numBytes = 0),
      (this.numTensors = 0),
      (this.numStringTensors = 0),
      (this.numDataBuffers = 0),
      (this.gradientDepth = 0),
      (this.kernelDepth = 0),
      (this.scopeStack = []),
      (this.numDataMovesStack = []),
      (this.nextScopeId = 0),
      (this.tensorInfo = new WeakMap()),
      (this.profiling = !1),
      (this.activeProfile = { newBytes: 0, newTensors: 0, peakBytes: 0, kernels: [], result: null })
  }
  var Mt,
    Pt =
      (null ==
        (Mt = (function () {
          if (null == St) {
            var t = void 0
            if ('undefined' != typeof window) t = window
            else if ('undefined' != typeof global) t = global
            else if ('undefined' != typeof process) t = process
            else {
              if ('undefined' == typeof self) throw new Error('Could not find a global object')
              t = self
            }
            St = t
          }
          return St
        })())._tfengine && ((al = new o(Mt)), (Mt._tfengine = new Dt(al))),
      (al = Mt._tfengine.ENV),
      (f = al),
      (vt = function () {
        return Mt._tfengine
      }),
      Mt._tfengine)
  function Bt() {
    return ('undefined' != typeof window && null != window.document) || 'undefined' != typeof WorkerGlobalScope
  }
  var Lt = f
  Lt.registerFlag(
    'DEBUG',
    function () {
      return !1
    },
    function (t) {
      t &&
        console.warn(
          'Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.',
        )
    },
  ),
    Lt.registerFlag('IS_BROWSER', Bt),
    Lt.registerFlag('IS_NODE', function () {
      return 'undefined' != typeof process && void 0 !== process.versions && void 0 !== process.versions.node
    }),
    Lt.registerFlag('IS_CHROME', function () {
      return (
        'undefined' != typeof navigator &&
        null != navigator &&
        null != navigator.userAgent &&
        /Chrome/.test(navigator.userAgent) &&
        /Google Inc/.test(navigator.vendor)
      )
    }),
    Lt.registerFlag('PROD', function () {
      return !1
    }),
    Lt.registerFlag('TENSORLIKE_CHECK_SHAPE_CONSISTENCY', function () {
      return Lt.getBool('DEBUG')
    }),
    Lt.registerFlag('DEPRECATION_WARNINGS_ENABLED', function () {
      return !0
    }),
    Lt.registerFlag('IS_TEST', function () {
      return !1
    })
  var Wt,
    zt,
    Gt,
    Ut = {},
    Vt = {
      alpha: !1,
      antialias: !1,
      premultipliedAlpha: !1,
      preserveDrawingBuffer: !1,
      depth: !1,
      stencil: !1,
      failIfMajorPerformanceCaveat: !0,
    }
  function Ht(t, e) {
    Ut[t] = e
  }
  function jt(t) {
    t in Ut ||
      (Ut[t] = (function (e) {
        if (1 !== e && 2 !== e) throw new Error('Cannot get WebGL rendering context, WebGL is disabled.')
        var t = (function () {
          if ('undefined' != typeof OffscreenCanvas && 2 === e) return new OffscreenCanvas(300, 150)
          if ('undefined' != typeof document) return document.createElement('canvas')
          throw new Error('Cannot create a canvas in this context')
        })()
        return (
          t.addEventListener(
            'webglcontextlost',
            function (t) {
              t.preventDefault(), delete Ut[e]
            },
            !1,
          ),
          1 === e ? t.getContext('webgl', Vt) || t.getContext('experimental-webgl', Vt) : t.getContext('webgl2', Vt)
        )
      })(t))
    var e = Ut[t]
    return e.isContextLost()
      ? (delete Ut[t], jt(t))
      : (e.disable(e.DEPTH_TEST),
        e.disable(e.STENCIL_TEST),
        e.disable(e.BLEND),
        e.disable(e.DITHER),
        e.disable(e.POLYGON_OFFSET_FILL),
        e.disable(e.SAMPLE_COVERAGE),
        e.enable(e.SCISSOR_TEST),
        e.enable(e.CULL_FACE),
        e.cullFace(e.BACK),
        Ut[t])
  }
  function qt(t) {
    t = D(t)
    return R(Math.ceil(t / 4))
  }
  function Kt(t, e) {
    return [Math.max(1, Math.ceil(e / 2)), Math.max(1, Math.ceil(t / 2))]
  }
  function Xt(t, e) {
    var n,
      r,
      o,
      i,
      a,
      s,
      u,
      c,
      l = t,
      e =
        2 === f.getNumber('WEBGL_VERSION')
          ? ((n = l.R32F),
            (r = l.R16F),
            (o = l.RGBA16F),
            (i = l.RGBA32F),
            (a = l.RED),
            (s = 4),
            (u = 1),
            (c = l.HALF_FLOAT),
            l.FLOAT)
          : ((n = t.RGBA),
            (r = t.RGBA),
            (o = t.RGBA),
            (i = l.RGBA),
            (a = t.RGBA),
            (u = s = 4),
            (c = null != e ? e.HALF_FLOAT_OES : null),
            t.FLOAT)
    return {
      internalFormatFloat: n,
      internalFormatHalfFloat: r,
      internalFormatPackedHalfFloat: o,
      internalFormatPackedFloat: i,
      textureFormatFloat: a,
      downloadTextureFormat: t.RGBA,
      downloadUnpackNumChannels: s,
      defaultNumChannels: u,
      textureTypeHalfFloat: c,
      textureTypeFloat: e,
    }
  }
  function $t(t, e, n) {
    n = n()
    return (
      e &&
        (function (t) {
          var e = t.getError()
          if (e !== t.NO_ERROR) throw new Error('WebGL Error: ' + Jt(t, e))
        })(t),
      n
    )
  }
  ;((ul = Wt = Wt || {})[(ul.DENSE = 0)] = 'DENSE'),
    (ul[(ul.SHARED_BATCH = 1)] = 'SHARED_BATCH'),
    ((cl = zt = zt || {})[(cl.RENDER = 0)] = 'RENDER'),
    (cl[(cl.UPLOAD = 1)] = 'UPLOAD'),
    (cl[(cl.PIXELS = 2)] = 'PIXELS'),
    (cl[(cl.DOWNLOAD = 3)] = 'DOWNLOAD'),
    ((hl = Gt = Gt || {})[(hl.UNPACKED_FLOAT16 = 0)] = 'UNPACKED_FLOAT16'),
    (hl[(hl.UNPACKED_FLOAT32 = 1)] = 'UNPACKED_FLOAT32'),
    (hl[(hl.PACKED_4X1_UNSIGNED_BYTE = 2)] = 'PACKED_4X1_UNSIGNED_BYTE'),
    (hl[(hl.PACKED_2X2_FLOAT32 = 3)] = 'PACKED_2X2_FLOAT32'),
    (hl[(hl.PACKED_2X2_FLOAT16 = 4)] = 'PACKED_2X2_FLOAT16')
  function Yt(t) {
    return !!(f.getBool('WEBGL_RENDER_FLOAT32_ENABLED') || 0 === t || (5.96e-8 < Math.abs(t) && Math.abs(t) < 65504))
  }
  function Jt(t, e) {
    switch (e) {
      case t.NO_ERROR:
        return 'NO_ERROR'
      case t.INVALID_ENUM:
        return 'INVALID_ENUM'
      case t.INVALID_VALUE:
        return 'INVALID_VALUE'
      case t.INVALID_OPERATION:
        return 'INVALID_OPERATION'
      case t.INVALID_FRAMEBUFFER_OPERATION:
        return 'INVALID_FRAMEBUFFER_OPERATION'
      case t.OUT_OF_MEMORY:
        return 'OUT_OF_MEMORY'
      case t.CONTEXT_LOST_WEBGL:
        return 'CONTEXT_LOST_WEBGL'
      default:
        return 'Unknown error code ' + e
    }
  }
  function Qt(t, e, n) {
    return we(
      t,
      e,
      function () {
        return t.getExtension(n)
      },
      'Extension "' + n + '" not supported on this browser.',
    )
  }
  function Zt(t, e, n) {
    var r = we(
      t,
      e,
      function () {
        return t.createShader(t.VERTEX_SHADER)
      },
      'Unable to create vertex WebGLShader.',
    )
    if (
      ($t(t, e, function () {
        return t.shaderSource(r, n)
      }),
      $t(t, e, function () {
        return t.compileShader(r)
      }),
      !1 === t.getShaderParameter(r, t.COMPILE_STATUS))
    )
      throw (console.log(t.getShaderInfoLog(r)), new Error('Failed to compile vertex shader.'))
    return r
  }
  function te(t, e, n) {
    var r = we(
      t,
      e,
      function () {
        return t.createShader(t.FRAGMENT_SHADER)
      },
      'Unable to create fragment WebGLShader.',
    )
    if (
      ($t(t, e, function () {
        return t.shaderSource(r, n)
      }),
      $t(t, e, function () {
        return t.compileShader(r)
      }),
      !1 === t.getShaderParameter(r, t.COMPILE_STATUS))
    )
      throw (
        ((function (t, e) {
          var n = re.exec(e)
          if (null == n) return console.log("Couldn't parse line number in error: " + e), console.log(t)
          for (
            var r = +n[1],
              n = t.split('\n'),
              o = n.length.toString().length + 2,
              i = n.map(function (t, e) {
                return I((e + 1).toString(), o) + t
              }),
              a = 0,
              s = 0;
            s < i.length;
            s++
          )
            a = Math.max(i[s].length, a)
          ;(t = i.slice(0, r - 1)), (n = i.slice(r - 1, r)), (r = i.slice(r))
          console.log(t.join('\n')),
            console.log(e.split('\n')[0]),
            console.log('%c ' + I(n[0], a), 'border:1px solid red; background-color:#e3d2d2; color:#a61717'),
            console.log(r.join('\n'))
        })(n, t.getShaderInfoLog(r)),
        new Error('Failed to compile fragment shader.'))
      )
    return r
  }
  var ee,
    ne,
    re = /ERROR: [0-9]+:([0-9]+):/g
  function oe(t, e) {
    return we(
      t,
      e,
      function () {
        return t.createProgram()
      },
      'Unable to create WebGLProgram.',
    )
  }
  function ie(t, e, n) {
    if (
      ($t(t, e, function () {
        return t.linkProgram(n)
      }),
      !1 === t.getProgramParameter(n, t.LINK_STATUS))
    )
      throw (console.log(t.getProgramInfoLog(n)), new Error('Failed to link vertex and fragment shaders.'))
  }
  function ae(t, e, n) {
    if (
      ($t(t, e, function () {
        return t.validateProgram(n)
      }),
      !1 === t.getProgramParameter(n, t.VALIDATE_STATUS))
    )
      throw (console.log(t.getProgramInfoLog(n)), new Error('Shader program validation failed.'))
  }
  function se(t, e, n) {
    var r = we(
      t,
      e,
      function () {
        return t.createBuffer()
      },
      'Unable to create WebGLBuffer',
    )
    return (
      $t(t, e, function () {
        return t.bindBuffer(t.ARRAY_BUFFER, r)
      }),
      $t(t, e, function () {
        return t.bufferData(t.ARRAY_BUFFER, n, t.STATIC_DRAW)
      }),
      r
    )
  }
  function ue(t, e, n) {
    var r = we(
      t,
      e,
      function () {
        return t.createBuffer()
      },
      'Unable to create WebGLBuffer',
    )
    return (
      $t(t, e, function () {
        return t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, r)
      }),
      $t(t, e, function () {
        return t.bufferData(t.ELEMENT_ARRAY_BUFFER, n, t.STATIC_DRAW)
      }),
      r
    )
  }
  function ce(t, e) {
    return we(
      t,
      e,
      function () {
        return t.createTexture()
      },
      'Unable to create WebGLTexture.',
    )
  }
  function le(t, e) {
    var n = f.getNumber('WEBGL_MAX_TEXTURE_SIZE')
    if (t <= 0 || e <= 0) {
      var r = '[' + t + 'x' + e + ']'
      throw new Error('Requested texture size ' + r + ' is invalid.')
    }
    if (n < t || n < e)
      throw (
        ((r = '[' + t + 'x' + e + ']'),
        new Error('Requested texture size ' + r + ' greater than WebGL maximum on this browser / GPU [' + n + 'x' + n + '].'))
      )
  }
  function he(t, e) {
    return we(
      t,
      e,
      function () {
        return t.createFramebuffer()
      },
      'Unable to create WebGLFramebuffer.',
    )
  }
  function pe(t, e, n, r, o, i, a, s) {
    var u = t.getAttribLocation(n, r)
    return (
      -1 !== u &&
      ($t(t, e, function () {
        return t.bindBuffer(t.ARRAY_BUFFER, o)
      }),
      $t(t, e, function () {
        return t.vertexAttribPointer(u, i, t.FLOAT, !1, a, s)
      }),
      $t(t, e, function () {
        return t.enableVertexAttribArray(u)
      }),
      !0)
    )
  }
  function de(t, e, n, r) {
    Ce(t, r),
      $t(t, e, function () {
        return t.activeTexture(t.TEXTURE0 + r)
      }),
      $t(t, e, function () {
        return t.bindTexture(t.TEXTURE_2D, n)
      })
  }
  function fe(t, e, n, r) {
    return we(
      t,
      e,
      function () {
        return t.getUniformLocation(n, r)
      },
      'uniform "' + r + '" not present in program.',
    )
  }
  function ve(t, e, n) {
    return t.getUniformLocation(e, n)
  }
  function me(t, e, n, r, o, i) {
    $t(t, e, function () {
      return de(t, e, r, i)
    }),
      $t(t, e, function () {
        return t.uniform1i(o, i)
      })
  }
  function ge(t, e, n, r) {
    $t(t, e, function () {
      return t.bindFramebuffer(t.FRAMEBUFFER, r)
    }),
      $t(t, e, function () {
        return t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, n, 0)
      })
  }
  function ye(t, e, n) {
    $t(t, e, function () {
      return t.bindFramebuffer(t.FRAMEBUFFER, n)
    }),
      $t(t, e, function () {
        return t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, null, 0)
      })
  }
  function be(t) {
    var e = t.checkFramebufferStatus(t.FRAMEBUFFER)
    if (e !== t.FRAMEBUFFER_COMPLETE) throw new Error('Error binding framebuffer: ' + xe(t, e))
  }
  function xe(t, e) {
    switch (e) {
      case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
        return 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT'
      case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
        return 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT'
      case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
        return 'FRAMEBUFFER_INCOMPLETE_DIMENSIONS'
      case t.FRAMEBUFFER_UNSUPPORTED:
        return 'FRAMEBUFFER_UNSUPPORTED'
      default:
        return 'unknown error ' + e
    }
  }
  function we(t, e, n, r) {
    e = $t(t, e, function () {
      return n()
    })
    if (null == e) throw new Error(r)
    return e
  }
  function Ce(t, e) {
    var n = t.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1,
      e = e + t.TEXTURE0
    if (e < t.TEXTURE0 || n < e) throw new Error('textureUnit must be in [gl.TEXTURE0, gl.TEXTURE' + n + '].')
  }
  function Ee(t, e) {
    return void 0 === e && (e = 2), D(t.slice(0, t.length - e))
  }
  function Se(t) {
    if (0 === t.length) throw Error('Cannot get rows and columns of an empty shape array.')
    return [1 < t.length ? t[t.length - 2] : 1, t[t.length - 1]]
  }
  function _e(t) {
    var e = [1, 1, 1]
    return (e = 0 !== t.length && (1 !== t.length || 1 !== t[0]) ? [Ee(t)].concat(Se(t)) : e)
  }
  function Re(n, t) {
    void 0 === t && (t = !1)
    var e = f.getNumber('WEBGL_MAX_TEXTURE_SIZE')
    t &&
      ((e *= 2),
      1 ===
        (n = n.map(function (t, e) {
          return e >= n.length - 2 ? C(n[e]) : n[e]
        })).length && (n = [2, n[0]])),
      2 !== n.length && ((i = F(n)), (n = i.newShape))
    var r = D(n)
    if (n.length <= 1 && r <= e) return [1, r]
    if (2 === n.length && n[0] <= e && n[1] <= e) return n
    if (3 === n.length && n[0] * n[1] <= e && n[2] <= e) return [n[0] * n[1], n[2]]
    if (3 === n.length && n[0] <= e && n[1] * n[2] <= e) return [n[0], n[1] * n[2]]
    if (4 === n.length && n[0] * n[1] * n[2] <= e && n[3] <= e) return [n[0] * n[1] * n[2], n[3]]
    if (4 === n.length && n[0] <= e && n[1] * n[2] * n[3] <= e) return [n[0], n[1] * n[2] * n[3]]
    if (t) {
      var o = Ee(n),
        i = 2,
        e = 2
      return (
        n.length && ((i = (t = Se(n))[0]), (e = t[1])),
        R((r = o * (i / 2) * (e / 2))).map(function (t) {
          return 2 * t
        })
      )
    }
    return R(r)
  }
  function Ie(t) {
    return t % 2 == 0
  }
  function Ae(t, e) {
    if (S((t = t.slice(-2)), (e = e.slice(-2)))) return !0
    if (!t.length || !e.length) return !0
    if (0 === t[0] || 0 === t[1] || 0 === e[0] || 0 === e[1]) return !0
    if (t.length !== e.length) {
      var n = t.slice(-1)[0],
        r = e.slice(-1)[0]
      if (n === r) return !0
      if (Ie(n) && Ie(r) && (1 === t[0] || 1 === e[0])) return !0
    }
    return t[1] === e[1] && Ie(t[0]) && Ie(e[0])
  }
  function Ne(t) {
    return null == ee && ((t = jt(t)), (ee = t.getParameter(t.MAX_TEXTURE_SIZE))), ee
  }
  function ke(t) {
    return null == ne && ((t = jt(t)), (ne = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS))), Math.min(16, ne)
  }
  function Te(t) {
    if (0 === t) return 0
    var e = jt(t)
    return De(e, 'EXT_disjoint_timer_query_webgl2') && 2 === t ? 2 : De(e, 'EXT_disjoint_timer_query') ? 1 : 0
  }
  function De(t, e) {
    return null != t.getExtension(e)
  }
  function Oe(t) {
    try {
      if (null != jt(t)) return !0
    } catch (t) {
      return !1
    }
    return !1
  }
  function Fe(t) {
    if (0 === t) return !1
    var e = jt(t)
    if (1 === t) {
      if (!De(e, 'OES_texture_float')) return !1
    } else if (!De(e, 'EXT_color_buffer_float')) return !1
    return Pe(e)
  }
  function Me(t) {
    if (0 === t) return !1
    var e = jt(t)
    if (1 === t) return !!De(e, 'OES_texture_float') && !!De(e, 'WEBGL_color_buffer_float') && Pe(e)
    if (De(e, 'EXT_color_buffer_float')) return Pe(e)
    if (De(e, 'EXT_color_buffer_half_float')) {
      var o = e.getExtension('EXT_color_buffer_half_float')
      return (function (t) {
        var e = Xt(t, o),
          n = t.createTexture()
        t.bindTexture(t.TEXTURE_2D, n),
          t.texImage2D(t.TEXTURE_2D, 0, e.internalFormatHalfFloat, 1, 1, 0, e.textureFormatFloat, e.textureTypeHalfFloat, null)
        var r = t.createFramebuffer()
        t.bindFramebuffer(t.FRAMEBUFFER, r), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, n, 0)
        e = t.checkFramebufferStatus(t.FRAMEBUFFER) === t.FRAMEBUFFER_COMPLETE
        return (
          t.bindTexture(t.TEXTURE_2D, null),
          t.bindFramebuffer(t.FRAMEBUFFER, null),
          t.deleteTexture(n),
          t.deleteFramebuffer(r),
          e
        )
      })(e)
    }
    return !1
  }
  function Pe(t) {
    var e = Xt(t),
      n = t.createTexture()
    t.bindTexture(t.TEXTURE_2D, n),
      t.texImage2D(t.TEXTURE_2D, 0, e.internalFormatFloat, 1, 1, 0, e.textureFormatFloat, e.textureTypeFloat, null)
    var r = t.createFramebuffer()
    t.bindFramebuffer(t.FRAMEBUFFER, r), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, n, 0)
    e = t.checkFramebufferStatus(t.FRAMEBUFFER) === t.FRAMEBUFFER_COMPLETE
    return (
      t.bindTexture(t.TEXTURE_2D, null), t.bindFramebuffer(t.FRAMEBUFFER, null), t.deleteTexture(n), t.deleteFramebuffer(r), e
    )
  }
  function Be(t) {
    return 2 === t && null != jt(t).fenceSync
  }
  var Le = Object.freeze({
      callAndCheck: $t,
      canBeRepresented: Yt,
      getWebGLErrorMessage: Jt,
      getExtensionOrThrow: Qt,
      createVertexShader: Zt,
      createFragmentShader: te,
      createProgram: oe,
      linkProgram: ie,
      validateProgram: ae,
      createStaticVertexBuffer: se,
      createStaticIndexBuffer: ue,
      getNumChannels: function () {
        return 2 === f.getNumber('WEBGL_VERSION') ? 1 : 4
      },
      createTexture: ce,
      validateTextureSize: le,
      createFramebuffer: he,
      bindVertexBufferToProgramAttribute: pe,
      bindTextureUnit: de,
      unbindTextureUnit: function (t, e, n) {
        Ce(t, n),
          $t(t, e, function () {
            return t.activeTexture(t.TEXTURE0 + n)
          }),
          $t(t, e, function () {
            return t.bindTexture(t.TEXTURE_2D, null)
          })
      },
      getProgramUniformLocationOrThrow: fe,
      getProgramUniformLocation: ve,
      bindTextureToProgramUniformSampler: me,
      bindCanvasToFramebuffer: function (t, e) {
        $t(t, e, function () {
          return t.bindFramebuffer(t.FRAMEBUFFER, null)
        }),
          $t(t, e, function () {
            return t.viewport(0, 0, t.canvas.width, t.canvas.height)
          }),
          $t(t, e, function () {
            return t.scissor(0, 0, t.canvas.width, t.canvas.height)
          })
      },
      bindColorTextureToFramebuffer: ge,
      unbindColorTextureFromFramebuffer: ye,
      validateFramebuffer: be,
      getFramebufferErrorMessage: xe,
      getBatchDim: Ee,
      getRowsCols: Se,
      getShapeAs3D: _e,
      getTextureShapeFromLogicalShape: Re,
      isReshapeFree: Ae,
      getWebGLMaxTextureSize: Ne,
      resetMaxTextureSize: function () {
        ee = null
      },
      resetMaxTexturesInShader: function () {
        ne = null
      },
      getMaxTexturesInShader: ke,
      getWebGLDisjointQueryTimerVersion: Te,
      hasExtension: De,
      isWebGLVersionEnabled: Oe,
      isCapableOfRenderingToFloatTexture: Fe,
      isDownloadFloatTextureEnabled: Me,
      isWebGLFenceEnabled: Be,
    }),
    We = f
  function ze(t) {
    f.getBool('DEPRECATION_WARNINGS_ENABLED') &&
      console.warn(t + ' You can disable deprecation warnings with tf.disableDeprecationWarnings().')
  }
  function Ge(t, e) {
    return Pt.tidy(t, e)
  }
  function Ue(t) {
    kt(t).forEach(function (t) {
      return t.dispose()
    })
  }
  function Ve() {
    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e]
    f.getBool('IS_TEST') || console.warn.apply(console, t)
  }
  function He(t, e) {
    var n = t
    if (z(t)) return 'string' === e ? [] : [t.length]
    if (!Array.isArray(t)) return []
    for (var r = []; Array.isArray(n) || (z(n) && 'string' !== e); ) r.push(n.length), (n = n[0])
    return (
      Array.isArray(t) &&
        f.getBool('TENSORLIKE_CHECK_SHAPE_CONSISTENCY') &&
        (function t(e, n, r) {
          if (((r = r || []), !Array.isArray(e) && !z(e)))
            return (
              A(0 === n.length, function () {
                return (
                  'Element arr[' + r.join('][') + '] is a primitive, but should be an array/TypedArray of ' + n[0] + ' elements'
                )
              }),
              0
            )
          A(0 < n.length, function () {
            return 'Element arr[' + r.join('][') + '] should be a primitive, but is an array of ' + e.length + ' elements'
          }),
            A(e.length === n[0], function () {
              return 'Element arr[' + r.join('][') + '] should have ' + n[0] + ' elements, but has ' + e.length + ' elements'
            })
          for (var o = n.slice(1), i = 0; i < e.length; ++i) t(e[i], o, r.concat(i))
        })(t, r, []),
      r
    )
  }
  function je(t, e, n, r) {
    if (null != t && (('numeric' !== t && t !== e) || ('numeric' === t && 'string' === e)))
      throw new Error("Argument '" + n + "' passed to '" + r + "' must be " + t + ' tensor, but got ' + e + ' tensor')
  }
  function qe(t, e, n, r) {
    if ((void 0 === r && (r = 'numeric'), t instanceof bt)) return je(r, t.dtype, e, n), t
    var o = q(t)
    if (
      (je(r, (o = 'string' !== o && 0 <= ['bool', 'int32', 'float32'].indexOf(r) ? r : o), e, n),
      null == t || (!z(t) && !Array.isArray(t) && 'number' != typeof t && 'boolean' != typeof t && 'string' != typeof t))
    ) {
      var i = null == t ? 'null' : t.constructor.name
      throw new Error("Argument '" + e + "' passed to '" + n + "' must be a Tensor or TensorLike, but got '" + i + "'")
    }
    i = He(t, o)
    z(t) || Array.isArray(t) || (t = [t])
    t = 'string' !== o ? Y(t, o, f.getBool('DEBUG')) : E(t, [], !0)
    return Pt.makeTensor(t, i, o)
  }
  function Ke(t, n, r, e) {
    if ((void 0 === e && (e = 'numeric'), !Array.isArray(t)))
      throw new Error('Argument ' + n + ' passed to ' + r + ' must be a `Tensor[]` or `TensorLike[]`')
    return t.map(function (t, e) {
      return qe(t, n + '[' + e + ']', r)
    }, e)
  }
  function Xe(t, e) {
    for (var n = 0; n < t.length; ++n) if (t[t.length - n - 1] !== e - 1 - n) return !1
    return !0
  }
  function $e(t, e, n) {
    for (var r = t.length + e.length, o = [], i = 0, a = 0, s = 0; s < r; s++)
      -1 === n.indexOf(s) ? o.push(t[i++]) : o.push(e[a++])
    return o
  }
  function Ye(e, t) {
    for (var n = [], r = e.length, o = 0; o < r; o++) -1 === t.indexOf(o) && n.push(e[o])
    return [
      n,
      t.map(function (t) {
        return e[t]
      }),
    ]
  }
  function Je(t, e) {
    return $e(
      t,
      e.map(function (t) {
        return 1
      }),
      e,
    )
  }
  function Qe(t, e, n) {
    A(Xe(e, n), function () {
      return t + ' supports only inner-most axes for now. Got axes ' + e + ' and rank-' + n + ' input.'
    })
  }
  function Ze(t, e) {
    if (Xe(t, e)) return null
    for (var n = [], r = 0; r < e; ++r) -1 === t.indexOf(r) && n.push(r)
    return (
      t.forEach(function (t) {
        return n.push(t)
      }),
      n
    )
  }
  function tn(t) {
    return t
      .map(function (t, e) {
        return [e, t]
      })
      .sort(function (t, e) {
        return t[1] - e[1]
      })
      .map(function (t) {
        return t[0]
      })
  }
  function en(t, e) {
    for (var n = [], r = e - t; r < e; ++r) n.push(r)
    return n
  }
  function nn(t, r) {
    var o = t[0].length
    t.forEach(function (t, e) {
      A(t.length === o, function () {
        return 'Error in concat' + o + 'D: rank of tensors[' + e + '] must be the same as the rank of the rest (' + o + ')'
      })
    }),
      A(0 <= r && r < o, function () {
        return 'Error in concat' + o + 'D: axis must be between 0 and ' + (o - 1) + '.'
      })
    var i = t[0]
    t.forEach(function (t, e) {
      for (var n = 0; n < o; n++)
        A(n === r || t[n] === i[n], function () {
          return (
            'Error in concat' +
            o +
            'D: Shape of tensors[' +
            e +
            '] (' +
            t +
            ') does not match the shape of the rest (' +
            i +
            ') along the non-concatenated axis ' +
            e +
            '.'
          )
        })
    })
  }
  function rn(t, e) {
    for (var n = t[0].slice(), r = 1; r < t.length; r++) n[e] += t[r][e]
    return n
  }
  function on(t) {
    var e = Object.keys(t)
    if (1 !== e.length)
      throw new Error(
        'Please provide an object with a single key (operation name) mapping to a function. Got an object with ' +
          e.length +
          ' keys.',
      )
    var r = e[0],
      o = t[r]
    r.endsWith('_') && (r = r.substring(0, r.length - 1))
    t = function () {
      for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e]
      Pt.startScope(r)
      try {
        var n = o.apply(void 0, t)
        return n instanceof Promise && console.error('Cannot return a Promise inside of tidy.'), Pt.endScope(n), n
      } catch (t) {
        throw (Pt.endScope(null), t)
      }
    }
    return Object.defineProperty(t, 'name', { value: r, configurable: !0 }), t
  }
  We.registerFlag('HAS_WEBGL', function () {
    return 0 < We.getNumber('WEBGL_VERSION')
  }),
    We.registerFlag('WEBGL_VERSION', function () {
      return Oe(2) ? 2 : Oe(1) ? 1 : 0
    }),
    We.registerFlag('WEBGL_BUFFER_SUPPORTED', function () {
      return 2 === We.get('WEBGL_VERSION')
    }),
    We.registerFlag('WEBGL_CPU_FORWARD', function () {
      return !0
    }),
    We.registerFlag('WEBGL_FORCE_F16_TEXTURES', function () {
      return !1
    }),
    We.registerFlag('WEBGL_PACK', function () {
      return We.getBool('HAS_WEBGL')
    }),
    We.registerFlag('WEBGL_PACK_NORMALIZATION', function () {
      return We.getBool('WEBGL_PACK')
    }),
    We.registerFlag('WEBGL_PACK_CLIP', function () {
      return We.getBool('WEBGL_PACK')
    }),
    We.registerFlag('WEBGL_PACK_DEPTHWISECONV', function () {
      return !1
    }),
    We.registerFlag('WEBGL_PACK_BINARY_OPERATIONS', function () {
      return We.getBool('WEBGL_PACK')
    }),
    We.registerFlag('WEBGL_PACK_UNARY_OPERATIONS', function () {
      return We.getBool('WEBGL_PACK')
    }),
    We.registerFlag('WEBGL_PACK_ARRAY_OPERATIONS', function () {
      return We.getBool('WEBGL_PACK')
    }),
    We.registerFlag('WEBGL_PACK_IMAGE_OPERATIONS', function () {
      return We.getBool('WEBGL_PACK')
    }),
    We.registerFlag('WEBGL_PACK_REDUCE', function () {
      return We.getBool('WEBGL_PACK')
    }),
    We.registerFlag('WEBGL_LAZILY_UNPACK', function () {
      return We.getBool('WEBGL_PACK')
    }),
    We.registerFlag('WEBGL_CONV_IM2COL', function () {
      return We.getBool('WEBGL_PACK')
    }),
    We.registerFlag('WEBGL_MAX_TEXTURE_SIZE', function () {
      return Ne(We.getNumber('WEBGL_VERSION'))
    }),
    We.registerFlag('WEBGL_MAX_TEXTURES_IN_SHADER', function () {
      return ke(We.getNumber('WEBGL_VERSION'))
    }),
    We.registerFlag('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION', function () {
      var t = We.getNumber('WEBGL_VERSION')
      return 0 === t ? 0 : Te(t)
    }),
    We.registerFlag('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE', function () {
      return (
        0 < We.getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') &&
        ((t = navigator.userAgent || navigator.vendor || window.opera),
        !(
          /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(
            t,
          ) ||
          /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(
            t.substr(0, 4),
          )
        ))
      )
      var t
    }),
    We.registerFlag('WEBGL_RENDER_FLOAT32_CAPABLE', function () {
      return Fe(We.getNumber('WEBGL_VERSION'))
    }),
    We.registerFlag('WEBGL_RENDER_FLOAT32_ENABLED', function () {
      return !We.getBool('WEBGL_FORCE_F16_TEXTURES') && We.getBool('WEBGL_RENDER_FLOAT32_CAPABLE')
    }),
    We.registerFlag('WEBGL_DOWNLOAD_FLOAT_ENABLED', function () {
      return Me(We.getNumber('WEBGL_VERSION'))
    }),
    We.registerFlag('WEBGL_FENCE_API_ENABLED', function () {
      return Be(We.getNumber('WEBGL_VERSION'))
    }),
    We.registerFlag('WEBGL_SIZE_UPLOAD_UNIFORM', function () {
      return We.getBool('WEBGL_RENDER_FLOAT32_ENABLED') ? 4 : 0
    })
  var gt = ze,
    an = on({
      complex_: function (t, e) {
        var n = qe(t, 'real', 'complex'),
          r = qe(e, 'imag', 'complex')
        return (
          y(n.shape, r.shape, 'real and imag shapes, ' + n.shape + ' and ' + r.shape + ', must match in call to tf.complex().'),
          Pt.runKernelFunc(
            function (t) {
              return t.complex(n, r)
            },
            { $real: n, $imag: r },
          )
        )
      },
    }),
    sn = on({
      real_: function (t) {
        var e = qe(t, 'input', 'real')
        return Pt.runKernelFunc(
          function (t) {
            return t.real(e)
          },
          { $input: e },
        )
      },
    }),
    un = on({
      imag_: function (t) {
        var e = qe(t, 'input', 'imag')
        return Pt.runKernelFunc(
          function (t) {
            return t.imag(e)
          },
          { $input: e },
        )
      },
    })
  function cn(t, e, n) {
    return ln(t, e, He(t, n), n)
  }
  function ln(t, e, n, r) {
    if ('complex64' === (r = null == r ? q(t) : r))
      throw new Error('Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).')
    if (!z(t) && !Array.isArray(t) && 'number' != typeof t && 'boolean' != typeof t && 'string' != typeof t)
      throw new Error(
        'values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray',
      )
    if (null != e) {
      et(e)
      var o = D(e),
        i = D(n)
      A(o === i, function () {
        return 'Based on the provided shape, [' + e + '], the tensor should have ' + o + ' values but has ' + i
      })
      for (var a = 0; a < n.length; ++a) {
        var s = n[a],
          s = a !== n.length - 1 || s !== D(e.slice(a))
        A(n[a] === e[a] || !s, function () {
          return 'Error creating a new Tensor. Inferred shape (' + n + ') does not match the provided shape (' + e + '). '
        })
      }
    }
    return (
      z(t) || Array.isArray(t) || (t = [t]),
      (e = e || n),
      (t = 'string' !== r ? Y(t, r, f.getBool('DEBUG')) : E(t, [], !0)),
      Pt.makeTensor(t, e, r)
    )
  }
  function hn(t, e) {
    if (((z(t) && 'string' !== e) || Array.isArray(t)) && 'complex64' !== e)
      throw new Error('Error creating a new Scalar: value must be a primitive (number|boolean|string)')
    if ('string' === e && z(t) && !(t instanceof Uint8Array))
      throw new Error('When making a scalar from encoded string, the value must be `Uint8Array`.')
    return ln(t, [], [], e)
  }
  function pn(t, e) {
    b(t)
    var n = He(t, e)
    if (1 !== n.length) throw new Error('tensor1d() requires values to be a flat/TypedArray')
    return ln(t, null, n, e)
  }
  function dn(t, e, n) {
    if ((b(t), null != e && 2 !== e.length)) throw new Error('tensor2d() requires shape to have two numbers')
    var r = He(t, n)
    if (2 !== r.length && 1 !== r.length) throw new Error('tensor2d() requires values to be number[][] or flat/TypedArray')
    if (1 === r.length && null == e)
      throw new Error('tensor2d() requires shape to be provided when `values` are a flat/TypedArray')
    return ln(t, e, r, n)
  }
  function fn(t, e, n) {
    if ((b(t), null != e && 3 !== e.length)) throw new Error('tensor3d() requires shape to have three numbers')
    var r = He(t, n)
    if (3 !== r.length && 1 !== r.length) throw new Error('tensor3d() requires values to be number[][][] or flat/TypedArray')
    if (1 === r.length && null == e) throw new Error('tensor3d() requires shape to be provided when `values` are a flat array')
    return ln(t, e, r, n)
  }
  function vn(t, e, n) {
    if ((b(t), null != e && 4 !== e.length)) throw new Error('tensor4d() requires shape to have four numbers')
    var r = He(t, n)
    if (4 !== r.length && 1 !== r.length) throw new Error('tensor4d() requires values to be number[][][][] or flat/TypedArray')
    if (1 === r.length && null == e) throw new Error('tensor4d() requires shape to be provided when `values` are a flat array')
    return ln(t, e, r, n)
  }
  function mn(t, e) {
    if ('complex64' === (e = void 0 === e ? 'float32' : e)) {
      var n = mn(t, 'float32'),
        r = gn(t, 'float32')
      return an(n, r)
    }
    r = Q(D(t), e)
    return Pt.makeTensor(r, t, e)
  }
  function gn(t, e) {
    if ('complex64' === (e = void 0 === e ? 'float32' : e)) {
      var n = gn(t, 'float32'),
        r = gn(t, 'float32')
      return an(n, r)
    }
    r = Z(D(t), e)
    return Pt.makeTensor(r, t, e)
  }
  function yn(e, n, r) {
    return Pt.runKernelFunc(function (t) {
      return t.fill(e, n, r)
    }, {})
  }
  function bn(t, e, n, r) {
    if ((void 0 === r && (r = 'float32'), 0 === (n = void 0 === n ? 1 : n))) throw new Error('Cannot have a step of zero')
    if (t === e || (t < e && n < 0) || (e < t && 1 < n)) return gn([0], r)
    var o = Z(Math.abs(Math.ceil((e - t) / n)), r)
    e < t && 1 === n && (n = -1), (o[0] = t)
    for (var i = 1; i < o.length; i++) o[i] = o[i - 1] + n
    return pn(o, r)
  }
  var xn = on({
      onesLike_: function (t) {
        var e = qe(t, 'x', 'onesLike')
        if ('complex64' !== e.dtype)
          return Pt.runKernelFunc(
            function (t) {
              return t.onesLike(e)
            },
            { $x: e },
            function (t, e) {
              return {
                $x: function () {
                  return wn(t)
                },
              }
            },
          )
        var n = xn(sn(e)),
          t = wn(un(e))
        return an(n, t)
      },
    }),
    wn = on({
      zerosLike_: function (t) {
        var e = qe(t, 'x', 'zerosLike')
        return Pt.runKernelFunc(
          function (t) {
            return t.zerosLike(e)
          },
          { $x: e },
          function (t, e) {
            return {
              $x: function () {
                return wn(t)
              },
            }
          },
        )
      },
    }),
    Cn = on({
      concat_: function (t, n) {
        void 0 === n && (n = 0),
          A(1 <= t.length, function () {
            return 'Pass at least one tensor to concat'
          })
        var e = Ke(t, 'tensors', 'concat')
        'complex64' === e[0].dtype &&
          e.forEach(function (t) {
            if ('complex64' !== t.dtype)
              throw new Error('Cannot concatenate complex64 tensors with a tensor\n          with dtype ' + t.dtype + '. ')
          }),
          (n = O(n, e[0].shape)[0])
        t = rn(
          e.map(function (t) {
            return t.shape
          }),
          n,
        )
        if (0 === D(t)) return cn([], t)
        if (
          1 ===
          (e = e.filter(function (t) {
            return 0 < t.size
          })).length
        )
          return e[0]
        var r = e.map(function (t) {
          return t.shape
        })
        nn(r, n)
        t = { axis: n }
        return Pt.runKernelFunc(
          function (t) {
            return t.concat(e, n)
          },
          e,
          function (t) {
            var e = r.map(function (t) {
              return t[n]
            })
            return In(t, e, n).map(function (t) {
              return function () {
                return t
              }
            })
          },
          'Concat',
          t,
        )
      },
    }),
    En = on({
      concat1d_: function (t) {
        return Cn(t, 0)
      },
    }),
    Sn = on({
      concat2d_: function (t, e) {
        return Cn(t, e)
      },
    }),
    _n = on({
      concat3d_: function (t, e) {
        return Cn(t, e)
      },
    }),
    Rn = on({
      concat4d_: function (t, e) {
        return Cn(t, e)
      },
    }),
    In = on({
      split_: function (t, e, n) {
        void 0 === n && (n = 0)
        var r,
          o = qe(t, 'x', 'split')
        return (
          (n = O(n, o.shape)[0]),
          (r =
            'number' == typeof e
              ? (A(o.shape[n] % e == 0, function () {
                  return 'Number of splits must evenly divide the axis.'
                }),
                new Array(e).fill(o.shape[n] / e))
              : (A(
                  o.shape[n] ===
                    e.reduce(function (t, e) {
                      return t + e
                    }),
                  function () {
                    return 'The sum of sizes must match the size of the axis dimension.'
                  },
                ),
                e)),
          Pt.runKernelFunc(
            function (t) {
              return t.split(o, r, n)
            },
            { $x: o },
            function (t) {
              return {
                $x: function () {
                  return Cn(t, n)
                },
              }
            },
          )
        )
      },
    })
  function An(t, e) {
    return t((e = { exports: {} }), e.exports), e.exports
  }
  var Nn = An(function (e) {
      !(function () {
        function o(t) {
          var r,
            e = this,
            n =
              ((r = 4022871197),
              function (t) {
                t = t.toString()
                for (var e = 0; e < t.length; e++) {
                  var n = 0.02519603282416938 * (r += t.charCodeAt(e))
                  ;(n -= r = n >>> 0), (r = (n *= r) >>> 0), (r += 4294967296 * (n -= r))
                }
                return 2.3283064365386963e-10 * (r >>> 0)
              })
          ;(e.next = function () {
            var t = 2091639 * e.s0 + 2.3283064365386963e-10 * e.c
            return (e.s0 = e.s1), (e.s1 = e.s2), (e.s2 = t - (e.c = 0 | t))
          }),
            (e.c = 1),
            (e.s0 = n(' ')),
            (e.s1 = n(' ')),
            (e.s2 = n(' ')),
            (e.s0 -= n(t)),
            e.s0 < 0 && (e.s0 += 1),
            (e.s1 -= n(t)),
            e.s1 < 0 && (e.s1 += 1),
            (e.s2 -= n(t)),
            e.s2 < 0 && (e.s2 += 1),
            (n = null)
        }
        function i(t, e) {
          return (e.c = t.c), (e.s0 = t.s0), (e.s1 = t.s1), (e.s2 = t.s2), e
        }
        function t(t, e) {
          var n = new o(t),
            e = e && e.state,
            r = n.next
          return (
            (r.int32 = function () {
              return (4294967296 * n.next()) | 0
            }),
            (r.double = function () {
              return r() + 11102230246251564e-32 * ((2097152 * r()) | 0)
            }),
            (r.quick = r),
            e &&
              ('object' == typeof e && i(e, n),
              (r.state = function () {
                return i(n, {})
              })),
            r
          )
        }
        e && e.exports ? (e.exports = t) : (this.alea = t)
      })()
    }),
    kn = An(function (e) {
      !(function () {
        function r(t) {
          var e = this,
            n = ''
          ;(e.x = 0),
            (e.y = 0),
            (e.z = 0),
            (e.w = 0),
            (e.next = function () {
              var t = e.x ^ (e.x << 11)
              return (e.x = e.y), (e.y = e.z), (e.z = e.w), (e.w ^= (e.w >>> 19) ^ t ^ (t >>> 8))
            }),
            t === (0 | t) ? (e.x = t) : (n += t)
          for (var r = 0; r < n.length + 64; r++) (e.x ^= 0 | n.charCodeAt(r)), e.next()
        }
        function o(t, e) {
          return (e.x = t.x), (e.y = t.y), (e.z = t.z), (e.w = t.w), e
        }
        function t(t, e) {
          var n = new r(t),
            t = e && e.state,
            e = function () {
              return (n.next() >>> 0) / 4294967296
            }
          return (
            (e.double = function () {
              do {
                var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
              } while (0 === t)
              return t
            }),
            (e.int32 = n.next),
            (e.quick = e),
            t &&
              ('object' == typeof t && o(t, n),
              (e.state = function () {
                return o(n, {})
              })),
            e
          )
        }
        e && e.exports ? (e.exports = t) : (this.xor128 = t)
      })()
    }),
    Tn = An(function (e) {
      !(function () {
        function r(t) {
          var e = this,
            n = ''
          ;(e.next = function () {
            var t = e.x ^ (e.x >>> 2)
            return (
              (e.x = e.y),
              (e.y = e.z),
              (e.z = e.w),
              (e.w = e.v),
              ((e.d = (e.d + 362437) | 0) + (e.v = e.v ^ (e.v << 4) ^ t ^ (t << 1))) | 0
            )
          }),
            (e.x = 0),
            (e.y = 0),
            (e.z = 0),
            (e.w = 0),
            t === ((e.v = 0) | t) ? (e.x = t) : (n += t)
          for (var r = 0; r < n.length + 64; r++)
            (e.x ^= 0 | n.charCodeAt(r)), r == n.length && (e.d = (e.x << 10) ^ (e.x >>> 4)), e.next()
        }
        function o(t, e) {
          return (e.x = t.x), (e.y = t.y), (e.z = t.z), (e.w = t.w), (e.v = t.v), (e.d = t.d), e
        }
        function t(t, e) {
          var n = new r(t),
            t = e && e.state,
            e = function () {
              return (n.next() >>> 0) / 4294967296
            }
          return (
            (e.double = function () {
              do {
                var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
              } while (0 === t)
              return t
            }),
            (e.int32 = n.next),
            (e.quick = e),
            t &&
              ('object' == typeof t && o(t, n),
              (e.state = function () {
                return o(n, {})
              })),
            e
          )
        }
        e && e.exports ? (e.exports = t) : (this.xorwow = t)
      })()
    }),
    Dn = An(function (e) {
      !(function () {
        function r(t) {
          var o = this
          ;(o.next = function () {
            var t = o.x,
              e = o.i,
              n = t[e],
              r = (n ^= n >>> 7) ^ (n << 24)
            return (
              (r ^= (n = t[(e + 1) & 7]) ^ (n >>> 10)),
              (r ^= (n = t[(e + 3) & 7]) ^ (n >>> 3)),
              (r ^= (n = t[(e + 4) & 7]) ^ (n << 7)),
              (n = t[(e + 7) & 7]),
              (r ^= (n ^= n << 13) ^ (n << 9)),
              (t[e] = r),
              (o.i = (e + 1) & 7),
              r
            )
          }),
            (function (t, e) {
              var n,
                r = []
              if (e === (0 | e)) r[0] = e
              else
                for (e = '' + e, n = 0; n < e.length; ++n)
                  r[7 & n] = (r[7 & n] << 15) ^ ((e.charCodeAt(n) + r[(n + 1) & 7]) << 13)
              for (; r.length < 8; ) r.push(0)
              for (n = 0; n < 8 && 0 === r[n]; ++n);
              for (8 == n ? (r[7] = -1) : r[n], t.x = r, t.i = 0, n = 256; 0 < n; --n) t.next()
            })(o, t)
        }
        function o(t, e) {
          return (e.x = t.x.slice()), (e.i = t.i), e
        }
        function t(t, e) {
          var n = new r((t = null == t ? +new Date() : t)),
            t = e && e.state,
            e = function () {
              return (n.next() >>> 0) / 4294967296
            }
          return (
            (e.double = function () {
              do {
                var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
              } while (0 === t)
              return t
            }),
            (e.int32 = n.next),
            (e.quick = e),
            t &&
              (t.x && o(t, n),
              (e.state = function () {
                return o(n, {})
              })),
            e
          )
        }
        e && e.exports ? (e.exports = t) : (this.xorshift7 = t)
      })()
    }),
    On = An(function (e) {
      !(function () {
        function r(t) {
          var i = this
          ;(i.next = function () {
            var t,
              e,
              n = i.w,
              r = i.X,
              o = i.i
            return (
              (i.w = n = (n + 1640531527) | 0),
              (e = r[(o + 34) & 127]),
              (t = r[(o = (o + 1) & 127)]),
              (e ^= e << 13),
              (t ^= t << 17),
              (e ^= e >>> 15),
              (t ^= t >>> 12),
              (e = r[o] = e ^ t),
              (i.i = o),
              (e + (n ^ (n >>> 16))) | 0
            )
          }),
            (function (t, e) {
              var n,
                r,
                o,
                i,
                a,
                s = [],
                u = 128
              for (
                e === (0 | e) ? ((r = e), (e = null)) : ((e += '\0'), (r = 0), (u = Math.max(u, e.length))), o = 0, i = -32;
                i < u;
                ++i
              )
                e && (r ^= e.charCodeAt((i + 32) % e.length)),
                  0 === i && (a = r),
                  (r ^= r << 10),
                  (r ^= r >>> 15),
                  (r ^= r << 4),
                  (r ^= r >>> 13),
                  0 <= i && ((a = (a + 1640531527) | 0), (o = 0 == (n = s[127 & i] ^= r + a) ? o + 1 : 0))
              for (128 <= o && (s[127 & ((e && e.length) || 0)] = -1), o = 127, i = 512; 0 < i; --i)
                (r = s[(o + 34) & 127]),
                  (n = s[(o = (o + 1) & 127)]),
                  (r ^= r << 13),
                  (n ^= n << 17),
                  (r ^= r >>> 15),
                  (n ^= n >>> 12),
                  (s[o] = r ^ n)
              ;(t.w = a), (t.X = s), (t.i = o)
            })(i, t)
        }
        function o(t, e) {
          return (e.i = t.i), (e.w = t.w), (e.X = t.X.slice()), e
        }
        function t(t, e) {
          var n = new r((t = null == t ? +new Date() : t)),
            t = e && e.state,
            e = function () {
              return (n.next() >>> 0) / 4294967296
            }
          return (
            (e.double = function () {
              do {
                var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
              } while (0 === t)
              return t
            }),
            (e.int32 = n.next),
            (e.quick = e),
            t &&
              (t.X && o(t, n),
              (e.state = function () {
                return o(n, {})
              })),
            e
          )
        }
        e && e.exports ? (e.exports = t) : (this.xor4096 = t)
      })()
    }),
    Fn = An(function (e) {
      !(function () {
        function r(t) {
          var o = this,
            e = ''
          ;(o.next = function () {
            var t = ((t = o.b) << 25) ^ (t >>> 7) ^ (e = o.c),
              e = (e - (n = o.d)) | 0,
              n = (n << 24) ^ (n >>> 8) ^ (r = o.a),
              r = (r - t) | 0
            return (
              (o.b = t = (t << 20) ^ (t >>> 12) ^ e),
              (o.c = e = (e - n) | 0),
              (o.d = (n << 16) ^ (e >>> 16) ^ r),
              (o.a = (r - t) | 0)
            )
          }),
            (o.a = 0),
            (o.b = 0),
            (o.c = -1640531527),
            (o.d = 1367130551),
            t === Math.floor(t) ? ((o.a = (t / 4294967296) | 0), (o.b = 0 | t)) : (e += t)
          for (var n = 0; n < e.length + 20; n++) (o.b ^= 0 | e.charCodeAt(n)), o.next()
        }
        function o(t, e) {
          return (e.a = t.a), (e.b = t.b), (e.c = t.c), (e.d = t.d), e
        }
        function t(t, e) {
          var n = new r(t),
            t = e && e.state,
            e = function () {
              return (n.next() >>> 0) / 4294967296
            }
          return (
            (e.double = function () {
              do {
                var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
              } while (0 === t)
              return t
            }),
            (e.int32 = n.next),
            (e.quick = e),
            t &&
              ('object' == typeof t && o(t, n),
              (e.state = function () {
                return o(n, {})
              })),
            e
          )
        }
        e && e.exports ? (e.exports = t) : (this.tychei = t)
      })()
    }),
    Mn = An(function (e) {
      !(function (i, a) {
        var s,
          u = this,
          c = 256,
          l = 6,
          h = 'random',
          p = a.pow(c, l),
          d = a.pow(2, 52),
          f = 2 * d,
          v = c - 1
        function t(t, e, n) {
          var r = [],
            t = y(
              (function t(e, n) {
                var r,
                  o = [],
                  i = typeof e
                if (n && 'object' == i)
                  for (r in e)
                    try {
                      o.push(t(e[r], n - 1))
                    } catch (t) {}
                return o.length ? o : 'string' == i ? e : e + '\0'
              })(
                (e = 1 == e ? { entropy: !0 } : e || {}).entropy
                  ? [t, b(i)]
                  : null == t
                  ? (function () {
                      try {
                        var t
                        return (
                          s && (t = s.randomBytes)
                            ? (t = t(c))
                            : ((t = new Uint8Array(c)), (u.crypto || u.msCrypto).getRandomValues(t)),
                          b(t)
                        )
                      } catch (t) {
                        var e = u.navigator,
                          e = e && e.plugins
                        return [+new Date(), u, e, u.screen, b(i)]
                      }
                    })()
                  : t,
                3,
              ),
              r,
            ),
            o = new m(r),
            r = function () {
              for (var t = o.g(l), e = p, n = 0; t < d; ) (t = (t + n) * c), (e *= c), (n = o.g(1))
              for (; f <= t; ) (t /= 2), (e /= 2), (n >>>= 1)
              return (t + n) / e
            }
          return (
            (r.int32 = function () {
              return 0 | o.g(4)
            }),
            (r.quick = function () {
              return o.g(4) / 4294967296
            }),
            (r.double = r),
            y(b(o.S), i),
            (
              e.pass ||
              n ||
              function (t, e, n, r) {
                return (
                  r &&
                    (r.S && g(r, o),
                    (t.state = function () {
                      return g(o, {})
                    })),
                  n ? ((a[h] = t), e) : t
                )
              }
            )(r, t, 'global' in e ? e.global : this == a, e.state)
          )
        }
        function m(t) {
          var e,
            n = t.length,
            a = this,
            r = 0,
            o = (a.i = a.j = 0),
            i = (a.S = [])
          for (n || (t = [n++]); r < c; ) i[r] = r++
          for (r = 0; r < c; r++) (i[r] = i[(o = v & (o + t[r % n] + (e = i[r])))]), (i[o] = e)
          ;(a.g = function (t) {
            for (var e, n = 0, r = a.i, o = a.j, i = a.S; t--; )
              (e = i[(r = v & (r + 1))]), (n = n * c + i[v & ((i[r] = i[(o = v & (o + e))]) + (i[o] = e))])
            return (a.i = r), (a.j = o), n
          })(c)
        }
        function g(t, e) {
          return (e.i = t.i), (e.j = t.j), (e.S = t.S.slice()), e
        }
        function y(t, e) {
          for (var n, r = t + '', o = 0; o < r.length; ) e[v & o] = v & ((n ^= 19 * e[v & o]) + r.charCodeAt(o++))
          return b(e)
        }
        function b(t) {
          return String.fromCharCode.apply(0, t)
        }
        if (((a['seed' + h] = t), y(a.random(), i), e.exports)) {
          e.exports = t
          try {
            s = require('crypto')
          } catch (t) {}
        }
      })([], Math)
    })
  ;(Mn.alea = Nn), (Mn.xor128 = kn), (Mn.xorwow = Tn), (Mn.xorshift7 = Dn), (Mn.xor4096 = On), (Mn.tychei = Fn)
  var Pn = Mn.alea,
    Bn =
      ((Un.prototype.nextValue = function () {
        if (!isNaN(this.nextVal)) {
          var t = this.nextVal
          return (this.nextVal = NaN), t
        }
        for (var e = !1; !e; ) {
          for (
            var n = void 0, r = void 0, o = void 0;
            (o = (n = 2 * this.random() - 1) * n + (r = 2 * this.random() - 1) * r), 1 <= o || 0 === o;

          );
          var i = Math.sqrt((-2 * Math.log(o)) / o),
            a = this.mean + this.stdDev * n * i,
            s = this.mean + this.stdDev * r * i
          ;(this.truncated && !this.isValidTruncated(a)) || (e = !0)
        }
        return (this.truncated && !this.isValidTruncated(s)) || (this.nextVal = this.convertValue(s)), this.convertValue(a)
      }),
      (Un.prototype.convertValue = function (t) {
        return null == this.dtype || 'float32' === this.dtype ? t : Math.round(t)
      }),
      (Un.prototype.isValidTruncated = function (t) {
        return t <= this.upper && t >= this.lower
      }),
      Un),
    Ln =
      ((Gn.prototype.nextValue = function () {
        for (var t, e, n, r, o; ; ) {
          for (; (n = this.randn.nextValue()), (o = 1 + this.c * n), o <= 0; );
          if (
            ((o *= o * o),
            (t = 1 - 0.331 * (r = n * n) * r),
            (e = 0.5 * r + this.d * (1 - o + Math.log(o))),
            (r = this.randu()) < t || Math.log(r) < e)
          )
            break
        }
        return (
          (o = (1 / this.beta) * this.d * o),
          this.alpha < 1 && (o *= Math.pow(this.randu(), 1 / this.alpha)),
          this.convertValue(o)
        )
      }),
      (Gn.prototype.convertValue = function (t) {
        return 'float32' === this.dtype ? t : Math.round(t)
      }),
      Gn),
    Wn =
      ((zn.prototype.convertValue = function (t) {
        return this.canReturnFloat() ? t : Math.round(t)
      }),
      (zn.prototype.nextValue = function () {
        return this.convertValue(this.min + this.range * this.random())
      }),
      zn)
  function zn(t, e, n, r) {
    var o = this
    if (
      (void 0 === t && (t = 0),
      void 0 === e && (e = 1),
      (this.canReturnFloat = function () {
        return null == o.dtype || 'float32' === o.dtype
      }),
      (this.min = t),
      (this.range = e - t),
      (this.dtype = n),
      'number' == typeof (r = null == r ? Math.random() : r) && (r = r.toString()),
      !this.canReturnFloat() && this.range <= 1)
    )
      throw new Error('The difference between ' + t + ' - ' + e + ' <= 1 and dtype is not float')
    this.random = Pn(r)
  }
  function Gn(t, e, n, r) {
    ;(this.alpha = t), (this.beta = 1 / e), (this.dtype = n)
    r = r || Math.random()
    ;(this.randu = Pn(r.toString())),
      (this.randn = new Bn(0, 1, n, !1, this.randu())),
      (this.d = t < 1 ? t + 2 / 3 : t - 1 / 3),
      (this.c = 1 / Math.sqrt(9 * this.d))
  }
  function Un(t, e, n, r, o) {
    ;(this.mean = t),
      (this.stdDev = e),
      (this.dtype = n),
      (this.nextVal = NaN),
      (this.truncated = r),
      this.truncated && ((this.upper = this.mean + 2 * this.stdDev), (this.lower = this.mean - 2 * this.stdDev))
    o = o || Math.random()
    this.random = Pn(o.toString())
  }
  function Vn(t, e, n) {
    return (e = (e = void 0 === e ? 'float32' : e) || 'float32'), et(t), new ft(t, e, n)
  }
  var Hn = on({
      batchToSpaceND_: function (t, e, n) {
        var r = qe(t, 'x', 'batchToSpaceND'),
          o = e.reduce(function (t, e) {
            return t * e
          })
        return (
          A(r.rank >= 1 + e.length, function () {
            return 'input rank is ' + r.rank + ' but should be > than blockShape.length ' + e.length
          }),
          A(n.length === e.length, function () {
            return 'crops.length is ' + n.length + ' but should be equal to blockShape.length  ' + e.length
          }),
          A(r.shape[0] % o == 0, function () {
            return (
              'input tensor batch is ' +
              r.shape[0] +
              ' but is not divisible by the product of the elements of blockShape ' +
              e.join(' * ') +
              ' === ' +
              o
            )
          }),
          Pt.runKernelFunc(
            function (t) {
              return t.batchToSpaceND(r, e, n)
            },
            { $x: r },
            function (t) {
              return {
                $x: function () {
                  return t.spaceToBatchND(e, n)
                },
              }
            },
          )
        )
      },
    }),
    jn = on({
      broadcastTo_: function (t, e) {
        var n = qe(t, 'broadcastTo', 'x'),
          r = n.shape
        if (
          e.some(function (t) {
            return !(0 < t) || t % 1 != 0
          })
        )
          throw new Error('broadcastTo(): Invalid broadcast shape [' + e + '].')
        if (e.length < n.rank) throw new Error('broadcastTo(): shape.length=' + e.length + ' < input.rank=' + n.rank + '.')
        if (e.length > n.rank) {
          for (var o = n.shape.slice(); o.length < e.length; ) o.unshift(1)
          n = n.reshape(o)
        }
        for (var i = Array.from(e), a = e.length - 1; 0 <= a; a--)
          if (n.shape[a] === e[a]) i[a] = 1
          else if (1 !== n.shape[a]) throw new Error('broadcastTo(): [' + r + '] cannot be broadcast to [' + e + '].')
        var s = i
          .map(function (t, e) {
            return 1 < t ? e : -1
          })
          .filter(function (t) {
            return 0 <= t
          })
        return 0 === s.length
          ? n.clone()
          : Pt.runKernelFunc(
              function (t) {
                return t.tile(n, i)
              },
              { input: n },
              function (t) {
                return {
                  input: function () {
                    return t.sum(s, !0)
                  },
                }
              },
            )
      },
    }),
    qn = on({
      cast_: function (t, e) {
        var n = qe(t, 'x', 'cast')
        if (!L(e)) throw new Error('Failed to cast to unknown dtype ' + e)
        if (('string' === e && 'string' !== n.dtype) || ('string' !== e && 'string' === n.dtype))
          throw new Error('Only strings can be casted to strings')
        t = { dtype: e }
        return Pt.runKernelFunc(
          function (t) {
            return t.cast(n, e)
          },
          { x: n },
          function (t) {
            return {
              x: function () {
                return t.clone()
              },
            }
          },
          'Cast',
          t,
        )
      },
    }),
    Kn = on({
      clone_: function (t) {
        var e = qe(t, 'x', 'clone', null)
        return Pt.runKernelFunc(
          function () {
            return Pt.makeTensorFromDataId(e.dataId, e.shape, e.dtype)
          },
          { $x: e },
          function (t) {
            return {
              $x: function () {
                return t.toFloat()
              },
            }
          },
        )
      },
    }),
    Xn = on({
      cumsum_: function (t, e, n, r) {
        void 0 === e && (e = 0), void 0 === n && (n = !1), void 0 === r && (r = !1)
        var o = qe(t, 'x', 'cumsum'),
          t = Ze([(e |= 0)], o.rank),
          i = o
        null != t && (i = o.transpose(t))
        var a = en(1, o.rank)[0],
          o = Pt.runKernelFunc(
            function (t) {
              return t.cumsum(i, a, n, r)
            },
            { permutedX: i },
            function (t) {
              return {
                permutedX: function () {
                  return t.cumsum(e, n, !r)
                },
              }
            },
          )
        return (o = null != t ? o.transpose(t) : o)
      },
    }),
    $n = on({
      depthToSpace_: function (t, e, n) {
        void 0 === n && (n = 'NHWC')
        var r = qe(t, 'x', 'depthToSpace'),
          o = 'NHWC' === n ? r.shape[1] : r.shape[2],
          i = 'NHWC' === n ? r.shape[2] : r.shape[3],
          a = 'NHWC' === n ? r.shape[3] : r.shape[1]
        return (
          A(0 <= o * e, function () {
            return (
              'Negative dimension size caused by overflow when multiplying\n      ' +
              o +
              ' and ' +
              e +
              '  for depthToSpace with input shape\n      ' +
              r.shape
            )
          }),
          A(0 <= i * e, function () {
            return (
              'Negative dimension size caused by overflow when multiplying\n      ' +
              i +
              ' and ' +
              e +
              ' for depthToSpace with input shape\n          ' +
              r.shape
            )
          }),
          A(a % (e * e) == 0, function () {
            return (
              'Dimension size must be evenly divisible by ' +
              e * e +
              ' but is ' +
              a +
              ' for depthToSpace with input shape ' +
              r.shape
            )
          }),
          Pt.runKernelFunc(
            function (t) {
              return t.depthToSpace(r, e, n)
            },
            { $x: r },
          )
        )
      },
    }),
    Yn = on({
      expandDims_: function (t, e) {
        void 0 === e && (e = 0)
        var n = qe(t, 'x', 'expandDims', null)
        A(e <= n.rank, function () {
          return 'Axis must be <= rank of the tensor'
        })
        t = n.shape.slice()
        return (
          e < 0 &&
            (A(-(n.rank + 1) <= e, function () {
              return 'Axis must be in the interval [' + -(n.rank + 1) + ', ' + n.rank + ']'
            }),
            (e = n.rank + e + 1)),
          t.splice(e, 0, 1),
          cr(n, t)
        )
      },
    }),
    Jn = on({
      eye_: function (t, e, n, r) {
        for (
          var o = Vn([t, (e = null == e ? t : e)], (r = void 0 === r ? 'float32' : r)), i = t <= e ? t : e, a = 0;
          a < i;
          ++a
        )
          o.set(1, a, a)
        e = o.toTensor().as2D(t, e)
        if (null == n) return e
        if (1 === n.length) return dr(Yn(e, 0), [n[0], 1, 1])
        if (2 === n.length) return dr(Yn(Yn(e, 0), 0), [n[0], n[1], 1, 1])
        if (3 === n.length) return dr(Yn(Yn(Yn(e, 0), 0), 0), [n[0], n[1], n[2], 1, 1])
        throw new Error('eye() currently supports only 1D and 2D batchShapes, but received ' + n.length + 'D.')
      },
    }),
    Qn = on({
      multinomial_: function (t, e, n, r) {
        void 0 === r && (r = !1)
        var o = qe(t, 'logits', 'multinomial'),
          i = o.size,
          t = o.rank
        if (i < 2) throw new Error('Error in multinomial: you need at least 2 outcomes, but got ' + i + '.')
        if (2 < t) throw new Error('Rank of probabilities must be 1 or 2, but is ' + t)
        n = n || Math.random()
        var a = 1 === t ? o.as2D(1, -1) : o,
          o = Pt.runKernelFunc(
            function (t) {
              return t.multinomial(a, r, e, n)
            },
            { logits2D: a },
          )
        return 1 === t ? o.as1D() : o
      },
    }),
    Zn = on({
      oneHot_: function (t, e, n, r) {
        if ((void 0 === n && (n = 1), void 0 === r && (r = 0), e < 2))
          throw new Error('Error in oneHot: depth must be >=2, but it is ' + e)
        var t = (o = qe(t, 'indices', 'oneHot', 'int32')).shape.concat([e]),
          o = o.flatten()
        return Pt.runKernelFunc(
          function (t) {
            return t.oneHot(o, e, n, r)
          },
          { $indices: o },
          function (t) {
            return {
              $indices: function () {
                return gn(o.shape, 'float32')
              },
            }
          },
        ).reshape(t)
      },
    }),
    tr = on({
      pad_: function (t, n, e) {
        void 0 === e && (e = 0)
        var r = qe(t, 'x', 'pad')
        if (0 === r.rank) throw new Error('pad(scalar) is not defined. Pass non-scalar to pad')
        t = { paddings: n, constantValue: e }
        return Pt.runKernelFunc(
          function (t) {
            return t.pad(r, n, e)
          },
          { x: r },
          function (t) {
            var e = n.map(function (t) {
              return t[0]
            })
            return {
              x: function () {
                return t.slice(e, r.shape)
              },
            }
          },
          'PadV2',
          t,
        )
      },
    }),
    er = on({
      pad1d_: function (t, e, n) {
        return (
          void 0 === n && (n = 0),
          A(2 === e.length, function () {
            return 'Invalid number of paddings. Must be length of 2.'
          }),
          tr(t, [e], n)
        )
      },
    }),
    nr = on({
      pad2d_: function (t, e, n) {
        return (
          void 0 === n && (n = 0),
          A(2 === e.length && 2 === e[0].length && 2 === e[1].length, function () {
            return 'Invalid number of paddings. Must be length of 2 each.'
          }),
          tr(t, e, n)
        )
      },
    }),
    rr = on({
      pad3d_: function (t, e, n) {
        return (
          void 0 === n && (n = 0),
          A(3 === e.length && 2 === e[0].length && 2 === e[1].length && 2 === e[2].length, function () {
            return 'Invalid number of paddings. Must be length of 2 each.'
          }),
          tr(t, e, n)
        )
      },
    }),
    or = on({
      pad4d_: function (t, e, n) {
        return (
          void 0 === n && (n = 0),
          A(4 === e.length && 2 === e[0].length && 2 === e[1].length && 2 === e[2].length && 2 === e[3].length, function () {
            return 'Invalid number of paddings. Must be length of 2 each.'
          }),
          tr(t, e, n)
        )
      },
    }),
    ir = on({
      rand_: function (t, e, n) {
        var r = D(t),
          o = null
        if (null == n || 'float32' === n) o = new Float32Array(r)
        else if ('int32' === n) o = new Int32Array(r)
        else {
          if ('bool' !== n) throw new Error('Unknown data type ' + n)
          o = new Uint8Array(r)
        }
        for (var i = 0; i < r; i++) o[i] = e()
        return Pt.makeTensor(o, t, n)
      },
    }),
    ar = on({
      randomNormal_: function (t, e, n, r, o) {
        if ((void 0 === e && (e = 0), void 0 === n && (n = 1), null != r && 'bool' === r))
          throw new Error('Unsupported data type ' + r)
        for (var i = new Bn(e, n, r, !1, o), a = Vn(t, r), s = 0; s < a.values.length; s++) a.values[s] = i.nextValue()
        return a.toTensor()
      },
    }),
    sr = on({
      randomGamma_: function (t, e, n, r, o) {
        if (
          (null == (n = void 0 === n ? 1 : n) && (n = 1),
          'float32' !== (r = null == (r = void 0 === r ? 'float32' : r) ? 'float32' : r) && 'int32' !== r)
        )
          throw new Error('Unsupported data type ' + r)
        for (var i = new Ln(e, n, r, o), a = Vn(t, r), s = 0; s < a.values.length; s++) a.values[s] = i.nextValue()
        return a.toTensor()
      },
    }),
    ur = on({
      randomUniform_: function (t, e, n, r, o) {
        void 0 === e && (e = 0), void 0 === n && (n = 1)
        for (var i = Vn(t, (r = void 0 === r ? 'float32' : r)), a = new Wn(e, n, null, o), s = 0; s < i.values.length; s++)
          i.values[s] = a.nextValue()
        return i.toTensor()
      },
    }),
    cr = on({
      reshape_: function (t, e) {
        var n = qe(t, 'x', 'reshape', null)
        ;(e = T(e, n.size)),
          A(n.size === D(e), function () {
            return 'new shape and old shape must have the same number of elements.'
          })
        t = { shape: e }
        return Pt.runKernelFunc(
          function (t) {
            return t.reshape(n, e)
          },
          { x: n },
          function (t) {
            return {
              x: function () {
                return t.reshape(n.shape)
              },
            }
          },
          'Reshape',
          t,
        )
      },
    }),
    lr = on({
      spaceToBatchND_: function (t, r, o) {
        var e = qe(t, 'x', 'spaceToBatchND')
        return (
          A(e.rank >= 1 + r.length, function () {
            return 'input rank ' + e.rank + ' should be > than [blockShape] ' + r.length
          }),
          A(o.length === r.length, function () {
            return 'paddings.shape[0] ' + o.length + ' must be equal to [blockShape] ' + r.length
          }),
          A(
            e.shape.reduce(function (t, e, n) {
              return 0 < n && n <= r.length ? t && (e + o[n - 1][0] + o[n - 1][1]) % r[n - 1] == 0 : t
            }, !0),
            function () {
              return (
                'input spatial dimensions ' +
                e.shape.slice(1) +
                ' with paddings ' +
                o.toString() +
                ' must be divisible by blockShapes ' +
                r.toString()
              )
            },
          ),
          Pt.runKernelFunc(
            function (t) {
              return t.spaceToBatchND(e, r, o)
            },
            { $x: e },
            function (t) {
              return {
                $x: function () {
                  return t.batchToSpaceND(r, o)
                },
              }
            },
          )
        )
      },
    }),
    hr = on({
      squeeze_: function (t, e) {
        t = qe(t, 'x', 'squeeze')
        return cr(t, F(t.shape, e).newShape)
      },
    }),
    pr = on({
      stack_: function (t, e) {
        void 0 === e && (e = 0)
        var n = Ke(t, 'tensors', 'stack')
        if (
          (A(1 <= n.length, function () {
            return 'Pass at least one tensor to tf.stack'
          }),
          1 === n.length)
        )
          return n[0].expandDims(e)
        var t = n[0].rank,
          r = n[0].shape,
          o = n[0].dtype
        A(e <= t, function () {
          return 'Axis must be <= rank of the tensor'
        }),
          n.forEach(function (t) {
            y(r, t.shape, 'All tensors passed to stack must have matching shapes')
          }),
          n.forEach(function (t) {
            A(o === t.dtype, function () {
              return 'All tensors passed to stack must have matching dtypes'
            })
          })
        n = n.map(function (t) {
          return t.expandDims(e)
        })
        return Cn(n, e)
      },
    }),
    dr = on({
      tile_: function (t, s) {
        var n = qe(t, 'x', 'tile', null)
        A(n.rank === s.length, function () {
          return 'Error in transpose: rank of input ' + n.rank + ' must match length of reps ' + s + '.'
        })
        var e = [n],
          t = { reps: s }
        return Pt.runKernelFunc(
          function (t, e) {
            t = t.tile(n, s)
            return e([n]), t
          },
          { x: n },
          function (i, t) {
            var a = t[0]
            return {
              x: function () {
                var t = wn(a)
                if (1 === a.rank) for (var e = 0; e < s[0]; ++e) t = t.add(i.slice([e * a.shape[0]], [a.shape[0]]))
                else if (2 === a.rank)
                  for (e = 0; e < s[0]; ++e)
                    for (var n = 0; n < s[1]; ++n)
                      t = t.add(i.slice([e * a.shape[0], n * a.shape[1]], [a.shape[0], a.shape[1]]))
                else if (3 === a.rank)
                  for (e = 0; e < s[0]; ++e)
                    for (n = 0; n < s[1]; ++n)
                      for (var r = 0; r < s[2]; ++r)
                        t = t.add(
                          i.slice([e * a.shape[0], n * a.shape[1], r * a.shape[2]], [a.shape[0], a.shape[1], a.shape[2]]),
                        )
                else {
                  if (4 !== a.rank)
                    throw new Error('Gradient for tile operation is not implemented for rank-' + a.rank + ' tensors yet.')
                  for (e = 0; e < s[0]; ++e)
                    for (n = 0; n < s[1]; ++n)
                      for (r = 0; r < s[2]; ++r)
                        for (var o = 0; o < s[3]; ++o)
                          t = t.add(
                            i.slice(
                              [e * a.shape[0], n * a.shape[1], r * a.shape[2], o * a.shape[3]],
                              [a.shape[0], a.shape[1], a.shape[2], a.shape[3]],
                            ),
                          )
                }
                return t
              },
            }
          },
          'Tile',
          t,
          e,
        )
      },
    }),
    fr = on({
      truncatedNormal_: function (t, e, n, r, o) {
        if ((void 0 === e && (e = 0), void 0 === n && (n = 1), null != r && 'bool' === r))
          throw new Error('Unsupported data type ' + r)
        for (var i = new Bn(e, n, r, !0, o), a = Vn(t, r), s = 0; s < a.values.length; s++) a.values[s] = i.nextValue()
        return a.toTensor()
      },
    }),
    vr = on({
      unstack_: function (t, e) {
        e = (e = void 0 === e ? 0 : e) || 0
        var n = qe(t, 'x', 'unstack')
        A(e >= -n.shape.length && e < n.shape.length, function () {
          return 'Axis = ' + e + ' is not in [-' + n.shape.length + ', ' + n.shape.length + ')'
        }),
          e < 0 && (e += n.shape.length)
        t = { axis: e }
        return Pt.runKernelFunc(
          function (t) {
            return t.unstack(n, e)
          },
          { x: n },
          function (t) {
            return {
              x: function () {
                return pr(t, e)
              },
            }
          },
          'Unpack',
          t,
        )
      },
    })
  function mr(t, e, n, r) {
    var o = []
    if ((r = void 0 === r ? !0 : r)) (o = o.concat(e.slice(0))).push(t[0] / n), (o = o.concat(t.slice(1)))
    else {
      for (var o = o.concat(t[0]), i = e.length, a = 0; a < i; ++a) o = o.concat([t[a + 1] / e[a], e[a]])
      o = o.concat(t.slice(i + 1))
    }
    return o
  }
  function gr(t, e, n) {
    var r = []
    if ((n = void 0 === n ? !0 : n)) {
      r.push(e)
      for (var o = e + 1; o < t; ++o) o <= 2 * e ? (r.push(o), r.push(o - (e + 1))) : r.push(o)
    } else {
      for (var i = [], a = [], o = 1; o < t; ++o) (2 * e + 1 <= o || o % 2 == 1 ? a : i).push(o)
      r.push.apply(r, i), r.push(0), r.push.apply(r, a)
    }
    return r
  }
  function yr(t, e, n, r) {
    var o = []
    ;(r = void 0 === r ? !0 : r) ? o.push(t[0] / n) : o.push(t[0] * n)
    for (var i = 1; i < t.length; ++i) i <= e.length ? (r ? o.push(e[i - 1] * t[i]) : o.push(t[i] / e[i - 1])) : o.push(t[i])
    return o
  }
  function br(t, e) {
    for (var n = [0], r = 0; r < e; ++r) n.push(t[r][0])
    return n
  }
  function xr(t, e, n) {
    for (var r = t.slice(0, 1), o = 0; o < n; ++o) r.push(t[o + 1] - e[o][0] - e[o][1])
    return r
  }
  function wr(t, e) {
    if (t.rank < 1) throw new Error('tf.gatherND() expects the input to be rank 1 or higher, but the rank was ' + t.rank + '.')
    if (e.rank < 1)
      throw new Error('tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ' + e.rank + '.')
    if ('int32' !== e.dtype)
      throw new Error('tf.gatherND() expects the indices to be int32 type, but the dtype was ' + e.dtype + '.')
    if (e.shape[e.rank - 1] > t.rank)
      throw new Error('index innermost dimension length must be <= tensor rank; saw: ' + e.shape[e.rank - 1] + ' vs. ' + t.rank)
    if (0 === t.size) throw new Error('Requested more than 0 entries, but input is empty. Input shape: ' + t.shape + '.')
    for (var n = e.shape, e = n[n.length - 1], r = 1, o = 0; o < n.length - 1; ++o) r *= n[o]
    var i = t.shape,
      a = n.slice()
    a.pop()
    for (var s = 1, o = e; o < t.rank; ++o) (s *= i[o]), a.push(i[o])
    e = $(t.shape)
      .map(function (t) {
        return t / s
      })
      .concat([1])
      .slice(0, e)
    return [a, r, s, e]
  }
  Object.freeze({ prepareAndValidate: wr })
  function Cr(t) {
    return t <= 30 ? t : X(t, Math.floor(Math.sqrt(t)))
  }
  function Er(t, e, n) {
    var r = 1 < e.rank ? e.shape[e.rank - 1] : 1,
      o = 1 < e.rank ? e.rank - 1 : 1,
      i =
        'Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ' +
        n.shape +
        ', indices.shape: ' +
        e.shape +
        ', shape: ' +
        t +
        ', sliceDim: ' +
        r +
        ', and batchDim: ' +
        o +
        '.'
    if (n.rank < o) throw new Error(i + ' update.rank < ' + o + '. ')
    if (t.length < r + (n.rank - o)) throw new Error(i + ' Output shape length < ' + (r + (n.rank - o)))
    if (n.rank !== o + t.length - r) throw new Error(i + ' update.rank != ' + (o + t.length - r))
    for (var a = 0; a < o; ++a)
      if (n.shape[a] !== e.shape[a])
        throw new Error(i + ' updates.shape[' + a + '] (' + n.shape[a] + ') != indices.shape[' + a + '] (' + e.shape[a] + ').')
    for (a = 0; a < n.rank - o; ++a)
      if (n.shape[a + o] !== t[a + r])
        throw new Error(
          i + ' updates.shape[' + (a + o) + '] (' + n.shape[a + o] + ') != shape[' + (a + o) + '] (' + t[a + o] + ')',
        )
  }
  function Sr(t, e, n) {
    if (e.rank < 1)
      throw new Error('tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ' + e.rank + '.')
    if (t.rank < 1)
      throw new Error('tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ' + t.rank + '.')
    if ('int32' !== e.dtype) throw new Error("The dtype of 'indices' should be int32, but got dtype: " + e.dtype)
    if (n.length < 1) throw new Error('Output rank must be greater or equal to 1, but got shape: ' + n)
    if (0 === n.length) {
      if (0 === e.size) throw new Error('Indices specified for empty output. indices shape: ' + e.shape)
      if (0 === t.size) throw new Error('Updates specified for empty output. updates shape: ' + t.shape)
    }
    Er(n, e, t)
  }
  function _r(t, e, n) {
    for (var r = e.shape.length, o = 1 < r ? e.shape[r - 1] : 1, i = n.length, a = 1, s = o; s < i; ++s) a *= n[s]
    r = o < 1 ? 1 : o
    return { sliceRank: o, numUpdates: D(e.shape) / r, sliceSize: a, strides: $(n.slice(0, o)).concat([1]), outputSize: D(n) }
  }
  function Rr(e, n, r) {
    A(e.rank === n.length, function () {
      return 'Error in slice' + e.rank + 'D: Length of begin ' + n + ' must match the rank of the array (' + e.rank + ').'
    }),
      A(e.rank === r.length, function () {
        return 'Error in slice' + e.rank + 'D: Length of size ' + r + ' must match the rank of the array (' + e.rank + ').'
      })
    for (var t = 0; t < e.rank; ++t)
      !(function (t) {
        A(n[t] + r[t] <= e.shape[t], function () {
          return (
            'Error in slice' +
            e.rank +
            'D: begin[' +
            t +
            '] + size[' +
            t +
            '] (' +
            (n[t] + r[t]) +
            ') would overflow input.shape[' +
            t +
            '] (' +
            e.shape[t] +
            ')'
          )
        })
      })(t)
  }
  function Ir(t) {
    for (var e = [], n = 0; 0 < t; ) 1 & t && e.push(n), (t /= 2), n++
    return e
  }
  function Ar(t, e, n) {
    for (var r = [], o = 0; o < t.length; o++) r[o] = Math.ceil((e[o] - t[o]) / n[o])
    return r
  }
  function Nr(t, e, n, r, o) {
    ;(e = e[o]), (n = n[o] || 1)
    ;(t & (1 << o) || null == e) && (e = 0 < n ? Number.MIN_SAFE_INTEGER : Number.MAX_SAFE_INTEGER)
    o = r[o]
    return e < 0 && (e += o), v(0, e, o - 1)
  }
  function kr(t, e, n, r, o) {
    ;(e = e[o]), (n = n[o] || 1)
    ;(t & (1 << o) || null == e) && (e = 0 < n ? Number.MAX_SAFE_INTEGER : Number.MIN_SAFE_INTEGER)
    o = r[o]
    return e < 0 && (e += o), 0 < n ? v(0, e, o) : v(-1, e, o - 1)
  }
  function Tr(t, e, n) {
    for (var r = n.length, o = 0; o < n.length; o++)
      if (1 < n[o]) {
        r = o
        break
      }
    for (o = r + 1; o < n.length; o++) if (0 < e[o] || n[o] !== t[o]) return !1
    return !0
  }
  function Dr(t, e) {
    for (var n = 0 < t.length ? t[t.length - 1] : 1, r = 0; r < t.length - 1; r++) n += t[r] * e[r]
    return n
  }
  function Or(t) {
    return Pt.customGrad(t)
  }
  Object.freeze({ validateUpdateShape: Er, validateInput: Sr, calculateShapes: _r }),
    Object.freeze({
      assertParamsValid: Rr,
      maskToAxes: Ir,
      computeOutShape: Ar,
      startForAxis: Nr,
      stopForAxis: kr,
      isSliceContinous: Tr,
      computeFlatOffset: Dr,
    })
  var Fr = on({
      softmax_: function (t, o) {
        void 0 === o && (o = -1)
        var n = qe(t, 'logits', 'softmax', 'float32')
        if ((o = -1 === o ? n.rank - 1 : o) !== n.rank - 1)
          throw Error(
            'Softmax along a non-last dimension is not yet supported. Logits was rank ' + n.rank + ' and dim was ' + o,
          )
        return Pt.runKernelFunc(
          function (t, e) {
            t = t.softmax(n, o)
            return e([t]), t
          },
          { logits: n },
          function (t, e) {
            var n = e[0],
              r = t.mul(n)
            return {
              logits: function () {
                return r.sub(r.sum([o], !0).mul(n))
              },
            }
          },
          'Softmax',
          { dim: o },
          [],
          [!0],
        )
      },
    }),
    Mr = on({
      logSoftmax_: function (t, r) {
        void 0 === r && (r = -1)
        t = qe(t, 'logits', 'logSoftmax')
        if ((r = -1 === r ? t.rank - 1 : r) !== t.rank - 1)
          throw Error(
            'Log Softmax along a non-last dimension is not yet supported. Logits was rank ' + t.rank + ' and axis was ' + r,
          )
        return Or(function (t, e) {
          var n = t.max(r, !0),
            n = t.sub(n),
            n = n.toFloat().sub(n.exp().sum(r, !0).log())
          return (
            e([n]),
            {
              value: n,
              gradFunc: function (t, e) {
                e = e[0].exp()
                return t.sub(t.sum(r, !0).mul(e))
              },
            }
          )
        })(t)
      },
    }),
    Pr =
      ((Wr.prototype.get = function (t) {
        return this.data.has(t) || this.dataMover.moveData(this.backend, t), this.data.get(t)
      }),
      (Wr.prototype.set = function (t, e) {
        this.dataIdsCount++, this.data.set(t, e)
      }),
      (Wr.prototype.has = function (t) {
        return this.data.has(t)
      }),
      (Wr.prototype.delete = function (t) {
        return this.dataIdsCount--, this.data.delete(t)
      }),
      (Wr.prototype.numDataIds = function () {
        return this.dataIdsCount
      }),
      Wr),
    Br =
      ((Lr.prototype.time = function (t) {
        return zr('time')
      }),
      (Lr.prototype.read = function (t) {
        return zr('read')
      }),
      (Lr.prototype.readSync = function (t) {
        return zr('readSync')
      }),
      (Lr.prototype.numDataIds = function () {
        return zr('numDataIds')
      }),
      (Lr.prototype.disposeData = function (t) {
        return zr('disposeData')
      }),
      (Lr.prototype.write = function (t, e, n) {
        return zr('write')
      }),
      (Lr.prototype.move = function (t, e, n, r) {
        return zr('move')
      }),
      (Lr.prototype.memory = function () {
        return zr('memory')
      }),
      (Lr.prototype.floatPrecision = function () {
        return zr('floatPrecision')
      }),
      (Lr.prototype.epsilon = function () {
        return 32 === this.floatPrecision() ? 1e-7 : 1e-4
      }),
      (Lr.prototype.batchMatMul = function (t, e, n, r) {
        return zr('batchMatMul')
      }),
      (Lr.prototype.fusedBatchMatMul = function (t) {
        return t.a, t.b, t.transposeA, t.transposeB, t.bias, t.activation, t.preluActivationWeights, zr('fusedBatchMatMul')
      }),
      (Lr.prototype.slice = function (t, e, n) {
        return zr('slice')
      }),
      (Lr.prototype.stridedSlice = function (t, e, n, r) {
        return zr('stridedSlice')
      }),
      (Lr.prototype.unstack = function (t, e) {
        return zr('unstack')
      }),
      (Lr.prototype.reverse = function (t, e) {
        return zr('reverse')
      }),
      (Lr.prototype.concat = function (t, e) {
        return zr('concat')
      }),
      (Lr.prototype.neg = function (t) {
        return zr('neg')
      }),
      (Lr.prototype.add = function (t, e) {
        return zr('add')
      }),
      (Lr.prototype.addN = function (t) {
        return zr('addN')
      }),
      (Lr.prototype.subtract = function (t, e) {
        return zr('subtract')
      }),
      (Lr.prototype.multiply = function (t, e) {
        return zr('multiply')
      }),
      (Lr.prototype.realDivide = function (t, e) {
        return zr('realDivide')
      }),
      (Lr.prototype.floorDiv = function (t, e) {
        return zr('floorDiv')
      }),
      (Lr.prototype.sum = function (t, e) {
        return zr('sum')
      }),
      (Lr.prototype.prod = function (t, e) {
        return zr('prod')
      }),
      (Lr.prototype.unsortedSegmentSum = function (t, e, n) {
        return zr('unsortedSegmentSum')
      }),
      (Lr.prototype.argMin = function (t, e) {
        return zr('argMin')
      }),
      (Lr.prototype.argMax = function (t, e) {
        return zr('argMax')
      }),
      (Lr.prototype.equal = function (t, e) {
        return zr('equal')
      }),
      (Lr.prototype.notEqual = function (t, e) {
        return zr('notEqual')
      }),
      (Lr.prototype.less = function (t, e) {
        return zr('less')
      }),
      (Lr.prototype.lessEqual = function (t, e) {
        return zr('lessEqual')
      }),
      (Lr.prototype.greater = function (t, e) {
        return zr('greater')
      }),
      (Lr.prototype.greaterEqual = function (t, e) {
        return zr('greaterEqual')
      }),
      (Lr.prototype.logicalNot = function (t) {
        return zr('logicalNot')
      }),
      (Lr.prototype.logicalAnd = function (t, e) {
        return zr('logicalAnd')
      }),
      (Lr.prototype.logicalOr = function (t, e) {
        return zr('logicalOr')
      }),
      (Lr.prototype.where = function (t) {
        return zr('where')
      }),
      (Lr.prototype.select = function (t, e, n) {
        return zr('select')
      }),
      (Lr.prototype.topk = function (t, e, n) {
        return zr('topk')
      }),
      (Lr.prototype.min = function (t, e) {
        return zr('min')
      }),
      (Lr.prototype.minimum = function (t, e) {
        return zr('minimum')
      }),
      (Lr.prototype.mod = function (t, e) {
        return zr('mod')
      }),
      (Lr.prototype.max = function (t, e) {
        return zr('max')
      }),
      (Lr.prototype.maximum = function (t, e) {
        return zr('maximum')
      }),
      (Lr.prototype.all = function (t, e) {
        return zr('all')
      }),
      (Lr.prototype.any = function (t, e) {
        return zr('any')
      }),
      (Lr.prototype.squaredDifference = function (t, e) {
        return zr('squaredDifference')
      }),
      (Lr.prototype.ceil = function (t) {
        return zr('ceil')
      }),
      (Lr.prototype.floor = function (t) {
        return zr('floor')
      }),
      (Lr.prototype.round = function (t) {
        return zr('round')
      }),
      (Lr.prototype.sign = function (t) {
        return zr('sign')
      }),
      (Lr.prototype.isNaN = function (t) {
        return zr('isNaN')
      }),
      (Lr.prototype.isInf = function (t) {
        return zr('isInf')
      }),
      (Lr.prototype.isFinite = function (t) {
        return zr('isFinite')
      }),
      (Lr.prototype.pow = function (t, e) {
        return zr('pow')
      }),
      (Lr.prototype.exp = function (t) {
        return zr('exp')
      }),
      (Lr.prototype.expm1 = function (t) {
        return zr('expm1')
      }),
      (Lr.prototype.softmax = function (t, e) {
        return zr('softmax')
      }),
      (Lr.prototype.log = function (t) {
        return zr('log')
      }),
      (Lr.prototype.log1p = function (t) {
        return zr('log1p')
      }),
      (Lr.prototype.sqrt = function (t) {
        return zr('sqrt')
      }),
      (Lr.prototype.rsqrt = function (t) {
        return zr('rsqrt')
      }),
      (Lr.prototype.square = function (t) {
        return zr('square')
      }),
      (Lr.prototype.reciprocal = function (t) {
        return zr('reciprocal')
      }),
      (Lr.prototype.relu = function (t) {
        return zr('relu')
      }),
      (Lr.prototype.relu6 = function (t) {
        return zr('relu6')
      }),
      (Lr.prototype.prelu = function (t, e) {
        return zr('prelu')
      }),
      (Lr.prototype.elu = function (t) {
        return zr('elu')
      }),
      (Lr.prototype.eluDer = function (t, e) {
        return zr('eluDer')
      }),
      (Lr.prototype.selu = function (t) {
        return zr('selu')
      }),
      (Lr.prototype.int = function (t) {
        return zr('int')
      }),
      (Lr.prototype.clip = function (t, e, n) {
        return zr('clip')
      }),
      (Lr.prototype.abs = function (t) {
        return zr('abs')
      }),
      (Lr.prototype.complexAbs = function (t) {
        return zr('complexAbs')
      }),
      (Lr.prototype.sigmoid = function (t) {
        return zr('sigmoid')
      }),
      (Lr.prototype.softplus = function (t) {
        return zr('softplus')
      }),
      (Lr.prototype.sin = function (t) {
        return zr('sin')
      }),
      (Lr.prototype.cos = function (t) {
        return zr('cos')
      }),
      (Lr.prototype.tan = function (t) {
        return zr('tan')
      }),
      (Lr.prototype.asin = function (t) {
        return zr('asin')
      }),
      (Lr.prototype.acos = function (t) {
        return zr('acos')
      }),
      (Lr.prototype.atan = function (t) {
        return zr('atan')
      }),
      (Lr.prototype.atan2 = function (t, e) {
        return zr('atan2')
      }),
      (Lr.prototype.sinh = function (t) {
        return zr('sinh')
      }),
      (Lr.prototype.cosh = function (t) {
        return zr('cosh')
      }),
      (Lr.prototype.tanh = function (t) {
        return zr('tanh')
      }),
      (Lr.prototype.asinh = function (t) {
        return zr('asinh')
      }),
      (Lr.prototype.acosh = function (t) {
        return zr('acosh')
      }),
      (Lr.prototype.atanh = function (t) {
        return zr('atanh')
      }),
      (Lr.prototype.erf = function (t) {
        return zr('erf')
      }),
      (Lr.prototype.step = function (t, e) {
        return zr('step')
      }),
      (Lr.prototype.fusedConv2d = function (t) {
        return t.input, t.filter, t.convInfo, t.bias, t.activation, t.preluActivationWeights, zr('fusedConv2d')
      }),
      (Lr.prototype.conv2d = function (t, e, n) {
        return zr('conv2d')
      }),
      (Lr.prototype.conv2dDerInput = function (t, e, n) {
        return zr('conv2dDerInput')
      }),
      (Lr.prototype.conv2dDerFilter = function (t, e, n) {
        return zr('conv2dDerFilter')
      }),
      (Lr.prototype.fusedDepthwiseConv2D = function (t) {
        return t.input, t.filter, t.convInfo, t.bias, t.activation, t.preluActivationWeights, zr('fusedDepthwiseConv2D')
      }),
      (Lr.prototype.depthwiseConv2D = function (t, e, n) {
        return zr('depthwiseConv2D')
      }),
      (Lr.prototype.depthwiseConv2DDerInput = function (t, e, n) {
        return zr('depthwiseConv2DDerInput')
      }),
      (Lr.prototype.depthwiseConv2DDerFilter = function (t, e, n) {
        return zr('depthwiseConv2DDerFilter')
      }),
      (Lr.prototype.conv3d = function (t, e, n) {
        return zr('conv3d')
      }),
      (Lr.prototype.conv3dDerInput = function (t, e, n) {
        return zr('conv3dDerInput')
      }),
      (Lr.prototype.conv3dDerFilter = function (t, e, n) {
        return zr('conv3dDerFilter')
      }),
      (Lr.prototype.maxPool = function (t, e) {
        return zr('maxPool')
      }),
      (Lr.prototype.maxPoolBackprop = function (t, e, n, r) {
        return zr('maxPoolBackprop')
      }),
      (Lr.prototype.avgPool = function (t, e) {
        return zr('avgPool')
      }),
      (Lr.prototype.avgPoolBackprop = function (t, e, n) {
        return zr('avgPoolBackprop')
      }),
      (Lr.prototype.avgPool3d = function (t, e) {
        return zr('avgPool3d')
      }),
      (Lr.prototype.avgPool3dBackprop = function (t, e, n) {
        return zr('avgPool3dBackprop')
      }),
      (Lr.prototype.maxPool3d = function (t, e) {
        return zr('maxPool3d')
      }),
      (Lr.prototype.maxPool3dBackprop = function (t, e, n, r) {
        return zr('maxPool3dBackprop')
      }),
      (Lr.prototype.reshape = function (t, e) {
        return zr('reshape')
      }),
      (Lr.prototype.cast = function (t, e) {
        return zr('cast')
      }),
      (Lr.prototype.tile = function (t, e) {
        return zr('tile')
      }),
      (Lr.prototype.pad = function (t, e, n) {
        return zr('pad')
      }),
      (Lr.prototype.transpose = function (t, e) {
        return zr('transpose')
      }),
      (Lr.prototype.gather = function (t, e, n) {
        return zr('gather')
      }),
      (Lr.prototype.gatherND = function (t, e) {
        return zr('gatherND')
      }),
      (Lr.prototype.scatterND = function (t, e, n) {
        return zr('scatterND')
      }),
      (Lr.prototype.batchToSpaceND = function (t, e, n) {
        return zr('batchToSpaceND')
      }),
      (Lr.prototype.spaceToBatchND = function (t, e, n) {
        return zr('spaceToBatchND')
      }),
      (Lr.prototype.resizeBilinear = function (t, e, n, r) {
        return zr('resizeBilinear')
      }),
      (Lr.prototype.resizeBilinearBackprop = function (t, e, n) {
        return zr('resizeBilinearBackprop')
      }),
      (Lr.prototype.resizeNearestNeighbor = function (t, e, n, r) {
        return zr('resizeNearestNeighbor')
      }),
      (Lr.prototype.resizeNearestNeighborBackprop = function (t, e, n) {
        return zr('resizeNearestNeighborBackprop')
      }),
      (Lr.prototype.batchNormalization = function (t, e, n, r, o, i) {
        return zr('batchNormalization')
      }),
      (Lr.prototype.localResponseNormalization4D = function (t, e, n, r, o) {
        return zr('localResponseNormalization4D')
      }),
      (Lr.prototype.LRNGrad = function (t, e, n, r, o, i, a) {
        return zr('LRNGrad')
      }),
      (Lr.prototype.multinomial = function (t, e, n, r) {
        return zr('multinomial')
      }),
      (Lr.prototype.oneHot = function (t, e, n, r) {
        return zr('oneHot')
      }),
      (Lr.prototype.cumsum = function (t, e, n, r) {
        return zr('cumsum')
      }),
      (Lr.prototype.nonMaxSuppression = function (t, e, n, r, o) {
        return zr('nonMaxSuppression')
      }),
      (Lr.prototype.fft = function (t) {
        return zr('fft')
      }),
      (Lr.prototype.ifft = function (t) {
        return zr('ifft')
      }),
      (Lr.prototype.complex = function (t, e) {
        return zr('complex')
      }),
      (Lr.prototype.real = function (t) {
        return zr('real')
      }),
      (Lr.prototype.imag = function (t) {
        return zr('imag')
      }),
      (Lr.prototype.cropAndResize = function (t, e, n, r, o, i) {
        return zr('cropAndResize')
      }),
      (Lr.prototype.depthToSpace = function (t, e, n) {
        return zr('depthToSpace')
      }),
      (Lr.prototype.split = function (t, e, n) {
        return zr('split')
      }),
      (Lr.prototype.sparseToDense = function (t, e, n, r) {
        return zr('sparseToDense')
      }),
      (Lr.prototype.diag = function (t) {
        return zr('diag')
      }),
      (Lr.prototype.fill = function (t, e, n) {
        return zr('fill')
      }),
      (Lr.prototype.onesLike = function (t) {
        return zr('onesLike')
      }),
      (Lr.prototype.zerosLike = function (t) {
        return zr('zerosLike')
      }),
      (Lr.prototype.linspace = function (t, e, n) {
        return zr('linspace')
      }),
      (Lr.prototype.dispose = function () {
        return zr('dispose')
      }),
      Lr)
  function Lr() {}
  function Wr(t, e) {
    ;(this.backend = t), (this.dataMover = e), (this.data = new WeakMap()), (this.dataIdsCount = 0)
  }
  function zr(t) {
    throw new Error("'" + t + "' not yet implemented or not found in the registry. Did you forget to import the kernel?")
  }
  function Gr(t, e) {
    for (var n = t.length, r = [], o = 0; o < n; o++) {
      var i = n - 1 - o,
        a = t[i] || 1
      1 < (e[e.length - 1 - o] || 1) && 1 === a && r.unshift(i)
    }
    return r
  }
  function Ur(t, e) {
    for (var n = [], r = 0; r < e.length; r++) {
      var o = t[t.length - r - 1],
        i = e.length - r - 1,
        a = e[i]
      ;(null == o || (1 === o && 1 < a)) && n.unshift(i)
    }
    return n
  }
  function Vr(t, e) {
    for (var n = [], r = Math.max(t.length, e.length), o = 0; o < r; o++) {
      var i = t[t.length - o - 1]
      null == i && (i = 1)
      var a = e[e.length - o - 1]
      if ((null == a && (a = 1), 1 === i)) n.unshift(a)
      else if (1 === a) n.unshift(i)
      else {
        if (i !== a) throw Error('Operands could not be broadcast together with shapes ' + t + ' and ' + e + '.')
        n.unshift(i)
      }
    }
    return n
  }
  function Hr(t, e, n, r, o, i, a) {
    void 0 === a && (a = 'channelsLast')
    var s,
      u = $r(e),
      e = u[0],
      u = u[1]
    if ('channelsLast' === a) s = [e, u, t[3], t[3]]
    else {
      if ('channelsFirst' !== a) throw new Error('Unknown dataFormat ' + a)
      s = [e, u, t[1], t[1]]
    }
    return qr(t, s, n, r, o, i, !1, a)
  }
  function jr(t, e, n, r, o, i, a) {
    void 0 === a && (a = 'NDHWC')
    var s,
      u,
      c = Yr(e),
      l = c[0],
      e = c[1],
      c = c[2]
    if ('NDHWC' === a) (u = 'channelsLast'), (s = [l, e, c, t[4], t[4]])
    else {
      if ('NCDHW' !== a) throw new Error('Unknown dataFormat ' + a)
      ;(u = 'channelsFirst'), (s = [l, e, c, t[1], t[1]])
    }
    return Kr(t, s, n, r, o, !1, u, i)
  }
  function qr(t, e, n, r, o, f, i, a) {
    void 0 === i && (i = !1)
    var s = [-1, -1, -1, -1],
      u = s[0],
      c = s[1],
      l = s[2],
      h = s[3]
    if ('channelsLast' === (a = void 0 === a ? 'channelsLast' : a)) (u = t[0]), (c = t[1]), (l = t[2]), (h = t[3])
    else {
      if ('channelsFirst' !== a) throw new Error('Unknown dataFormat ' + a)
      ;(u = t[0]), (h = t[1]), (c = t[2]), (l = t[3])
    }
    var p,
      d = e[0],
      v = e[1],
      m = e[3],
      g = $r(n),
      y = g[0],
      b = g[1],
      x = $r(r),
      w = x[0],
      s = x[1],
      n = Jr(d, w),
      g = Jr(v, s),
      r = (function (t, e, n, r, o, i, a) {
        if ('number' == typeof t)
          var s = { top: t, bottom: t, left: t, right: t, type: 0 === t ? 'VALID' : 'NUMBER' },
            u = (function (t, e, n, r, o) {
              null == r && (r = Xr(t, e, n))
              var i = t[1],
                a = Qr((t[0] - e + 2 * r) / n + 1, o)
              A(N(a), function () {
                return 'The output # of rows (' + a + ') must be an integer. Change the stride and/or zero pad parameters'
              })
              var s = Qr((i - e + 2 * r) / n + 1, o)
              return (
                A(N(s), function () {
                  return 'The output # of columns (' + s + ') must be an integer. Change the stride and/or zero pad parameters'
                }),
                [a, s]
              )
            })([e, n], i, r, t, f),
            c = u[0],
            l = u[1]
        else if ('same' === t) {
          ;(c = Math.ceil(e / r)), (l = Math.ceil(n / o))
          var h = Math.max(0, (c - 1) * r + i - e),
            p = Math.max(0, (l - 1) * o + a - n),
            d = Math.floor(h / 2),
            u = h - d,
            h = Math.floor(p / 2)
          s = { top: d, bottom: u, left: h, right: p - h, type: 'SAME' }
        } else {
          if ('valid' !== t) throw Error('Unknown padding parameter: ' + t)
          ;(s = { top: 0, bottom: 0, left: 0, right: 0, type: 'VALID' }),
            (c = Math.ceil((e - i + 1) / r)),
            (l = Math.ceil((n - a + 1) / o))
        }
        return { padInfo: s, outHeight: c, outWidth: l }
      })(o, c, l, y, b, n, g),
      x = r.padInfo,
      o = r.outHeight,
      r = r.outWidth,
      m = i ? m * h : m
    return (
      'channelsFirst' === a ? (p = [u, m, o, r]) : 'channelsLast' === a && (p = [u, o, r, m]),
      {
        batchSize: u,
        dataFormat: a,
        inHeight: c,
        inWidth: l,
        inChannels: h,
        outHeight: o,
        outWidth: r,
        outChannels: m,
        padInfo: x,
        strideHeight: y,
        strideWidth: b,
        filterHeight: d,
        filterWidth: v,
        effectiveFilterHeight: n,
        effectiveFilterWidth: g,
        dilationHeight: w,
        dilationWidth: s,
        inShape: t,
        outShape: p,
        filterShape: e,
      }
    )
  }
  function Kr(t, e, n, r, o, i, a, x) {
    void 0 === i && (i = !1)
    var s = [-1, -1, -1, -1, -1],
      u = s[0],
      c = s[1],
      l = s[2],
      h = s[3],
      p = s[4]
    if ('channelsLast' === (a = void 0 === a ? 'channelsLast' : a)) (u = t[0]), (c = t[1]), (l = t[2]), (h = t[3]), (p = t[4])
    else {
      if ('channelsFirst' !== a) throw new Error('Unknown dataFormat ' + a)
      ;(u = t[0]), (p = t[1]), (c = t[2]), (l = t[3]), (h = t[4])
    }
    var d,
      f = e[0],
      v = e[1],
      m = e[2],
      g = e[4],
      y = Yr(n),
      b = y[0],
      w = y[1],
      C = y[2],
      E = Yr(r),
      S = E[0],
      _ = E[1],
      R = E[2],
      I = Jr(f, S),
      s = Jr(v, _),
      n = Jr(m, R),
      y = (function (t, e, n, r, o, i, a, s, u, c) {
        if ('number' == typeof t)
          var l = { top: t, bottom: t, left: t, right: t, front: t, back: t, type: 0 === t ? 'VALID' : 'NUMBER' },
            h = (function (t, e, n, r, o) {
              null == r && (r = Xr(t, e, n))
              var i = t[1],
                a = t[2],
                s = Qr((t[0] - e + 2 * r) / n + 1, o)
              A(N(s), function () {
                return 'The output # of depths (' + s + ') must be an integer. Change the stride and/or zero pad parameters'
              })
              var u = Qr((i - e + 2 * r) / n + 1, o)
              A(N(u), function () {
                return 'The output # of rows (' + u + ') must be an integer. Change the stride and/or zero pad parameters'
              })
              var c = Qr((a - e + 2 * r) / n + 1, o)
              return (
                A(N(c), function () {
                  return 'The output # of columns (' + c + ') must be an integer. Change the stride and/or zero pad parameters'
                }),
                [s, u, c, 1]
              )
            })([e, n, r, 1], s, o, t, x),
            p = h[0],
            d = h[1],
            f = h[2]
        else if ('same' === t) {
          var v = ((p = Math.ceil(e / o)) - 1) * o + s - e,
            m = ((d = Math.ceil(n / i)) - 1) * i + u - n,
            g = ((f = Math.ceil(r / a)) - 1) * a + c - r,
            y = Math.floor(v / 2),
            b = v - y,
            h = Math.floor(m / 2),
            v = m - h,
            m = Math.floor(g / 2)
          l = { top: h, bottom: v, left: m, right: g - m, front: y, back: b, type: 'SAME' }
        } else {
          if ('valid' !== t) throw Error('Unknown padding parameter: ' + t)
          ;(l = { top: 0, bottom: 0, left: 0, right: 0, front: 0, back: 0, type: 'VALID' }),
            (p = Math.ceil((e - s + 1) / o)),
            (d = Math.ceil((n - u + 1) / i)),
            (f = Math.ceil((r - c + 1) / a))
        }
        return { padInfo: l, outDepth: p, outHeight: d, outWidth: f }
      })(o, c, l, h, b, w, C, I, s, n),
      r = y.padInfo,
      E = y.outDepth,
      o = y.outHeight,
      y = y.outWidth,
      g = i ? g * p : g
    return (
      'channelsFirst' === a ? (d = [u, g, E, o, y]) : 'channelsLast' === a && (d = [u, E, o, y, g]),
      {
        batchSize: u,
        dataFormat: a,
        inDepth: c,
        inHeight: l,
        inWidth: h,
        inChannels: p,
        outDepth: E,
        outHeight: o,
        outWidth: y,
        outChannels: g,
        padInfo: r,
        strideDepth: b,
        strideHeight: w,
        strideWidth: C,
        filterDepth: f,
        filterHeight: v,
        filterWidth: m,
        effectiveFilterDepth: I,
        effectiveFilterHeight: s,
        effectiveFilterWidth: n,
        dilationDepth: S,
        dilationHeight: _,
        dilationWidth: R,
        inShape: t,
        outShape: d,
        filterShape: e,
      }
    )
  }
  function Xr(t, e, n, r) {
    r = Jr(e, (r = void 0 === r ? 1 : r))
    return Math.floor((t[0] * (n - 1) - n + r) / 2)
  }
  function $r(t) {
    return 'number' == typeof t ? [t, t, t] : 2 === t.length ? [t[0], t[1], 1] : t
  }
  function Yr(t) {
    return 'number' == typeof t ? [t, t, t] : t
  }
  function Jr(t, e) {
    return e <= 1 ? t : t + (t - 1) * (e - 1)
  }
  function Qr(t, e) {
    if (!e) return t
    switch (e) {
      case 'round':
        return Math.round(t)
      case 'ceil':
        return Math.ceil(t)
      case 'floor':
        return Math.floor(t)
      default:
        throw new Error('Unknown roundingMode ' + e)
    }
  }
  function Zr(t) {
    var e = $r(t),
      n = e[0],
      t = e[1],
      e = e[2]
    return 1 === n && 1 === t && 1 === e
  }
  function to(t, e) {
    return Zr(t) || Zr(e)
  }
  function eo(t) {
    if ('NHWC' === t) return 'channelsLast'
    if ('NCHW' === t) return 'channelsFirst'
    throw new Error('Unknown dataFormat ' + t)
  }
  function no(t, e, n) {
    if ('complex64' === e) {
      if ('complex64' === t.dtype) return t.clone()
      var r = gn(t.shape),
        o = t.toFloat(),
        i = n.complex(o, r)
      return r.dispose(), o.dispose(), i
    }
    if (!W(t.dtype, e)) return Pt.makeTensorFromDataId(t.dataId, t.shape, e)
    if ('complex64' === t.dtype) {
      ;(o = n.real(t)), (i = o.cast(e))
      return o.dispose(), i
    }
    if ('int32' === e) return n.int(t)
    if ('bool' !== e) throw new Error('Error in Cast: failed to cast ' + t.dtype + ' to ' + e)
    e = hn(0, t.dtype)
    return (i = n.notEqual(t, e)), e.dispose(), i
  }
  function ro(t, e) {
    return Pt.makeTensorFromDataId(t.dataId, e, t.dtype)
  }
  function oo(t, e, n) {
    var r = (e - t) / (n - 1),
      o = Z(n, 'float32')
    o[0] = t
    for (var i = 1; i < o.length; i++) o[i] = o[i - 1] + r
    return pn(o, 'float32')
  }
  function io(t, e) {
    if (t.length !== e.length)
      throw new Error('Cannot merge real and imag arrays of different lengths. real:' + t.length + ', imag: ' + e.length + '.')
    for (var n = new Float32Array(2 * t.length), r = 0; r < n.length; r += 2) (n[r] = t[r / 2]), (n[r + 1] = e[r / 2])
    return n
  }
  function ao(t, e) {
    return { real: t[2 * e], imag: t[2 * e + 1] }
  }
  function so(t, e) {
    return e < t ? 1 : t < e ? -1 : 0
  }
  function uo(t, e, n, r, o) {
    return lo(t, e, n, r, o, 0).selectedIndices
  }
  function co(t, e, n, r, o, i) {
    i = lo(t, e, n, r, o, i)
    return i.numValidOutputs.dispose(), { selectedIndices: i.selectedIndices, selectedScores: i.selectedScores }
  }
  function lo(t, e, n, r, o, i, a, s) {
    void 0 === s && (s = !1)
    for (
      var u,
        c,
        l = Array.from(e)
          .map(function (t, e) {
            return { score: t, boxIndex: e, suppressBeginIndex: 0 }
          })
          .filter(function (t) {
            return t.score > o
          })
          .sort(ho),
        h = 0 < i ? -0.5 / i : 0,
        p = [],
        d = [];
      p.length < n && 0 < l.length;

    ) {
      var f = l.pop(),
        v = f.score,
        m = f.boxIndex,
        g = f.suppressBeginIndex
      if (v < o) break
      for (var y = !1, b = p.length - 1; g <= b; --b) {
        var x = (function (t, e, n) {
          var r = t.subarray(4 * e, 4 * e + 4),
            o = t.subarray(4 * n, 4 * n + 4),
            i = Math.min(r[0], r[2]),
            a = Math.min(r[1], r[3]),
            s = Math.max(r[0], r[2]),
            u = Math.max(r[1], r[3]),
            c = Math.min(o[0], o[2]),
            e = Math.min(o[1], o[3]),
            t = Math.max(o[0], o[2]),
            n = Math.max(o[1], o[3]),
            r = (s - i) * (u - a),
            o = (t - c) * (n - e)
          if (r <= 0 || o <= 0) return 0
          ;(c = Math.max(i, c)),
            (e = Math.max(a, e)),
            (t = Math.min(s, t)),
            (n = Math.min(u, n)),
            (e = Math.max(t - c, 0) * Math.max(n - e, 0))
          return e / (r + o - e)
        })(t, m, p[b])
        if (r <= x) {
          y = !0
          break
        }
        if (
          ((f.score =
            f.score *
            (function (t, e, n) {
              e = Math.exp(e * n * n)
              return n <= t ? e : 0
            })(r, h, x)),
          f.score <= o)
        )
          break
      }
      ;(f.suppressBeginIndex = p.length),
        y ||
          (f.score === v
            ? (p.push(m), d.push(f.score))
            : f.score > o &&
              ((v =
                (v = (function (t, e, n) {
                  for (var r, o = 0, i = t.length, a = !1; o < i; ) {
                    var s = n(e, t[(r = o + ((i - o) >>> 1))])
                    0 < s ? (o = r + 1) : ((i = r), (a = !s))
                  }
                  return a ? o : -o - 1
                })((u = l), (c = f), (v = ho) || so)) < 0
                  ? -(v + 1)
                  : v),
              u.splice(v, 0, c)))
    }
    i = p.length
    return (
      s && (p.fill(0, i), d.fill(0, i)),
      { selectedIndices: pn(p, 'int32'), selectedScores: pn(d, 'float32'), numValidOutputs: hn(i, 'int32') }
    )
  }
  function ho(t, e) {
    return t.score - e.score || (t.score === e.score && e.boxIndex - t.boxIndex)
  }
  function po(n, t, r) {
    var o = new Array(n.rank).fill(0),
      i = n.shape.slice()
    return t.map(function (t) {
      i[r] = t
      var e = n.slice(o, i)
      return (o[r] += t), e
    })
  }
  function fo(t, e) {
    for (var n = new Array(t.rank), r = 0; r < n.length; r++) n[r] = t.shape[r] * e[r]
    for (var o = Vn(n, t.dtype), r = 0; r < o.values.length; ++r) {
      for (var i = o.indexToLoc(r), a = new Array(t.rank), s = 0; s < a.length; s++) a[s] = i[s] % t.shape[s]
      var u = t.locToIndex(a)
      o.values[r] = t.values[u]
    }
    return o.toTensor()
  }
  function vo(t, e, n, r) {
    for (
      var o = e[e.length - 1], o = [t.length / o, o], i = o[0], a = o[1], s = M(n, i * r), u = M('int32', i * r), c = 0;
      c < i;
      c++
    ) {
      for (var l = c * a, h = t.subarray(l, l + a), p = [], d = 0; d < h.length; d++) p.push({ value: h[d], index: d })
      p.sort(function (t, e) {
        return e.value - t.value
      })
      for (var l = c * r, f = s.subarray(l, l + r), v = u.subarray(l, l + r), d = 0; d < r; d++)
        (f[d] = p[d].value), (v[d] = p[d].index)
    }
    e = e.slice()
    return (e[e.length - 1] = r), [cn(s, e, n), cn(u, e, 'int32')]
  }
  function mo(t, e) {
    for (var n = [], r = 0; r < e.length; r++) e[r] && n.push(r)
    for (var o = Vn(t, 'int32'), i = Vn([n.length, t.length], 'int32'), r = 0; r < n.length; r++) {
      var a = o.indexToLoc(n[r]),
        s = r * t.length
      i.values.set(a, s)
    }
    return i.toTensor()
  }
  Object.freeze({
    castTensor: no,
    reshapeTensor: ro,
    linspaceImpl: oo,
    upcastType: Rt,
    axesAreInnerMostDims: Xe,
    combineLocations: $e,
    computeOutAndReduceShapes: Ye,
    expandShapeToKeepDim: Je,
    assertAxesAreInnerMostDims: Qe,
    getAxesPermutation: Ze,
    getUndoAxesPermutation: tn,
    getInnerMostAxes: en,
    getBroadcastDims: Gr,
    getReductionAxes: Ur,
    assertAndGetBroadcastShape: Vr,
    assertParamsConsistent: nn,
    computeOutShape: rn,
    computePool2DInfo: Hr,
    computePool3DInfo: jr,
    computeConv2DInfo: qr,
    computeConv3DInfo: Kr,
    computeDefaultPad: Xr,
    tupleValuesAreOne: Zr,
    eitherStridesOrDilationsAreOne: to,
    convertConv2DDataFormat: eo,
    PARALLELIZE_THRESHOLD: 30,
    computeOptimalWindowSize: Cr,
  })
  function go(t, e) {
    ;(this.outputShape = []),
      (this.outputShape = t),
      (this.variableNames = e.map(function (t, e) {
        return 'T' + e
      }))
    var n = []
    this.variableNames.forEach(function (t) {
      n.push('float v' + t + ' = get' + t + 'AtOutCoords();')
    }),
      (e = this.variableNames
        .map(function (t) {
          return 'v' + t
        })
        .join(' + ')),
      (this.userCode =
        '\n      void main() {\n        ' +
        n.join('\n        ') +
        '\n\n        float result = ' +
        e +
        ';\n        setOutput(result);\n      }\n    ')
  }
  function yo(t, e) {
    ;(this.outputShape = []),
      (this.packedInputs = !0),
      (this.packedOutput = !0),
      (this.outputShape = t),
      (this.variableNames = e.map(function (t, e) {
        return 'T' + e
      }))
    var n = []
    this.variableNames.forEach(function (t) {
      n.push('vec4 v' + t + ' = get' + t + 'AtOutCoords();')
    }),
      (e = this.variableNames
        .map(function (t) {
          return 'v' + t
        })
        .join(' + ')),
      (this.userCode =
        '\n      void main() {\n        ' +
        n.join('\n        ') +
        '\n\n        vec4 result = ' +
        e +
        ';\n        setOutput(result);\n      }\n    ')
  }
  function bo(t, e, n) {
    this.variableNames = ['A']
    var r = t.windowSize,
      o = t.batchSize,
      t = t.inSize,
      t = Math.ceil(t / r)
    n || this.variableNames.push('bestIndicesA'),
      (this.outputShape = [o, t]),
      (e = 'max' === e ? '>' : '<'),
      (n = n ? 'inOffset + i;' : 'round(getBestIndicesA(batch, inOffset + i));'),
      (this.userCode =
        '\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ' +
        r +
        ';\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ' +
        r +
        '; i++) {\n          int inIdx = ' +
        n +
        ';\n          float candidate = getA(batch, inIdx);\n          if (candidate ' +
        e +
        ' bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    ')
  }
  function xo(e, t) {
    return ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, t).map(function (t) {
      return e + '.' + t
    })
  }
  function wo(t, e) {
    return 1 === e ? [t] : xo(t, e)
  }
  function Co() {
    var t,
      e,
      n,
      r,
      o,
      i,
      a,
      s,
      u,
      c =
        2 === f.getNumber('WEBGL_VERSION')
          ? ((t = '#version 300 es'),
            (n = 'out'),
            (r = e = 'in'),
            (o = 'texture'),
            (i = 'outputColor'),
            (a = 'out vec4 outputColor;'),
            (s =
              '\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    '),
            (u = ''),
            '\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    ')
          : ((e = 'attribute'),
            (r = n = 'varying'),
            (o = 'texture2D'),
            (i = 'gl_FragColor'),
            (a = t = ''),
            (s =
              '\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    '),
            (u =
              '\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    '),
            '\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    ')
    return {
      version: t,
      attribute: e,
      varyingVs: n,
      varyingFs: r,
      texture2D: o,
      output: i,
      defineOutput: a,
      defineSpecialNaN: s,
      defineSpecialInf: u,
      defineRound: c,
    }
  }
  function Eo(n, t, r) {
    void 0 === r && (r = 'index')
    var o = $(t)
    return o
      .map(function (t, e) {
        return (
          'int ' +
          n[e] +
          ' = ' +
          r +
          ' / ' +
          t +
          '; ' +
          (e === o.length - 1 ? 'int ' + n[e + 1] + ' = ' + r + ' - ' + n[e] + ' * ' + t : 'index -= ' + n[e] + ' * ' + t) +
          ';'
        )
      })
      .join('')
  }
  function So(t) {
    t = $(t).map(function (t) {
      return t.toString()
    })
    return (
      '\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ' + t[0] + ' + coords.y * ' + t[1] + ' + coords.z;\n  }\n'
    )
  }
  var _o =
    '\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n'
  function Ro(t, e, n, r) {
    var o = []
    t.forEach(function (t) {
      var e = D(t.shapeInfo.logicalShape)
      t.shapeInfo.isUniform
        ? o.push('uniform float ' + t.name + (1 < e ? '[' + e + ']' : '') + ';')
        : (o.push('uniform sampler2D ' + t.name + ';'), o.push('uniform int offset' + t.name + ';'))
    })
    var i,
      a = o.join('\n'),
      s = t
        .map(function (t) {
          return (function (t, e, n) {
            var r = ''
            r += (
              (n = void 0 === n ? !1 : n)
                ? function s(t) {
                    var e, n, r
                    switch (t.shapeInfo.logicalShape.length) {
                      case 0:
                        return (
                          (e = t.name),
                          (n = 'get' + e.charAt(0).toUpperCase() + e.slice(1)),
                          (r = Co()),
                          '\n    vec4 ' + n + '() {\n      return ' + r.texture2D + '(' + e + ', halfCR);\n    }\n  '
                        )
                      case 1:
                        return (function (t) {
                          var e = t.name,
                            n = 'get' + e.charAt(0).toUpperCase() + e.slice(1),
                            r = t.shapeInfo.texShape,
                            t = [Math.ceil(r[0] / 2), Math.ceil(r[1] / 2)],
                            r = Co()
                          return (
                            '\n    vec4 ' +
                            n +
                            '(int index) {\n      vec2 uv = packedUVfrom1D(\n        ' +
                            t[0] +
                            ', ' +
                            t[1] +
                            ', index);\n      return ' +
                            r.texture2D +
                            '(' +
                            e +
                            ', uv);\n    }\n  '
                          )
                        })(t)
                      case 2:
                        return (function (t) {
                          var e = t.shapeInfo.logicalShape,
                            n = t.name,
                            r = 'get' + n.charAt(0).toUpperCase() + n.slice(1),
                            o = t.shapeInfo.texShape,
                            i = o[0],
                            a = o[1],
                            t = Co()
                          if (null != o && S(e, o))
                            return (
                              '\n      vec4 ' +
                              r +
                              '(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(' +
                              a +
                              '.0, ' +
                              i +
                              '.0);\n\n        return ' +
                              t.texture2D +
                              '(' +
                              n +
                              ', uv);\n      }\n    '
                            )
                          var o = [Math.ceil(o[0] / 2), Math.ceil(o[1] / 2)],
                            e = Math.ceil(e[1] / 2)
                          return (
                            '\n    vec4 ' +
                            r +
                            '(int row, int col) {\n      vec2 uv = packedUVfrom2D(' +
                            e +
                            ', ' +
                            o[0] +
                            ', ' +
                            o[1] +
                            ', row, col);\n      return ' +
                            t.texture2D +
                            '(' +
                            n +
                            ', uv);\n    }\n  '
                          )
                        })(t)
                      case 3:
                        return (function (t) {
                          var e = t.shapeInfo.logicalShape,
                            n = t.name,
                            r = 'get' + n.charAt(0).toUpperCase() + n.slice(1),
                            o = t.shapeInfo.texShape,
                            o = [Math.ceil(o[0] / 2), Math.ceil(o[1] / 2)]
                          if (1 === e[0]) {
                            var i = e.slice(1),
                              a = ko(t, i)
                            return (
                              '\n        ' +
                              s(a) +
                              '\n        vec4 ' +
                              r +
                              '(int b, int row, int col) {\n          return ' +
                              r +
                              '(' +
                              To(['b', 'row', 'col'], [1, 2]) +
                              ');\n        }\n      '
                            )
                          }
                          var t = o[0],
                            i = o[1],
                            a = Math.ceil(e[2] / 2),
                            o = a * Math.ceil(e[1] / 2),
                            e = Co()
                          return (
                            '\n    vec4 ' +
                            r +
                            '(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ' +
                            t +
                            ', ' +
                            i +
                            ', ' +
                            o +
                            ', ' +
                            a +
                            ', b, row, col);\n      return ' +
                            e.texture2D +
                            '(' +
                            n +
                            ', uv);\n    }\n  '
                          )
                        })(t)
                      default:
                        return (function (t) {
                          for (
                            var e = t.shapeInfo.logicalShape,
                              n = e.length,
                              r = t.name,
                              o = 'get' + r.charAt(0).toUpperCase() + r.slice(1),
                              i = t.shapeInfo.texShape,
                              a = [Math.ceil(i[0] / 2), Math.ceil(i[1] / 2)],
                              t = a[0],
                              i = a[1],
                              a = Math.ceil(e[n - 1] / 2),
                              s = a * Math.ceil(e[n - 2] / 2),
                              u = 'int b, int row, int col',
                              c = 'b * ' + s + ' + (row / 2) * ' + a + ' + (col / 2)',
                              l = 2;
                            l < n - 1;
                            l++
                          )
                            (u = 'int b' + l + ', ' + u), (s *= e[n - l - 1]), (c = 'b' + l + ' * ' + s + ' + ' + c)
                          var a = Co()
                          return (
                            '\n    vec4 ' +
                            o +
                            '(' +
                            u +
                            ') {\n      int index = ' +
                            c +
                            ';\n      int texR = index / ' +
                            i +
                            ';\n      int texC = index - texR * ' +
                            i +
                            ';\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(' +
                            i +
                            ', ' +
                            t +
                            ');\n      return ' +
                            a.texture2D +
                            '(' +
                            r +
                            ', uv);\n    }\n  '
                          )
                        })(t)
                    }
                  }
                : function h(t) {
                    var e = t.shapeInfo.logicalShape
                    switch (e.length) {
                      case 0:
                        return (function (t) {
                          var e = t.name,
                            n = 'get' + e.charAt(0).toUpperCase() + e.slice(1)
                          if (t.shapeInfo.isUniform) return 'float ' + n + '() {return ' + e + ';}'
                          var r = t.shapeInfo.texShape,
                            o = r[0],
                            r = r[1]
                          if (1 === o && 1 === r)
                            return (
                              '\n      float ' + n + '() {\n        return sampleTexture(' + e + ', halfCR);\n      }\n    '
                            )
                          var o = t.shapeInfo.texShape,
                            r = o[0],
                            t = o[1],
                            o = Io(e)
                          return (
                            '\n    float ' +
                            n +
                            '() {\n      vec2 uv = uvFromFlat(' +
                            r +
                            ', ' +
                            t +
                            ', ' +
                            o +
                            ');\n      return sampleTexture(' +
                            e +
                            ', uv);\n    }\n  '
                          )
                        })(t)
                      case 1:
                        return (function (t) {
                          var e = t.name,
                            n = 'get' + e.charAt(0).toUpperCase() + e.slice(1)
                          if (t.shapeInfo.isUniform)
                            return '\n      float ' + n + '(int index) {\n        ' + Ao(t) + '\n      }\n    '
                          var r = t.shapeInfo.texShape,
                            o = r[0],
                            t = r[1]
                          if (1 === t && 1 === o)
                            return (
                              '\n      float ' +
                              n +
                              '(int index) {\n        return sampleTexture(' +
                              e +
                              ', halfCR);\n      }\n    '
                            )
                          var r = Io(e)
                          return 1 === t
                            ? '\n      float ' +
                                n +
                                '(int index) {\n        vec2 uv = vec2(0.5, (float(index + ' +
                                r +
                                ') + 0.5) / ' +
                                o +
                                '.0);\n        return sampleTexture(' +
                                e +
                                ', uv);\n      }\n    '
                            : 1 === o
                            ? '\n      float ' +
                              n +
                              '(int index) {\n        vec2 uv = vec2((float(index + ' +
                              r +
                              ') + 0.5) / ' +
                              t +
                              '.0, 0.5);\n        return sampleTexture(' +
                              e +
                              ', uv);\n      }\n    '
                            : '\n    float ' +
                              n +
                              '(int index) {\n      vec2 uv = uvFromFlat(' +
                              o +
                              ', ' +
                              t +
                              ', index + ' +
                              r +
                              ');\n      return sampleTexture(' +
                              e +
                              ', uv);\n    }\n  '
                        })(t)
                      case 2:
                        return (function (t) {
                          var e = t.shapeInfo.logicalShape,
                            n = t.name,
                            r = 'get' + n.charAt(0).toUpperCase() + n.slice(1),
                            o = t.shapeInfo.texShape
                          if (null != o && S(e, o)) {
                            var i = o[0],
                              a = o[1]
                            return (
                              '\n    float ' +
                              r +
                              '(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(' +
                              a +
                              '.0, ' +
                              i +
                              '.0);\n      return sampleTexture(' +
                              n +
                              ', uv);\n    }\n  '
                            )
                          }
                          ;(a = F(e)), (i = a.newShape), (a = a.keptDims)
                          if (i.length < e.length) {
                            var i = ko(t, i)
                            return (
                              '\n      ' +
                              h(i) +
                              '\n      float ' +
                              r +
                              '(int row, int col) {\n        return ' +
                              r +
                              '(' +
                              To(['row', 'col'], a) +
                              ');\n      }\n    '
                            )
                          }
                          if (t.shapeInfo.isUniform)
                            return (
                              '\n      float ' +
                              r +
                              '(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(' +
                              e[1] +
                              ', 1)));\n        ' +
                              Ao(t) +
                              '\n      }\n    '
                            )
                          var a = o[0],
                            t = o[1],
                            o = Io(n)
                          return 1 === t
                            ? '\n    float ' +
                                r +
                                '(int row, int col) {\n      float index = dot(vec3(row, col, ' +
                                o +
                                '), vec3(' +
                                e[1] +
                                ', 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ' +
                                a +
                                '.0);\n      return sampleTexture(' +
                                n +
                                ', uv);\n    }\n  '
                            : 1 === a
                            ? '\n    float ' +
                              r +
                              '(int row, int col) {\n      float index = dot(vec3(row, col, ' +
                              o +
                              '), vec3(' +
                              e[1] +
                              ', 1, 1));\n      vec2 uv = vec2((index + 0.5) / ' +
                              t +
                              '.0, 0.5);\n      return sampleTexture(' +
                              n +
                              ', uv);\n    }\n  '
                            : '\n  float ' +
                              r +
                              '(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ' +
                              e[1] +
                              ' + col + ' +
                              o +
                              ';\n    vec2 uv = uvFromFlat(' +
                              a +
                              ', ' +
                              t +
                              ', index);\n    return sampleTexture(' +
                              n +
                              ', uv);\n  }\n'
                        })(t)
                      case 3:
                        return (function (t) {
                          var e = t.shapeInfo.logicalShape,
                            n = t.name,
                            r = 'get' + n.charAt(0).toUpperCase() + n.slice(1),
                            o = e[1] * e[2],
                            i = e[2],
                            a = F(e),
                            s = a.newShape,
                            a = a.keptDims,
                            s = s
                          if (s.length < e.length) {
                            var u = ko(t, s)
                            return (
                              '\n        ' +
                              h(u) +
                              '\n        float ' +
                              r +
                              '(int row, int col, int depth) {\n          return ' +
                              r +
                              '(' +
                              To(['row', 'col', 'depth'], a) +
                              ');\n        }\n      '
                            )
                          }
                          if (t.shapeInfo.isUniform)
                            return (
                              '\n      float ' +
                              r +
                              '(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(' +
                              o +
                              ', ' +
                              i +
                              ', 1)));\n        ' +
                              Ao(t) +
                              '\n      }\n    '
                            )
                          var u = t.shapeInfo.texShape,
                            a = u[0],
                            u = u[1],
                            t = t.shapeInfo.flatOffset
                          if (u === o && null == t)
                            return (
                              '\n        float ' +
                              r +
                              '(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(' +
                              i +
                              ', 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(' +
                              u +
                              '.0, ' +
                              a +
                              '.0);\n          return sampleTexture(' +
                              n +
                              ', uv);\n        }\n      '
                            )
                          if (u === i && null == t)
                            return (
                              '\n    float ' +
                              r +
                              '(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(' +
                              e[1] +
                              ', 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(' +
                              u +
                              '.0, ' +
                              a +
                              '.0);\n      return sampleTexture(' +
                              n +
                              ', uv);\n    }\n  '
                            )
                          var e = Io(n)
                          return (
                            '\n      float ' +
                            r +
                            '(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ' +
                            o +
                            ' + col * ' +
                            i +
                            ' + depth + ' +
                            e +
                            ';\n        vec2 uv = uvFromFlat(' +
                            a +
                            ', ' +
                            u +
                            ', index);\n        return sampleTexture(' +
                            n +
                            ', uv);\n      }\n  '
                          )
                        })(t)
                      case 4:
                        return (function (t) {
                          var e = t.shapeInfo.logicalShape,
                            n = t.name,
                            r = 'get' + n.charAt(0).toUpperCase() + n.slice(1),
                            o = e[3],
                            i = e[2] * o,
                            a = e[1] * i,
                            s = F(e),
                            u = s.newShape,
                            s = s.keptDims
                          if (u.length < e.length) {
                            var c = ko(t, u)
                            return (
                              '\n      ' +
                              h(c) +
                              '\n      float ' +
                              r +
                              '(int row, int col, int depth, int depth2) {\n        return ' +
                              r +
                              '(' +
                              To(['row', 'col', 'depth', 'depth2'], s) +
                              ');\n      }\n    '
                            )
                          }
                          if (t.shapeInfo.isUniform)
                            return (
                              '\n      float ' +
                              r +
                              '(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(' +
                              a +
                              ', ' +
                              i +
                              ', ' +
                              o +
                              ', 1)));\n        ' +
                              Ao(t) +
                              '\n      }\n    '
                            )
                          var c = t.shapeInfo.flatOffset,
                            s = t.shapeInfo.texShape,
                            t = s[0],
                            s = s[1]
                          if (s === a && null == c)
                            return (
                              '\n      float ' +
                              r +
                              '(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(' +
                              i +
                              ', ' +
                              o +
                              ', 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(' +
                              s +
                              '.0, ' +
                              t +
                              '.0);\n        return sampleTexture(' +
                              n +
                              ', uv);\n      }\n    '
                            )
                          if (s === o && null == c)
                            return (
                              '\n      float ' +
                              r +
                              '(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(' +
                              e[1] * e[2] +
                              ', ' +
                              e[2] +
                              ', 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(' +
                              s +
                              '.0, ' +
                              t +
                              '.0);\n        return sampleTexture(' +
                              n +
                              ', uv);\n      }\n    '
                            )
                          var e = Io(n)
                          return (
                            '\n    float ' +
                            r +
                            '(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ' +
                            a +
                            ' + col * ' +
                            i +
                            ' +\n          depth * ' +
                            o +
                            ' + depth2;\n      vec2 uv = uvFromFlat(' +
                            t +
                            ', ' +
                            s +
                            ', index + ' +
                            e +
                            ');\n      return sampleTexture(' +
                            n +
                            ', uv);\n    }\n  '
                          )
                        })(t)
                      case 5:
                        return (function (t) {
                          var e = t.shapeInfo.logicalShape,
                            n = t.name,
                            r = 'get' + n.charAt(0).toUpperCase() + n.slice(1),
                            o = e[4],
                            i = e[3] * o,
                            a = e[2] * i,
                            s = e[1] * a,
                            u = F(e),
                            c = u.newShape,
                            u = u.keptDims
                          if (c.length < e.length) {
                            var l = ko(t, c)
                            return (
                              '\n      ' +
                              h(l) +
                              '\n      float ' +
                              r +
                              '(int row, int col, int depth, int depth2, int depth3) {\n        return ' +
                              r +
                              '(' +
                              To(['row', 'col', 'depth', 'depth2', 'depth3'], u) +
                              ');\n      }\n    '
                            )
                          }
                          if (t.shapeInfo.isUniform)
                            return (
                              '\n      float ' +
                              r +
                              '(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(' +
                              s +
                              ', ' +
                              a +
                              ', ' +
                              i +
                              ', ' +
                              o +
                              ')) +\n          depth3;\n        ' +
                              Ao(t) +
                              '\n      }\n    '
                            )
                          var l = t.shapeInfo.flatOffset,
                            u = t.shapeInfo.texShape,
                            t = u[0],
                            u = u[1]
                          if (u === s && null == l)
                            return (
                              '\n      float ' +
                              r +
                              '(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(' +
                              a +
                              ', ' +
                              i +
                              ', ' +
                              o +
                              ', 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(' +
                              u +
                              '.0, ' +
                              t +
                              '.0);\n        return sampleTexture(' +
                              n +
                              ', uv);\n      }\n    '
                            )
                          if (u === o && null == l)
                            return (
                              '\n      float ' +
                              r +
                              '(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(' +
                              e[1] * e[2] * e[3] +
                              ',\n               ' +
                              e[2] * e[3] +
                              ', ' +
                              e[3] +
                              ', 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(' +
                              u +
                              '.0, ' +
                              t +
                              '.0);\n        return sampleTexture(' +
                              n +
                              ', uv);\n      }\n    '
                            )
                          var e = Io(n)
                          return (
                            '\n    float ' +
                            r +
                            '(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ' +
                            s +
                            ' + col * ' +
                            a +
                            ' + depth * ' +
                            i +
                            ' +\n          depth2 * ' +
                            o +
                            ' + depth3 + ' +
                            e +
                            ';\n      vec2 uv = uvFromFlat(' +
                            t +
                            ', ' +
                            u +
                            ', index);\n      return sampleTexture(' +
                            n +
                            ', uv);\n    }\n  '
                          )
                        })(t)
                      case 6:
                        return (function (t) {
                          var e = t.shapeInfo.logicalShape,
                            n = t.name,
                            r = 'get' + n.charAt(0).toUpperCase() + n.slice(1),
                            o = F(e),
                            i = o.newShape,
                            a = o.keptDims
                          if (i.length < e.length) {
                            var s = ko(t, i)
                            return (
                              '\n      ' +
                              h(s) +
                              '\n      float ' +
                              r +
                              '(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ' +
                              r +
                              '(' +
                              To(['row', 'col', 'depth', 'depth2', 'depth3', 'depth4'], a) +
                              ');\n      }\n    '
                            )
                          }
                          var u = e[5],
                            c = e[4] * u,
                            l = e[3] * c,
                            o = e[2] * l,
                            i = e[1] * o
                          if (t.shapeInfo.isUniform)
                            return (
                              '\n      float ' +
                              r +
                              '(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(' +
                              i +
                              ', ' +
                              o +
                              ', ' +
                              l +
                              ', ' +
                              c +
                              ')) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(' +
                              u +
                              ', 1)));\n        ' +
                              Ao(t) +
                              '\n      }\n    '
                            )
                          var s = t.shapeInfo.flatOffset,
                            a = t.shapeInfo.texShape,
                            t = a[0],
                            a = a[1]
                          if (a === i && null == s)
                            return (
                              '\n      float ' +
                              r +
                              '(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(' +
                              o +
                              ', ' +
                              l +
                              ', ' +
                              c +
                              ', ' +
                              u +
                              ')) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(' +
                              a +
                              '.0, ' +
                              t +
                              '.0);\n        return sampleTexture(' +
                              n +
                              ', uv);\n      }\n    '
                            )
                          if (a === u && null == s)
                            return (
                              '\n      float ' +
                              r +
                              '(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(' +
                              e[1] * e[2] * e[3] * e[4] +
                              ',\n               ' +
                              e[2] * e[3] * e[4] +
                              ',\n               ' +
                              e[3] * e[4] +
                              ',\n               ' +
                              e[4] +
                              ')) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(' +
                              a +
                              '.0, ' +
                              t +
                              '.0);\n        return sampleTexture(' +
                              n +
                              ', uv);\n      }\n    '
                            )
                          var e = Io(n)
                          return (
                            '\n    float ' +
                            r +
                            '(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ' +
                            i +
                            ' + col * ' +
                            o +
                            ' + depth * ' +
                            l +
                            ' +\n          depth2 * ' +
                            c +
                            ' + depth3 * ' +
                            u +
                            ' + depth4 + ' +
                            e +
                            ';\n      vec2 uv = uvFromFlat(' +
                            t +
                            ', ' +
                            a +
                            ', index);\n      return sampleTexture(' +
                            n +
                            ', uv);\n    }\n  '
                          )
                        })(t)
                      default:
                        throw new Error(e.length + '-D input sampling is not yet supported')
                    }
                  }
            )(t)
            var o,
              i,
              a,
              s,
              u,
              c,
              l,
              h,
              p,
              d,
              f = t.shapeInfo.logicalShape,
              v = e.logicalShape
            return (
              f.length <= v.length &&
                (r += n
                  ? ((i = e),
                    (a = (o = t).name),
                    (s = a.charAt(0).toUpperCase() + a.slice(1)),
                    (u = 'get' + s + 'AtOutCoords'),
                    (c = o.shapeInfo.logicalShape.length),
                    (l = i.logicalShape.length),
                    (h = Gr(o.shapeInfo.logicalShape, i.logicalShape)),
                    (f = No(l)),
                    (p = l - c),
                    (d = ['x', 'y', 'z', 'w', 'u', 'v']),
                    (v =
                      0 === c
                        ? ''
                        : l < 2 && 1 <= h.length
                        ? 'coords = 0;'
                        : h
                            .map(function (t) {
                              return 'coords.' + d[t + p] + ' = 0;'
                            })
                            .join('\n')),
                    (n =
                      l < 2 && 0 < c
                        ? 'coords'
                        : o.shapeInfo.logicalShape
                            .map(function (t, e) {
                              return 'coords.' + d[e + p]
                            })
                            .join(', ')),
                    (a = 'return outputValue;'),
                    (o = 1 === D(o.shapeInfo.logicalShape)),
                    (i = 1 === D(i.logicalShape)),
                    1 !== c || o || i
                      ? o && !i
                        ? (a =
                            1 === l
                              ? '\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      '
                              : '\n        return vec4(outputValue.x);\n      ')
                        : h.length &&
                          ((l = c - 2),
                          (c = c - 1),
                          -1 < h.indexOf(l) && -1 < h.indexOf(c)
                            ? (a = 'return vec4(outputValue.x);')
                            : -1 < h.indexOf(l)
                            ? (a = 'return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);')
                            : -1 < h.indexOf(c) && (a = 'return vec4(outputValue.xx, outputValue.zz);'))
                      : (a = '\n      return vec4(outputValue.xy, outputValue.xy);\n    '),
                    '\n    vec4 ' +
                      u +
                      '() {\n      ' +
                      f +
                      ' coords = getOutputCoords();\n      ' +
                      v +
                      '\n      vec4 outputValue = get' +
                      s +
                      '(' +
                      n +
                      ');\n      ' +
                      a +
                      '\n    }\n  ')
                  : (function (t, e) {
                      var n = t.name,
                        r = n.charAt(0).toUpperCase() + n.slice(1),
                        o = 'get' + r + 'AtOutCoords',
                        i = e.texShape,
                        a = t.shapeInfo.texShape,
                        s = t.shapeInfo.logicalShape.length,
                        u = e.logicalShape.length
                      if (!t.shapeInfo.isUniform && s === u && null == t.shapeInfo.flatOffset && S(a, i))
                        return '\n      float ' + o + '() {\n        return sampleTexture(' + n + ', resultUV);\n      }\n    '
                      var n = No(u),
                        e = Gr(t.shapeInfo.logicalShape, e.logicalShape),
                        c = u - s,
                        l = ['x', 'y', 'z', 'w', 'u', 'v']
                      return (
                        '\n    float ' +
                        o +
                        '() {\n      ' +
                        n +
                        ' coords = getOutputCoords();\n      ' +
                        (0 === s
                          ? ''
                          : u < 2 && 1 <= e.length
                          ? 'coords = 0;'
                          : e
                              .map(function (t) {
                                return 'coords.' + l[t + c] + ' = 0;'
                              })
                              .join('\n')) +
                        '\n      return get' +
                        r +
                        '(' +
                        (u < 2 && 0 < s
                          ? 'coords'
                          : t.shapeInfo.logicalShape
                              .map(function (t, e) {
                                return 'coords.' + l[e + c]
                              })
                              .join(', ')) +
                        ');\n    }\n  '
                      )
                    })(t, e)),
              r
            )
          })(t, e, r)
        })
        .join('\n'),
      u = e.texShape,
      c = Co(),
      l =
        '\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ' +
        c.texture2D +
        '(textureSampler, uv).r;\n    }\n  ',
      t =
        c.version +
        '\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ' +
        c.varyingFs +
        ' vec2 resultUV;\n    ' +
        c.defineOutput +
        '\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ' +
        c.defineSpecialNaN +
        '\n    ' +
        c.defineSpecialInf +
        '\n    ' +
        c.defineRound +
        '\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    \nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n\n    \nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n\n    \nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n\n  ',
      c = e.isPacked
        ? ((i = (function (t, e) {
            switch (t.length) {
              case 0:
                return '\n    int getOutputCoords() {\n      return 0;\n    }\n  '
              case 1:
                return (function (t) {
                  t = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)]
                  return 1 === t[0]
                    ? '\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ' + t[1] + '.0);\n      }\n    '
                    : 1 === t[1]
                    ? '\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ' + t[0] + '.0);\n      }\n    '
                    : '\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(' +
                      t[0] +
                      ', ' +
                      t[1] +
                      '));\n      return 2 * (resTexRC.x * ' +
                      t[1] +
                      ' + resTexRC.y);\n    }\n  '
                })(e)
              case 2:
                return (function (t, e) {
                  var n = [Math.ceil(e[0] / 2), Math.ceil(e[1] / 2)]
                  if (S(t, e))
                    return (
                      '\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(' +
                      n[0] +
                      ', ' +
                      n[1] +
                      '));\n      }\n    '
                    )
                  t = Math.ceil(t[1] / 2)
                  return (
                    '\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(' +
                    n[0] +
                    ', ' +
                    n[1] +
                    '));\n\n      int index = resTexRC.x * ' +
                    n[1] +
                    ' + resTexRC.y;\n      int r = 2 * (index / ' +
                    t +
                    ');\n      int c = imod(index, ' +
                    t +
                    ') * 2;\n\n      return ivec2(r, c);\n    }\n  '
                  )
                })(t, e)
              case 3:
                return (
                  (o = t),
                  (r = e),
                  (n = [Math.ceil(r[0] / 2), Math.ceil(r[1] / 2)]),
                  (o = (r = Math.ceil(o[2] / 2)) * Math.ceil(o[1] / 2)),
                  '\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(' +
                    n[0] +
                    ', ' +
                    n[1] +
                    '));\n      int index = resTexRC.x * ' +
                    n[1] +
                    ' + resTexRC.y;\n\n      int b = index / ' +
                    o +
                    ';\n      index -= b * ' +
                    o +
                    ';\n\n      int r = 2 * (index / ' +
                    r +
                    ');\n      int c = imod(index, ' +
                    r +
                    ') * 2;\n\n      return ivec3(b, r, c);\n    }\n  '
                )
              default:
                return (function (t, e) {
                  for (
                    var n = [Math.ceil(e[0] / 2), Math.ceil(e[1] / 2)],
                      r = Math.ceil(t[t.length - 1] / 2),
                      e = r * Math.ceil(t[t.length - 2] / 2),
                      o = e,
                      i = '',
                      a = 'b, r, c',
                      s = 2;
                    s < t.length - 1;
                    s++
                  )
                    (i =
                      '\n      int b' +
                      s +
                      ' = index / ' +
                      (o *= t[t.length - s - 1]) +
                      ';\n      index -= b' +
                      s +
                      ' * ' +
                      o +
                      ';\n    ' +
                      i),
                      (a = 'b' + s + ', ' + a)
                  return (
                    '\n    ivec' +
                    t.length +
                    ' getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(' +
                    n[0] +
                    ', ' +
                    n[1] +
                    '));\n      int index = resTexRC.x * ' +
                    n[1] +
                    ' + resTexRC.y;\n\n      ' +
                    i +
                    '\n\n      int b = index / ' +
                    e +
                    ';\n      index -= b * ' +
                    e +
                    ';\n\n      int r = 2 * (index / ' +
                    r +
                    ');\n      int c = imod(index, ' +
                    r +
                    ') * 2;\n\n      return ivec' +
                    t.length +
                    '(' +
                    a +
                    ');\n    }\n  '
                  )
                })(t, e)
            }
            var n, r, o
          })(e.logicalShape, u)),
          '\n    void setOutput(vec4 val) {\n      ' + c.output + ' = val;\n    }\n  ')
        : ((i = (function (t, e) {
            switch (t.length) {
              case 0:
                return '\n    int getOutputCoords() {\n      return 0;\n    }\n  '
              case 1:
                return 1 === e[0]
                  ? '\n      int getOutputCoords() {\n        return int(resultUV.x * ' + e[1] + '.0);\n      }\n    '
                  : 1 === e[1]
                  ? '\n      int getOutputCoords() {\n        return int(resultUV.y * ' + e[0] + '.0);\n      }\n    '
                  : '\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(' +
                    e[0] +
                    ', ' +
                    e[1] +
                    '));\n      return resTexRC.x * ' +
                    e[1] +
                    ' + resTexRC.y;\n    }\n  '
              case 2:
                return S((o = t), (i = e))
                  ? '\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(' +
                      i[0] +
                      ', ' +
                      i[1] +
                      '));\n      }\n    '
                  : 1 === o[1]
                  ? '\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(' +
                    i[0] +
                    ', ' +
                    i[1] +
                    '));\n        int index = resTexRC.x * ' +
                    i[1] +
                    ' + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    '
                  : 1 === o[0]
                  ? '\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(' +
                    i[0] +
                    ', ' +
                    i[1] +
                    '));\n        int index = resTexRC.x * ' +
                    i[1] +
                    ' + resTexRC.y;\n        return ivec2(0, index);\n      }\n    '
                  : '\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(' +
                    i[0] +
                    ', ' +
                    i[1] +
                    '));\n      int index = resTexRC.x * ' +
                    i[1] +
                    ' + resTexRC.y;\n      int r = index / ' +
                    o[1] +
                    ';\n      int c = index - r * ' +
                    o[1] +
                    ';\n      return ivec2(r, c);\n    }\n  '
              case 3:
                return (
                  (a = e),
                  (s = Eo(['r', 'c', 'd'], t)),
                  '\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(' +
                    a[0] +
                    ', ' +
                    a[1] +
                    '));\n      int index = resTexRC.x * ' +
                    a[1] +
                    ' + resTexRC.y;\n      ' +
                    s +
                    '\n      return ivec3(r, c, d);\n    }\n  '
                )
              case 4:
                return (
                  (a = e),
                  (s = Eo(['r', 'c', 'd', 'd2'], t)),
                  '\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(' +
                    a[0] +
                    ', ' +
                    a[1] +
                    '));\n      int index = resTexRC.x * ' +
                    a[1] +
                    ' + resTexRC.y;\n      ' +
                    s +
                    '\n      return ivec4(r, c, d, d2);\n    }\n  '
                )
              case 5:
                return (
                  (n = e),
                  (r = Eo(['r', 'c', 'd', 'd2', 'd3'], t)),
                  '\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(' +
                    n[0] +
                    ',\n                             ' +
                    n[1] +
                    '));\n\n      int index = resTexRC.x * ' +
                    n[1] +
                    ' + resTexRC.y;\n\n      ' +
                    r +
                    '\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  '
                )
              case 6:
                return (
                  (n = e),
                  (r = Eo(['r', 'c', 'd', 'd2', 'd3', 'd4'], t)),
                  '\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(' +
                    n[0] +
                    ', ' +
                    n[1] +
                    '));\n      int index = resTexRC.x * ' +
                    n[1] +
                    ' + resTexRC.y;\n\n      ' +
                    r +
                    '\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  '
                )
              default:
                throw new Error(t.length + '-D output sampling is not yet supported')
            }
            var n, r, o, i, a, s
          })(e.logicalShape, u)),
          '\n    void setOutput(float val) {\n      ' + c.output + ' = vec4(val, 0, 0, 0);\n    }\n  ')
    return (
      r &&
        (t +=
          '\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n'),
      [t, l, c, a, i, s, n].join('\n')
    )
  }
  function Io(t) {
    return 'offset' + t
  }
  function Ao(t) {
    var e = t.name,
      t = D(t.shapeInfo.logicalShape)
    return t < 2
      ? 'return ' + e + ';'
      : '\n    for (int i = 0; i < ' + t + '; i++) {\n      if (i == index) {\n        return ' + e + '[i];\n      }\n    }\n  '
  }
  function No(t) {
    if (t <= 1) return 'int'
    if (2 === t) return 'ivec2'
    if (3 === t) return 'ivec3'
    if (4 === t) return 'ivec4'
    if (5 === t) return 'ivec5'
    if (6 === t) return 'ivec6'
    throw Error('GPU for rank ' + t + ' is not yet supported')
  }
  function ko(t, e) {
    t = JSON.parse(JSON.stringify(t))
    return (t.shapeInfo.logicalShape = e), t
  }
  function To(e, t) {
    return t
      .map(function (t) {
        return e[t]
      })
      .join(', ')
  }
  function Do(t, e, n, r) {
    ;(this.variableNames = ['A']),
      (this.packedInputs = !0),
      (this.packedOutput = !0),
      A(2 < t.length, function () {
        return 'Packed arg' + (n.charAt(0).toUpperCase() + n.slice(1)) + ' supports only inputs with rank above 2.'
      })
    var o = t[t.length - 1],
      i = Math.ceil(o / e)
    ;(this.outputShape = t.slice(0, -1)), 1 < i && this.outputShape.push(i), r || this.variableNames.push('bestIndicesA')
    var a,
      s = this.outputShape,
      u = s.length,
      c = No(u),
      l = wo('coords', u)
    a =
      1 === i
        ? '\n        ' +
          (v = No((m = u + 1))) +
          ' sourceLocR = ' +
          v +
          '(' +
          l.join() +
          ', 0);\n        ++' +
          l[u - 1] +
          ';\n        ' +
          v +
          ' sourceLocG = ' +
          v +
          '(' +
          l.join() +
          ', 0);\n        ++' +
          l[u - 2] +
          ';\n        ' +
          v +
          ' sourceLocA = ' +
          v +
          '(' +
          l.join() +
          ', 0);\n        --' +
          l[u - 1] +
          ';\n        ' +
          v +
          ' sourceLocB = ' +
          v +
          '(' +
          l.join() +
          ', 0);\n        --' +
          l[u - 2] +
          ';'
        : '\n        ' +
          c +
          ' sourceLocR = coords;\n        ++' +
          l[(m = u) - 1] +
          ';\n        ' +
          c +
          ' sourceLocG = coords;\n        ++' +
          l[u - 2] +
          ';\n        ' +
          c +
          ' sourceLocA = coords;\n        --' +
          l[u - 1] +
          ';\n        ' +
          c +
          ' sourceLocB = coords;\n        --' +
          l[u - 2] +
          ';'
    var h = ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, m),
      p = '.' + h[m - 1],
      d = h.map(function (t) {
        return 'int ' + t
      }),
      f = wo('sourceLocR', m - 1).concat('inIdx.r'),
      o = wo('sourceLocG', m - 1).concat('inIdx.g'),
      t = wo('sourceLocB', m - 1).concat('inIdx.b'),
      i = wo('sourceLocA', m - 1).concat('inIdx.a'),
      v = 'max' === n ? 'greaterThan' : 'lessThan',
      m = r
        ? ''
        : '\n          inIdx = round(vec4(getBestIndicesAChannel(' +
          f.join() +
          '),\n                             getBestIndicesAChannel(' +
          o.join() +
          '),\n                             getBestIndicesAChannel(' +
          t.join() +
          '),\n                             getBestIndicesAChannel(' +
          i.join() +
          ')));',
      i =
        'vec4(\n            getAChannel(' +
        f.join() +
        '),\n            hasNextCol ? getAChannel(' +
        o.join() +
        ') : 0.,\n            hasNextRow ? getAChannel(' +
        t.join() +
        ') : 0.,\n            hasNextRow && hasNextCol ? getAChannel(' +
        i.join() +
        ') : 0.)',
      r = r
        ? ''
        : '\n      float getBestIndicesAChannel(' +
          d.join() +
          ') {\n        return getChannel(getBestIndicesA(' +
          h.join() +
          '),\n                                          vec2(' +
          h.slice(-2).join() +
          '));\n      }'
    this.userCode =
      '\n      float getAChannel(' +
      d.join() +
      ') {\n        return getChannel(getA(' +
      h.join() +
      '),\n                               vec2(' +
      h.slice(-2).join() +
      '));\n      }\n      ' +
      r +
      '\n      void main() {\n        ' +
      c +
      ' coords = getOutputCoords();\n        bool hasNextCol = ' +
      l[u - 1] +
      ' < ' +
      (s[u - 1] - 1) +
      ';\n        bool hasNextRow = ' +
      l[u - 2] +
      ' < ' +
      (s[u - 2] - 1) +
      ';\n        ' +
      a +
      '\n        ivec4 srcIdx = ivec4(sourceLocR' +
      p +
      ', sourceLocG' +
      p +
      ',\n          sourceLocB' +
      p +
      ', sourceLocA' +
      p +
      ') * ' +
      e +
      ';\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ' +
      i +
      ';\n\n        for (int i = 0; i < ' +
      e +
      '; i++) {\n          inIdx = srcIdx;\n          ' +
      m +
      '\n          vec4 candidate = ' +
      i +
      ';\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(' +
      v +
      '(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    '
  }
  function Oo(t) {
    ;(this.variableNames = ['dy']), (this.outputShape = t.inShape)
    var e = t.filterHeight,
      n = t.filterWidth,
      r = t.strideHeight,
      o = t.strideWidth,
      i = t.dilationHeight,
      a = t.dilationWidth,
      s = t.effectiveFilterHeight,
      u = t.effectiveFilterWidth,
      c = s - 1 - t.padInfo.top,
      l = u - 1 - t.padInfo.left,
      n = 1 / (e * n)
    this.userCode =
      '\n      const ivec2 pads = ivec2(' +
      c +
      ', ' +
      l +
      ');\n      const float avgMultiplier = float(' +
      n +
      ');\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ' +
      s +
      ';\n            wR += ' +
      i +
      ') {\n          float dyR = float(dyRCorner + wR) / ' +
      r +
      '.0;\n\n          if (dyR < 0.0 || dyR >= ' +
      t.outHeight +
      '.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ' +
      u +
      ';\n            wC+= ' +
      a +
      ') {\n            float dyC = float(dyCCorner + wC) / ' +
      o +
      '.0;\n\n            if (dyC < 0.0 || dyC >= ' +
      t.outWidth +
      '.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    '
  }
  function Fo(t) {
    ;(this.variableNames = ['dy']), (this.outputShape = t.inShape)
    var e = t.filterDepth,
      n = t.filterHeight,
      r = t.filterWidth,
      o = t.strideDepth,
      i = t.strideHeight,
      a = t.strideWidth,
      s = t.dilationDepth,
      u = t.dilationHeight,
      c = t.dilationWidth,
      l = t.effectiveFilterDepth,
      h = t.effectiveFilterHeight,
      p = t.effectiveFilterWidth,
      d = l - 1 - t.padInfo.front,
      f = h - 1 - t.padInfo.top,
      v = p - 1 - t.padInfo.left,
      r = 1 / (e * n * r)
    this.userCode =
      '\n      const ivec3 pads = ivec3(' +
      d +
      ', ' +
      f +
      ', ' +
      v +
      ');\n      const float avgMultiplier = float(' +
      r +
      ');\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ' +
      l +
      ';\n            wD += ' +
      s +
      ') {\n          float dyD = float(dyDCorner + wD) / ' +
      o +
      '.0;\n\n          if (dyD < 0.0 || dyD >= ' +
      t.outDepth +
      '.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ' +
      h +
      ';\n              wR += ' +
      u +
      ') {\n            float dyR = float(dyRCorner + wR) / ' +
      i +
      '.0;\n\n            if (dyR < 0.0 || dyR >= ' +
      t.outHeight +
      '.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ' +
      p +
      ';\n                wC += ' +
      c +
      ') {\n              float dyC = float(dyCCorner + wC) / ' +
      a +
      '.0;\n\n              if (dyC < 0.0 || dyC >= ' +
      t.outWidth +
      '.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    '
  }
  function Mo(t, e, n, r, o, i) {
    ;(this.outputShape = []),
      (this.variableNames = ['x', 'mean', 'variance']),
      Vr(t, e),
      Vr(t, n),
      (n = '0.0'),
      null != r && (Vr(t, r), this.variableNames.push('offset'), (n = 'getOffsetAtOutCoords()')),
      (r = '1.0'),
      null != o && (Vr(t, o), this.variableNames.push('scale'), (r = 'getScaleAtOutCoords()')),
      (this.outputShape = t),
      (this.userCode =
        '\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ' +
        n +
        ';\n        float scale = ' +
        r +
        ';\n        float inv = scale * inversesqrt(variance + float(' +
        i +
        '));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    ')
  }
  function Po(t, e, n, r, o, i) {
    ;(this.packedInputs = !0),
      (this.packedOutput = !0),
      (this.variableNames = ['x', 'mean', 'variance']),
      Vr(t, e),
      Vr(t, n),
      (n = 'vec4(0.0)'),
      null != r && (Vr(t, r), this.variableNames.push('offset'), (n = 'getOffsetAtOutCoords()')),
      (r = 'vec4(1.0)'),
      null != o && (Vr(t, o), this.variableNames.push('scale'), (r = 'getScaleAtOutCoords()')),
      (this.outputShape = t),
      (this.userCode =
        '\n      void main() {\n        vec4 offset = ' +
        n +
        ';\n        vec4 scale = ' +
        r +
        ';\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(' +
        i +
        '));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    ')
  }
  function Bo(t, e, n) {
    ;(this.variableNames = ['AReal', 'AImag', 'BReal', 'BImag']),
      (this.outputShape = Vr(e, n)),
      (this.userCode =
        '\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ' +
        t +
        '\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    ')
  }
  function Lo(t, e, n) {
    ;(this.variableNames = ['A', 'B']),
      (this.outputShape = Vr(e, n)),
      (this.userCode =
        '\n      float binaryOperation(float a, float b) {\n        ' +
        t +
        '\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    ')
  }
  function Wo(t, e, n, r) {
    void 0 === r && (r = !1),
      (this.variableNames = ['A', 'B']),
      (this.supportsBroadcasting = !0),
      (this.packedInputs = !0),
      (this.packedOutput = !0),
      (this.outputShape = Vr(e, n)),
      (e = this.outputShape.length),
      (n = ''),
      r &&
        (0 === e || 1 === D(this.outputShape)
          ? (n = '\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ')
          : ((n = '\n          ' + No(e) + ' coords = getOutputCoords();\n        '),
            (n +=
              1 === e
                ? '\n            result.y = (coords + 1) >= ' +
                  this.outputShape[0] +
                  ' ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          '
                : '\n            bool nextRowOutOfBounds =\n              (' +
                  (r = wo('coords', e))[e - 2] +
                  ' + 1) >= ' +
                  this.outputShape[e - 2] +
                  ';\n            bool nextColOutOfBounds =\n              (' +
                  r[e - 1] +
                  ' + 1) >= ' +
                  this.outputShape[e - 1] +
                  ';\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          '))),
      (this.userCode =
        '\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ' +
        t +
        '\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ' +
        n +
        '\n\n        setOutput(result);\n      }\n    ')
  }
  function zo(t) {
    ;(this.variableNames = ['real', 'imag']),
      (this.outputShape = t),
      (this.userCode =
        '\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    ')
  }
  function Go(t) {
    ;(this.outputShape = []),
      (this.outputShape = rn(t, 1)),
      (this.variableNames = t.map(function (t, e) {
        return 'T' + e
      }))
    var e = new Array(t.length - 1)
    e[0] = t[0][1]
    for (var n = 1; n < e.length; n++) e[n] = e[n - 1] + t[n][1]
    for (var r = ['if (yC < ' + e[0] + ') setOutput(getT0(yR, yC));'], n = 1; n < e.length; n++) {
      var o = e[n - 1]
      r.push('else if (yC < ' + e[n] + ') setOutput(getT' + n + '(yR, yC-' + o + '));')
    }
    var i = e.length,
      a = e[e.length - 1]
    r.push('else setOutput(getT' + i + '(yR, yC-' + a + '));'),
      (this.userCode =
        '\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ' +
        r.join('\n        ') +
        '\n      }\n    ')
  }
  function Uo(t, e) {
    ;(this.packedInputs = !0), (this.packedOutput = !0), (this.outputShape = []), (this.outputShape = rn(t, e))
    var n = this.outputShape,
      r = n.length,
      o = No(r),
      i = wo('coords', r),
      a = ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, r)
    this.variableNames = t.map(function (t, e) {
      return 'T' + e
    })
    var s = new Array(t.length - 1)
    s[0] = t[0][e]
    for (var u = 1; u < s.length; u++) s[u] = s[u - 1] + t[u][e]
    for (
      var c = a[e],
        l = a.slice(-2),
        h = a.join(),
        p =
          'if (' +
          c +
          ' < ' +
          s[0] +
          ') {\n        return getChannel(\n            getT0(' +
          h +
          '), vec2(' +
          l.join() +
          '));\n        }',
        u = 1;
      u < s.length;
      u++
    ) {
      var d = s[u - 1]
      p +=
        '\n        if (' +
        c +
        ' < ' +
        s[u] +
        '  && ' +
        c +
        ' >= ' +
        s[u - 1] +
        ') {\n          return getChannel(\n            getT' +
        u +
        '(' +
        Qo(a, c, d) +
        '),\n            vec2(' +
        Qo(l, c, d) +
        '));\n        }'
    }
    var f = s.length,
      h = s[s.length - 1]
    ;(p +=
      '\n        return getChannel(\n          getT' + f + '(' + Qo(a, c, h) + '),\n          vec2(' + Qo(l, c, h) + '));'),
      (this.userCode =
        '\n      float getValue(' +
        a.map(function (t) {
          return 'int ' + t
        }) +
        ') {\n        ' +
        p +
        '\n      }\n\n      void main() {\n        ' +
        o +
        ' coords = getOutputCoords();\n        vec4 result = vec4(getValue(' +
        i +
        '), 0., 0., 0.);\n\n        ' +
        i[r - 1] +
        ' = ' +
        i[r - 1] +
        ' + 1;\n        if (' +
        i[r - 1] +
        ' < ' +
        n[r - 1] +
        ') {\n          result.g = getValue(' +
        i +
        ');\n        }\n\n        ' +
        i[r - 2] +
        ' = ' +
        i[r - 2] +
        ' + 1;\n        if (' +
        i[r - 2] +
        ' < ' +
        n[r - 2] +
        ') {\n          result.a = getValue(' +
        i +
        ');\n        }\n\n        ' +
        i[r - 1] +
        ' = ' +
        i[r - 1] +
        ' - 1;\n        if (' +
        i[r - 2] +
        ' < ' +
        n[r - 2] +
        ' &&\n            ' +
        i[r - 1] +
        ' < ' +
        n[r - 1] +
        ') {\n          result.b = getValue(' +
        i +
        ');\n        }\n        setOutput(result);\n      }\n    ')
  }
  var Vo = 'return a + b;',
    Ho = 'return a - b;',
    jo = 'return a * b;',
    qo = 'return (a < 0.) ? b * a : a;',
    Ko =
      '\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n',
    Xo =
      ((Jo.prototype.getCustomSetupFunc = function (n, r) {
        var o = this
        return function (t, e) {
          null == o.minLoc &&
            ((o.minLoc = t.getUniformLocationNoThrow(e, 'minVal')), (o.maxLoc = t.getUniformLocationNoThrow(e, 'maxVal'))),
            t.gl.uniform1f(o.minLoc, n),
            t.gl.uniform1f(o.maxLoc, r)
        }
      }),
      Jo),
    $o =
      ((Yo.prototype.getCustomSetupFunc = function (n, r) {
        var o = this
        return function (t, e) {
          null == o.minLoc &&
            ((o.minLoc = t.getUniformLocationNoThrow(e, 'minVal')), (o.maxLoc = t.getUniformLocationNoThrow(e, 'maxVal'))),
            t.gl.uniform1f(o.minLoc, n),
            t.gl.uniform1f(o.maxLoc, r)
        }
      }),
      Yo)
  function Yo(t) {
    ;(this.variableNames = ['A']),
      (this.packedInputs = !0),
      (this.packedOutput = !0),
      (this.outputShape = t),
      (this.userCode =
        '\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    ')
  }
  function Jo(t) {
    ;(this.variableNames = ['A']),
      (this.outputShape = t),
      (this.userCode =
        '\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    ')
  }
  function Qo(t, e, n) {
    var r = t.indexOf(e)
    return t
      .map(function (t, e) {
        return e === r ? t + ' - ' + n : t
      })
      .join()
  }
  function Zo(t) {
    ;(this.variableNames = ['x', 'dy']), (this.outputShape = t.filterShape)
    var e = t.strideHeight,
      n = t.strideWidth,
      r = t.padInfo.top,
      o = t.padInfo.left,
      i = 'channelsLast' === t.dataFormat
    this.userCode =
      '\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ' +
      t.batchSize +
      '; b++) {\n          for (int yR = 0; yR < ' +
      t.outHeight +
      '; yR++) {\n            int xR = wR + yR * ' +
      e +
      ' - ' +
      r +
      ';\n\n            if (xR < 0 || xR >= ' +
      t.inHeight +
      ') {\n              continue;\n            }\n\n            for (int yC = 0; yC < ' +
      t.outWidth +
      '; yC++) {\n              int xC = wC + yC * ' +
      n +
      ' - ' +
      o +
      ';\n\n              if (xC < 0 || xC >= ' +
      t.inWidth +
      ') {\n                continue;\n              }\n\n              if (' +
      i +
      ') {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    '
  }
  function ti(t) {
    ;(this.variableNames = ['dy', 'W']), (this.outputShape = t.inShape)
    var e = t.filterHeight,
      n = t.filterWidth,
      r = t.strideHeight,
      o = t.strideWidth,
      i = 'channelsLast' === t.dataFormat,
      a = e - 1 - t.padInfo.top,
      s = n - 1 - t.padInfo.left,
      u = i ? 1 : 2,
      c = i ? 2 : 3,
      l = i ? 3 : 1
    this.userCode =
      '\n      const ivec2 pads = ivec2(' +
      a +
      ', ' +
      s +
      ');\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[' +
      l +
      '];\n\n        ivec2 dyCorner = ivec2(coords[' +
      u +
      '], coords[' +
      c +
      ']) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ' +
      e +
      '; wR++) {\n          float dyR = float(dyRCorner + wR) / ' +
      r +
      '.0;\n\n          if (dyR < 0.0 || dyR >= ' +
      t.outHeight +
      '.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ' +
      e +
      ' - 1 - wR;\n\n          for (int wC = 0; wC < ' +
      n +
      '; wC++) {\n            float dyC = float(dyCCorner + wC) / ' +
      o +
      '.0;\n\n            if (dyC < 0.0 || dyC >= ' +
      t.outWidth +
      '.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ' +
      n +
      ' - 1 - wC;\n\n            for (int d2 = 0; d2 < ' +
      t.outChannels +
      '; d2++) {\n\n              if (' +
      i +
      ') {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    '
  }
  function ei(t) {
    ;(this.variableNames = ['x', 'dy']), (this.outputShape = t.filterShape)
    var e = t.strideDepth,
      n = t.strideHeight,
      r = t.strideWidth,
      o = t.padInfo.front,
      i = t.padInfo.top,
      a = t.padInfo.left
    this.userCode =
      '\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ' +
      t.batchSize +
      '; b++) {\n          for (int yF = 0; yF < ' +
      t.outDepth +
      '; yF++) {\n            int xF = wF + yF * ' +
      e +
      ' - ' +
      o +
      ';\n\n            if (xF < 0 || xF >= ' +
      t.inDepth +
      ') {\n              continue;\n            }\n\n            for (int yR = 0; yR < ' +
      t.outHeight +
      '; yR++) {\n              int xR = wR + yR * ' +
      n +
      ' - ' +
      i +
      ';\n\n              if (xR < 0 || xR >= ' +
      t.inHeight +
      ') {\n                continue;\n              }\n\n              for (int yC = 0; yC < ' +
      t.outWidth +
      '; yC++) {\n                int xC = wC + yC * ' +
      r +
      ' - ' +
      a +
      ';\n\n                if (xC < 0 || xC >= ' +
      t.inWidth +
      ') {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    '
  }
  function ni(t) {
    ;(this.variableNames = ['dy', 'W']), (this.outputShape = t.inShape)
    var e = t.filterDepth,
      n = t.filterHeight,
      r = t.filterWidth,
      o = t.strideDepth,
      i = t.strideHeight,
      a = t.strideWidth,
      s = e - 1 - t.padInfo.front,
      u = n - 1 - t.padInfo.top,
      c = r - 1 - t.padInfo.left
    this.userCode =
      '\n      const ivec3 pads = ivec3(' +
      s +
      ', ' +
      u +
      ', ' +
      c +
      ');\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ' +
      e +
      '; wF++) {\n          float dyF = float(dyFCorner + wF) / ' +
      o +
      '.0;\n\n          if (dyF < 0.0 || dyF >= ' +
      t.outDepth +
      '.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ' +
      e +
      ' - 1 - wF;\n\n          for (int wR = 0; wR < ' +
      n +
      '; wR++) {\n            float dyR = float(dyRCorner + wR) / ' +
      i +
      '.0;\n\n            if (dyR < 0.0 || dyR >= ' +
      t.outHeight +
      '.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ' +
      n +
      ' - 1 - wR;\n\n            for (int wC = 0; wC < ' +
      r +
      '; wC++) {\n              float dyC = float(dyCCorner + wC) / ' +
      a +
      '.0;\n\n              if (dyC < 0.0 || dyC >= ' +
      t.outWidth +
      '.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ' +
      r +
      ' - 1 - wC;\n\n              for (int d2 = 0; d2 < ' +
      t.outChannels +
      '; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    '
  }
  function ri(t) {
    ;(this.variableNames = ['x', 'dy']), (this.outputShape = t.filterShape)
    var e = t.strideHeight,
      n = t.strideWidth,
      r = t.padInfo.top,
      o = t.padInfo.left,
      i = t.outChannels / t.inChannels
    this.userCode =
      '\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ' +
      i +
      ' + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ' +
      t.batchSize +
      '; b++) {\n          for (int yR = 0; yR < ' +
      t.outHeight +
      '; yR++) {\n            int xR = wR + yR * ' +
      e +
      ' - ' +
      r +
      ';\n\n            if (xR < 0 || xR >= ' +
      t.inHeight +
      ') {\n              continue;\n            }\n\n            for (int yC = 0; yC < ' +
      t.outWidth +
      '; yC++) {\n              int xC = wC + yC * ' +
      n +
      ' - ' +
      o +
      ';\n\n              if (xC < 0 || xC >= ' +
      t.inWidth +
      ') {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    '
  }
  function oi(t) {
    ;(this.variableNames = ['dy', 'W']), (this.outputShape = t.inShape)
    var e = t.filterHeight,
      n = t.filterWidth,
      r = t.strideHeight,
      o = t.strideWidth,
      i = e - 1 - t.padInfo.top,
      a = n - 1 - t.padInfo.left,
      s = t.outChannels / t.inChannels
    this.userCode =
      '\n      const ivec2 pads = ivec2(' +
      i +
      ', ' +
      a +
      ');\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ' +
      e +
      '; wR++) {\n          float dyR = float(dyRCorner + wR) / ' +
      r +
      '.0;\n\n          if (dyR < 0.0 || dyR >= ' +
      t.outHeight +
      '.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ' +
      e +
      ' - 1 - wR;\n\n          for (int wC = 0; wC < ' +
      n +
      '; wC++) {\n            float dyC = float(dyCCorner + wC) / ' +
      o +
      '.0;\n\n            if (dyC < 0.0 || dyC >= ' +
      t.outWidth +
      '.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ' +
      n +
      ' - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ' +
      s +
      '; dm++) {\n              int d2 = d1 * ' +
      s +
      ' + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    '
  }
  function ii(t, e, n, r) {
    void 0 === e && (e = !1),
      void 0 === n && (n = null),
      void 0 === r && (r = !1),
      (this.variableNames = ['x', 'W']),
      (this.outputShape = t.outShape)
    var o = t.padInfo.top,
      i = t.padInfo.left,
      a = t.strideHeight,
      s = t.strideWidth,
      u = t.dilationHeight,
      c = t.dilationWidth,
      l = t.filterHeight,
      h = t.filterWidth,
      p = 4 * Math.floor(t.inChannels / 4),
      d = t.inChannels % 4,
      f = 'channelsLast' === t.dataFormat,
      v = f ? 1 : 2,
      m = f ? 2 : 3,
      g = f ? 3 : 1,
      y = '',
      b = ''
    n &&
      ((y = r
        ? 'float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ' +
          n +
          '\n        }'
        : '\n          float activation(float x) {\n            ' + n + '\n          }\n        '),
      (b = 'result = activation(result);')),
      (n = e ? 'result += getBiasAtOutCoords();' : ''),
      e && this.variableNames.push('bias'),
      r && this.variableNames.push('preluActivationWeights'),
      (this.userCode =
        '\n      ' +
        y +
        '\n\n      const ivec2 strides = ivec2(' +
        a +
        ', ' +
        s +
        ');\n      const ivec2 pads = ivec2(' +
        o +
        ', ' +
        i +
        ');\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[' +
        g +
        '];\n\n        ivec2 xRCCorner =\n            ivec2(coords[' +
        v +
        '], coords[' +
        m +
        ']) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ' +
        l +
        '; wR++) {\n          int xR = xRCorner + wR * ' +
        u +
        ';\n\n          if (xR < 0 || xR >= ' +
        t.inHeight +
        ') {\n            continue;\n          }\n\n          for (int wC = 0; wC < ' +
        h +
        '; wC++) {\n            int xC = xCCorner + wC * ' +
        c +
        ';\n\n            if (xC < 0 || xC >= ' +
        t.inWidth +
        ') {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ' +
        p +
        '; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (' +
        f +
        ') {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (' +
        (1 == d) +
        ') {\n\n              if (' +
        f +
        ') {\n                dotProd +=\n                    getX(batch, xR, xC, ' +
        p +
        ') *\n                    getW(wR, wC, ' +
        p +
        ', d2);\n              } else {\n                dotProd +=\n                    getX(batch, ' +
        p +
        ', xR, xC) *\n                    getW(wR, wC, ' +
        p +
        ', d2);\n              }\n\n            } else if (' +
        (2 == d) +
        ') {\n              vec2 wValues = vec2(\n                getW(wR, wC, ' +
        p +
        ', d2),\n                getW(wR, wC, ' +
        p +
        ' + 1, d2)\n              );\n\n              if (' +
        f +
        ') {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ' +
        p +
        '),\n                  getX(batch, xR, xC, ' +
        p +
        ' + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ' +
        p +
        ', xR, xC),\n                  getX(batch, ' +
        p +
        ' + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (' +
        (3 == d) +
        ') {\n              vec3 wValues = vec3(\n                getW(wR, wC, ' +
        p +
        ', d2),\n                getW(wR, wC, ' +
        p +
        ' + 1, d2),\n                getW(wR, wC, ' +
        p +
        ' + 2, d2)\n              );\n\n              if (' +
        f +
        ') {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ' +
        p +
        '),\n                  getX(batch, xR, xC, ' +
        p +
        ' + 1),\n                  getX(batch, xR, xC, ' +
        p +
        ' + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ' +
        p +
        ', xR, xC),\n                  getX(batch, ' +
        p +
        ' + 1, xR, xC),\n                  getX(batch, ' +
        p +
        ' + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ' +
        n +
        '\n        ' +
        b +
        '\n        setOutput(result);\n      }\n    ')
  }
  function ai(t) {
    ;(this.variableNames = ['x', 'W']), (this.outputShape = t.outShape)
    var e = t.padInfo.front,
      n = t.padInfo.top,
      r = t.padInfo.left,
      o = t.strideDepth,
      i = t.strideHeight,
      a = t.strideWidth,
      s = t.dilationDepth,
      u = t.dilationHeight,
      c = t.dilationWidth,
      l = t.filterDepth,
      h = t.filterHeight,
      p = t.filterWidth,
      d = 4 * Math.floor(t.inChannels / 4),
      f = t.inChannels % 4
    this.userCode =
      '\n      const ivec3 strides = ivec3(' +
      o +
      ', ' +
      i +
      ', ' +
      a +
      ');\n      const ivec3 pads = ivec3(' +
      e +
      ', ' +
      n +
      ', ' +
      r +
      ');\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ' +
      l +
      '; wF++) {\n          int xF = xFCorner + wF * ' +
      s +
      ';\n\n          if (xF < 0 || xF >= ' +
      t.inDepth +
      ') {\n            continue;\n          }\n\n          for (int wR = 0; wR < ' +
      h +
      '; wR++) {\n            int xR = xRCorner + wR * ' +
      u +
      ';\n\n            if (xR < 0 || xR >= ' +
      t.inHeight +
      ') {\n              continue;\n            }\n\n            for (int wC = 0; wC < ' +
      p +
      '; wC++) {\n              int xC = xCCorner + wC * ' +
      c +
      ';\n\n              if (xC < 0 || xC >= ' +
      t.inWidth +
      ') {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ' +
      d +
      '; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (' +
      (1 == f) +
      ') {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ' +
      d +
      ') *\n                  getW(wF, wR, wC, ' +
      d +
      ', d2);\n              } else if (' +
      (2 == f) +
      ') {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ' +
      d +
      '),\n                  getX(batch, xF, xR, xC, ' +
      d +
      ' + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ' +
      d +
      ', d2),\n                  getW(wF, wR, wC, ' +
      d +
      ' + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (' +
      (3 == f) +
      ') {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ' +
      d +
      '),\n                  getX(batch, xF, xR, xC, ' +
      d +
      ' + 1),\n                  getX(batch, xF, xR, xC, ' +
      d +
      ' + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ' +
      d +
      ', d2),\n                  getW(wF, wR, wC, ' +
      d +
      ' + 1, d2),\n                  getW(wF, wR, wC, ' +
      d +
      ' + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    '
  }
  function si(t, e, n, r) {
    void 0 === e && (e = !1),
      void 0 === n && (n = null),
      void 0 === r && (r = !1),
      (this.variableNames = ['x', 'W']),
      (this.outputShape = t.outShape)
    var o = t.inHeight,
      i = t.inWidth,
      a = t.padInfo.top,
      s = t.padInfo.left,
      u = t.strideHeight,
      c = t.strideWidth,
      l = t.dilationHeight,
      h = t.dilationWidth,
      p = t.filterHeight,
      d = t.filterWidth,
      f = t.outChannels / t.inChannels,
      v = '',
      t = ''
    n &&
      ((v = r
        ? 'float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ' +
          n +
          '\n        }'
        : '\n          float activation(float x) {\n            ' + n + '\n          }\n        '),
      (t = 'result = activation(result);')),
      (n = e ? 'result += getBiasAtOutCoords();' : ''),
      e && this.variableNames.push('bias'),
      r && this.variableNames.push('preluActivationWeights'),
      (this.userCode =
        '\n      ' +
        v +
        '\n\n      const ivec2 strides = ivec2(' +
        u +
        ', ' +
        c +
        ');\n      const ivec2 pads = ivec2(' +
        a +
        ', ' +
        s +
        ');\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ' +
        f +
        ';\n        int q = d2 - d1 * ' +
        f +
        ';\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ' +
        p +
        '; wR++) {\n          int xR = xRCorner + wR * ' +
        l +
        ';\n\n          if (xR < 0 || xR >= ' +
        o +
        ') {\n            continue;\n          }\n\n          for (int wC = 0; wC < ' +
        d +
        '; wC++) {\n            int xC = xCCorner + wC * ' +
        h +
        ';\n\n            if (xC < 0 || xC >= ' +
        i +
        ') {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ' +
        n +
        '\n        ' +
        t +
        '\n        setOutput(result);\n      }\n    ')
  }
  function ui(t, e, n, r) {
    void 0 === e && (e = !1),
      void 0 === n && (n = null),
      void 0 === r && (r = !1),
      (this.variableNames = ['x', 'W']),
      (this.packedInputs = !0),
      (this.packedOutput = !0),
      (this.outputShape = t.outShape)
    for (
      var o,
        i = t.inHeight,
        a = t.inWidth,
        s = t.padInfo.top,
        u = t.padInfo.left,
        c = t.strideHeight,
        l = t.strideWidth,
        h = t.dilationHeight,
        p = t.dilationWidth,
        d = t.filterHeight,
        f = t.filterWidth,
        v = f,
        m = 'int xR; int xC; int xCOffset;',
        g = 0;
      g < d;
      g++
    )
      for (var y = 0; y < f; y++)
        m +=
          '\n          vec4 xTexelR' +
          g +
          'C' +
          2 * y +
          ' = vec4(0.);\n          vec4 wR' +
          g +
          'C' +
          y +
          ' = vec4(0.);\n          vec4 xR' +
          g +
          'C' +
          y +
          ' = vec4(0.);'
    for (g = 0; g < d; g++)
      for (var b = 0; b < v; b++)
        (m += '\n          xR = xRCorner + ' + g * h + ';\n          xC = xCCorner + ' + (y = 2 * b) * p + ';\n        '),
          1 === l
            ? y < f &&
              ((m +=
                u % 2 == 1
                  ? '\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < ' +
                    i +
                    ' && xCOffset >= 0 && xCOffset < ' +
                    a +
                    ') {\n                  xTexelR' +
                    g +
                    'C' +
                    y +
                    " = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= " +
                    a +
                    ') {\n                    xTexelR' +
                    g +
                    'C' +
                    y +
                    '.zw = vec2(0.);\n                  }\n                } else {\n                  xTexelR' +
                    g +
                    'C' +
                    y +
                    ' = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < ' +
                    i +
                    ' && xCOffset >= 0 && xCOffset < ' +
                    a +
                    ") {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= " +
                    a +
                    ') {\n                    previous.zw = vec2(0.);\n                  }\n\n                  xR' +
                    g +
                    'C' +
                    y +
                    ' = vec4(previous.zw, xTexelR' +
                    g +
                    'C' +
                    y +
                    '.xy);\n                } else {\n                  xR' +
                    g +
                    'C' +
                    y +
                    ' = vec4(0, 0, xTexelR' +
                    g +
                    'C' +
                    y +
                    '.xy);\n                }\n              '
                  : '\n                if(xR >= 0 && xR < ' +
                    i +
                    ' && xC >= 0 && xC < ' +
                    a +
                    ') {\n                  xTexelR' +
                    g +
                    'C' +
                    y +
                    ' = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR' +
                    g +
                    'C' +
                    y +
                    ' = vec4(0.);\n                }\n\n                xR' +
                    g +
                    'C' +
                    y +
                    ' = xTexelR' +
                    g +
                    'C' +
                    y +
                    ';\n              '),
              y + 1 < f) &&
              ((o = u % 2 == 0 ? C(p) : p),
              (p % 2 == 0 && u % 2 == 1) || (p % 2 != 0 && u % 2 != 1)
                ? ((m +=
                    '\n                  xCOffset = xC + ' +
                    (u % 2) +
                    ' + ' +
                    o +
                    ';\n\n                  if(xR >= 0 && xR < ' +
                    i +
                    ' &&\n                    xCOffset >= 0 && xCOffset < ' +
                    a +
                    ') {\n                    xTexelR' +
                    g +
                    'C' +
                    (y + 2) +
                    ' = getX(batch, xR, xCOffset, d1);\n                  }\n                '),
                  1 < p &&
                    (m +=
                      '\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < ' +
                      i +
                      ' &&\n                      xCOffset >= 0 && xCOffset < ' +
                      a +
                      ') {\n                      xTexelR' +
                      g +
                      'C' +
                      y +
                      ' = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR' +
                      g +
                      'C' +
                      y +
                      ' = vec4(0.);\n                    }\n                  '),
                  (m +=
                    '\n                  xR' +
                    g +
                    'C' +
                    (y + 1) +
                    ' = vec4(\n                    xTexelR' +
                    g +
                    'C' +
                    y +
                    '.zw, xTexelR' +
                    g +
                    'C' +
                    (y + 2) +
                    '.xy);\n                '))
                : (m +=
                    '\n                  xCOffset = xC + ' +
                    o +
                    ';\n\n                  if(xR >= 0 && xR < ' +
                    i +
                    ' &&\n                    xCOffset >= 0 && xCOffset < ' +
                    a +
                    ') {\n                    xTexelR' +
                    g +
                    'C' +
                    (y + 2) +
                    ' = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR' +
                    g +
                    'C' +
                    (y + 1) +
                    ' = xTexelR' +
                    g +
                    'C' +
                    (y + 2) +
                    ';\n                '))
            : y < f &&
              ((m += '\n              if(xR >= 0 && xR < ' + i + ') {\n            '),
              u % 2 == 1
                ? ((m +=
                    '\n                xCOffset = xC + 1 - ' +
                    l +
                    ';\n                if(xCOffset >= 0 && xCOffset < ' +
                    a +
                    ') {\n                  xTexelR' +
                    g +
                    'C' +
                    y +
                    ' = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR' +
                    g +
                    'C' +
                    y +
                    ' = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < ' +
                    a +
                    ') {\n                  xTexelR' +
                    g +
                    'C' +
                    (y + 2) +
                    ' = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR' +
                    g +
                    'C' +
                    (y + 2) +
                    ' = vec4(0.);\n                }\n\n                xR' +
                    g +
                    'C' +
                    y +
                    ' = vec4(\n                  xTexelR' +
                    g +
                    'C' +
                    y +
                    '.zw, xTexelR' +
                    g +
                    'C' +
                    (y + 2) +
                    '.zw);\n              '),
                  y + 1 < f &&
                    (m +=
                      '\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + ' +
                      l +
                      ';\n                  if(xCOffset >= 0 && xCOffset < ' +
                      a +
                      ') {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR' +
                      g +
                      'C' +
                      (y + 1) +
                      ' = vec4(xTexelR' +
                      g +
                      'C' +
                      (y + 2) +
                      '.xy, final.xy);\n                '))
                : ((m +=
                    '\n                if(xC >= 0 && xC < ' +
                    a +
                    ') {\n                  xTexelR' +
                    g +
                    'C' +
                    y +
                    ' = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR' +
                    g +
                    'C' +
                    y +
                    ' = vec4(0.);\n                }\n\n                xCOffset = xC + ' +
                    l +
                    ';\n                if(xCOffset >= 0 && xCOffset < ' +
                    a +
                    ') {\n                  xTexelR' +
                    g +
                    'C' +
                    (y + 2) +
                    ' = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR' +
                    g +
                    'C' +
                    (y + 2) +
                    ' = vec4(0.);\n                }\n\n                xR' +
                    g +
                    'C' +
                    y +
                    ' = vec4(\n                  xTexelR' +
                    g +
                    'C' +
                    y +
                    '.xy, xTexelR' +
                    g +
                    'C' +
                    (y + 2) +
                    '.xy);\n              '),
                  y + 1 < f &&
                    (m +=
                      '\n                  xR' +
                      g +
                      'C' +
                      (y + 1) +
                      ' = vec4(\n                    xTexelR' +
                      g +
                      'C' +
                      y +
                      '.zw, xTexelR' +
                      g +
                      'C' +
                      (y + 2) +
                      '.zw);\n                ')),
              (m += '}')),
          y < f &&
            ((m +=
              '\n            vec4 wTexelR' +
              g +
              'C' +
              y +
              ' = getW(' +
              g +
              ', ' +
              y +
              ', d1, q);\n            wR' +
              g +
              'C' +
              y +
              ' = vec4(wTexelR' +
              g +
              'C' +
              y +
              '.xz, wTexelR' +
              g +
              'C' +
              y +
              '.xz);\n          '),
            y + 1 < f &&
              (m +=
                '\n              vec4 wTexelR' +
                g +
                'C' +
                (y + 1) +
                ' = getW(' +
                g +
                ', ' +
                (y + 1) +
                ', d1, q);\n              wR' +
                g +
                'C' +
                (y + 1) +
                ' =\n                vec4(wTexelR' +
                g +
                'C' +
                (y + 1) +
                '.xz, wTexelR' +
                g +
                'C' +
                (y + 1) +
                '.xz);'))
    for (g = 0; g < d; g++) for (y = 0; y < f; y++) m += 'dotProd += xR' + g + 'C' + y + ' * wR' + g + 'C' + y + ';'
    var x = '',
      t = ''
    n &&
      ((x = r
        ? 'vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ' +
          n +
          '\n        }'
        : 'vec4 activation(vec4 x) {\n          ' + n + '\n        }'),
      (t = 'result = activation(result);')),
      (n = e ? 'result += getBiasAtOutCoords();' : ''),
      e && this.variableNames.push('bias'),
      r && this.variableNames.push('preluActivationWeights'),
      (this.userCode =
        '\n      ' +
        x +
        '\n\n      const ivec2 strides = ivec2(' +
        c +
        ', ' +
        l +
        ');\n      const ivec2 pads = ivec2(' +
        s +
        ', ' +
        u +
        ');\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 dotProd = vec4(0.);\n\n        ' +
        m +
        '\n\n        vec4 result = dotProd;\n        ' +
        n +
        '\n        ' +
        t +
        '\n        setOutput(result);\n      }\n    ')
  }
  function ci(t, e, n, r, o) {
    ;(this.variableNames = ['Image', 'Boxes', 'BoxInd']), (this.outputShape = [])
    var i = t[0],
      a = t[1],
      s = t[2],
      u = t[3],
      c = e[0],
      l = n[0],
      t = n[1]
    ;(this.outputShape = [c, l, t, u]),
      (e = 'bilinear' === r ? 1 : 0),
      (c = (n = [a - 1 + '.0', s - 1 + '.0'])[0]),
      (u = n[1]),
      (n = (r =
        1 < l
          ? ['' + (a - 1) / (l - 1), '(y2-y1) * height_ratio', 'y1*' + c + ' + float(y)*(height_scale)']
          : ['0.0', '0.0', '0.5 * (y1+y2) * ' + c])[0]),
      (a = r[1]),
      (l = r[2]),
      (s = (r =
        1 < t
          ? ['' + (s - 1) / (t - 1), '(x2-x1) * width_ratio', 'x1*' + u + ' + float(x)*(width_scale)']
          : ['0.0', '0.0', '0.5 * (x1+x2) * ' + u])[0]),
      (t = r[1]),
      (r = r[2]),
      (this.userCode =
        '\n      const float height_ratio = float(' +
        n +
        ');\n      const float width_ratio = float(' +
        s +
        ');\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ' +
        i +
        ') {\n          return;\n        }\n\n        float height_scale = ' +
        a +
        ';\n        float width_scale = ' +
        t +
        ';\n\n        float in_y = ' +
        l +
        ';\n        if( in_y < 0.0 || in_y > ' +
        c +
        ' ) {\n          setOutput(float(' +
        o +
        '));\n          return;\n        }\n        float in_x = ' +
        r +
        ';\n        if( in_x < 0.0 || in_x > ' +
        u +
        ' ) {\n          setOutput(float(' +
        o +
        '));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(' +
        e +
        ' == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    ')
  }
  function li(t, e, n) {
    this.variableNames = ['x']
    var r = (this.outputShape = t).length,
      o = t[t.length - 1],
      t = n ? '<' : '>'
    this.userCode =
      '\n      int getIndex(int i) {\n        ' +
      (n ? 'return ' + o + ' -i - 1;' : 'return i;') +
      '\n      }\n\n      void main() {\n        ' +
      No(r) +
      ' coords = getOutputCoords();\n        int end = ' +
      hi(r, 'coords') +
      ';\n        float val = 0.0;\n        for (int i = ' +
      o +
      ' - 1; i >= 0; i -= 1) {\n          int idx = getIndex(i);\n          if (idx ' +
      t +
      ' end) {\n            continue;\n          }\n          if (idx == end && ' +
      e +
      ') {\n            continue;\n          }\n          ' +
      hi(r, 'coords') +
      ' = idx;\n          val += getX(' +
      (function (t) {
        if (1 === r) return t
        if (2 === r) return t + '.x, ' + t + '.y'
        if (3 === r) return 'coords.x, coords.y, coords.z'
        if (4 === r) return 'coords.x, coords.y, coords.z, coords.w'
        throw Error('Cumulative sum for rank ' + r + ' is not yet supported')
      })('coords') +
      ');\n        }\n        setOutput(val);\n      }\n    '
  }
  function hi(t, e) {
    if (1 === t) return '' + e
    if (2 === t) return e + '.y'
    if (3 === t) return e + '.z'
    if (4 === t) return e + '.w'
    throw Error('Cumulative sum for rank ' + t + ' is not yet supported')
  }
  function pi(t) {
    ;(this.variableNames = ['A']), (this.packedInputs = !1), (this.packedOutput = !0), (this.outPackingScheme = Wt.DENSE)
    var e = qt(t),
      n = Co()
    ;(this.outputShape = t),
      (this.userCode =
        '\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ' +
        Eo(['r', 'c', 'd'], t) +
        '\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(' +
        e[0] +
        ', ' +
        e[1] +
        '));\n        int index = 4 * (resTexRC.x * ' +
        e[1] +
        ' + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ' +
        n.output +
        ' = result;\n      }\n    ')
  }
  function di(t) {
    ;(this.variableNames = ['A']), (this.packedInputs = !0), (this.packedOutput = !0), (this.outPackingScheme = Wt.DENSE)
    var e = qt(t),
      n = Co()
    ;(this.outputShape = t),
      (this.userCode =
        '\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ' +
        Eo(['r', 'c', 'd'], t) +
        '\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(' +
        e[0] +
        ', ' +
        e[1] +
        '));\n        int index = 4 * (resTexRC.x * ' +
        e[1] +
        ' + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ' +
        n.output +
        ' = result;\n      }\n    ')
  }
  function fi(t) {
    ;(this.variableNames = ['X']),
      (this.outputShape = [t, t]),
      (this.userCode =
        '\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    ')
  }
  function vi(t) {
    ;(this.variableNames = ['A']), (this.outTexUsage = zt.DOWNLOAD)
    var e = Co()
    ;(this.outputShape = t),
      (this.userCode =
        '\n      ' +
        _o +
        '\n\n      void main() {\n        float x = getAAtOutCoords();\n        ' +
        e.output +
        ' = encode_float(x);\n      }\n    ')
  }
  function mi(t) {
    ;(this.variableNames = ['A']), (this.packedInputs = !0), (this.packedOutput = !1), (this.outTexUsage = zt.DOWNLOAD)
    var e = Co()
    ;(this.outputShape = t),
      (this.userCode =
        '\n      ' +
        _o +
        '\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ' +
        e.output +
        ' = encode_float(x);\n      }\n    ')
  }
  function gi(t, e, n) {
    void 0 === n && (n = !1), (this.variableNames = ['A'])
    var r = Co(),
      o = e[0],
      e = e[1]
    ;(this.outputShape = t),
      (n = n ? 'floor(result * 255. + 0.5)' : 'result'),
      (this.userCode =
        '\n      ' +
        So(t) +
        '\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n        \n        int r = flatIndex / ' +
        e +
        ';\n        int c = imod(flatIndex, ' +
        e +
        ');\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(' +
        e +
        '.0, ' +
        o +
        '.0);\n        vec4 values = ' +
        r.texture2D +
        '(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ' +
        r.output +
        ' = vec4(' +
        n +
        ', 0., 0., 0.);\n      }\n    ')
  }
  function yi(t, e, n) {
    void 0 === n && (n = !1), (this.variableNames = ['A']), (this.packedInputs = !1), (this.packedOutput = !0)
    var r = Co(),
      o = e[0],
      i = e[1]
    this.outputShape = t
    var a = '',
      e = 'result'
    n && (e = 'floor(result * 255. + 0.5)')
    for (var s = 0; s <= 1; s++)
      for (var u = 0; u <= 1; u++) {
        var c = 2 * s + u
        a +=
          '\n          localCoords = coords;\n          if(localCoords[2] + ' +
          u +
          ' < ' +
          t[2] +
          ') {\n            localCoords[2] += ' +
          u +
          ';\n            if(localCoords[1] + ' +
          s +
          ' < ' +
          t[1] +
          ') {\n              localCoords[1] += ' +
          s +
          ';\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / ' +
          i +
          ';\n              c = imod(flatIndex, ' +
          i +
          ');\n              uv = (vec2(c, r) + halfCR) / vec2(' +
          i +
          '.0, ' +
          o +
          '.0);\n              values = ' +
          r.texture2D +
          '(A, uv);\n\n              if(offset == 0) {\n                result[' +
          c +
          '] = values[0];\n              } else if(offset == 1) {\n                result[' +
          c +
          '] = values[1];\n              } else if(offset == 2) {\n                result[' +
          c +
          '] = values[2];\n              } else {\n                result[' +
          c +
          '] = values[3];\n              }\n            }\n          }\n        '
      }
    this.userCode =
      '\n      ' +
      So(t) +
      '\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        ' +
      a +
      '\n\n        ' +
      r.output +
      ' = ' +
      e +
      ';\n      }\n    '
  }
  function bi(t, e, n) {
    this.variableNames = ['real', 'imag']
    var r = e[1]
    ;(this.outputShape = e),
      (e = n ? '2.0 * ' + Math.PI : '-2.0 * ' + Math.PI),
      (n = n ? r + '.0' : '1.0'),
      (this.userCode =
        '\n      const float exponentMultiplier = ' +
        e +
        ';\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ' +
        t +
        '\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(' +
        r +
        ');\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ' +
        r +
        '; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ' +
        n +
        ';\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    ')
  }
  function xi(t, e, n) {
    this.variableNames = ['A', 'indices']
    var r = t.slice()
    ;(r[n] = e),
      (this.outputShape = r),
      (this.rank = r.length),
      (r = No(this.rank)),
      (n = (function (t, e) {
        var n = t.length
        if (4 < n) throw Error('Gather for rank ' + n + ' is not yet supported')
        if (1 === n) return 'int(getIndices(resRC))'
        for (var r = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'], o = [], i = 0; i < t.length; i++)
          i === e ? o.push('int(getIndices(' + r[i] + '))') : o.push('' + r[i])
        return o.join()
      })(t, n)),
      (this.userCode =
        '\n      void main() {\n        ' +
        r +
        ' resRC = getOutputCoords();\n        setOutput(getA(' +
        n +
        '));\n      }\n    ')
  }
  var wi =
      ((Si.prototype.getHeightCoordString = function () {
        return 'NHWC' === this.dataFormat ? 'coords[1]' : 'coords[2]'
      }),
      (Si.prototype.getWidthCoordString = function () {
        return 'NHWC' === this.dataFormat ? 'coords[2]' : 'coords[3]'
      }),
      (Si.prototype.getDepthCoordString = function () {
        return 'NHWC' === this.dataFormat ? 'coords[3]' : 'coords[1]'
      }),
      (Si.prototype.getOutputDepthSize = function () {
        return 'NHWC' === this.dataFormat ? this.outputShape[3] : this.outputShape[1]
      }),
      (Si.prototype.getInputSamplingString = function () {
        return 'NHWC' === this.dataFormat ? 'getX(b, in_h, in_w, in_d)' : 'getX(b, in_d, in_h, in_w)'
      }),
      Si),
    Ci =
      ((Ei.prototype.getCustomSetupFunc = function (n) {
        var r = this
        return function (t, e) {
          null == r.valueLoc && (r.valueLoc = t.getUniformLocationNoThrow(e, 'value')), t.gl.uniform1f(r.valueLoc, n)
        }
      }),
      Ei)
  function Ei(t, e) {
    ;(this.outputShape = []),
      (this.variableNames = ['x']),
      (this.outputShape = t),
      (this.userCode =
        '\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    ')
  }
  function Si(t, e, n) {
    ;(this.variableNames = ['x']),
      (this.outputShape = []),
      (this.outputShape = t),
      (this.blockSize = e),
      (this.dataFormat = n),
      (this.userCode =
        '\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ' +
        this.getHeightCoordString() +
        ';\n      int w = ' +
        this.getWidthCoordString() +
        ';\n      int d = ' +
        this.getDepthCoordString() +
        ';\n\n      int in_h = h / ' +
        e +
        ';\n      int offset_h = imod(h, ' +
        e +
        ');\n      int in_w = w / ' +
        e +
        ';\n      int offset_w = imod(w, ' +
        e +
        ');\n      int offset_d = (offset_h * ' +
        e +
        ' + offset_w) *\n        ' +
        this.getOutputDepthSize() +
        ';\n      int in_d = d + offset_d;\n\n      float result = ' +
        this.getInputSamplingString() +
        ';\n      setOutput(result);\n    }\n  ')
  }
  function _i(t, e, n) {
    ;(this.sliceDim = t),
      (this.strides = e),
      (this.variableNames = ['x', 'indices']),
      (this.outputShape = n),
      (t = No(e.length)),
      (e = No(n.length)),
      (n = 1 < this.sliceDim ? 'strides[j]' : 'strides'),
      (this.userCode =
        '\n        ' +
        t +
        ' strides = ' +
        t +
        '(' +
        this.strides +
        ');\n         void main() {\n          ' +
        e +
        ' coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ' +
        this.sliceDim +
        '; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ' +
        n +
        ';\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      ')
  }
  function Ri(t, e) {
    var n = Co()
    return Zt(
      t,
      e,
      n.version +
        '\n    precision highp float;\n    ' +
        n.attribute +
        ' vec3 clipSpacePos;\n    ' +
        n.attribute +
        ' vec2 uv;\n    ' +
        n.varyingVs +
        ' vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }',
    )
  }
  function Ii(t, e) {
    return se(t, e, new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]))
  }
  function Ai(t, e) {
    return ue(t, e, new Uint16Array([0, 1, 2, 2, 1, 3]))
  }
  function Ni(t, e, n, r, o, i, a) {
    le(n, r)
    var s = ce(t, e),
      u = t.TEXTURE_2D
    return (
      $t(t, e, function () {
        return t.bindTexture(u, s)
      }),
      $t(t, e, function () {
        return t.texParameteri(u, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE)
      }),
      $t(t, e, function () {
        return t.texParameteri(u, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE)
      }),
      $t(t, e, function () {
        return t.texParameteri(u, t.TEXTURE_MIN_FILTER, t.NEAREST)
      }),
      $t(t, e, function () {
        return t.texParameteri(u, t.TEXTURE_MAG_FILTER, t.NEAREST)
      }),
      $t(t, e, function () {
        return t.texImage2D(u, 0, o, n, r, 0, i, a, null)
      }),
      $t(t, e, function () {
        return t.bindTexture(t.TEXTURE_2D, null)
      }),
      s
    )
  }
  function ki(t, e, n, r, o) {
    n = [r, n]
    return Ni(t, e, n[0], n[1], o.internalFormatFloat, o.textureFormatFloat, t.FLOAT)
  }
  function Ti(t, e, n, r, o) {
    n = [r, n]
    return Ni(t, e, n[0], n[1], o.internalFormatHalfFloat, o.textureFormatFloat, o.textureTypeHalfFloat)
  }
  function Di(t, e, n, r, o) {
    n = [r, n]
    return Ni(t, e, n[0], n[1], t.RGBA, t.RGBA, t.UNSIGNED_BYTE)
  }
  function Oi(t, e, n, r, o) {
    r = Kt(n, r)
    return Ni(t, e, r[0], r[1], o.internalFormatPackedFloat, t.RGBA, t.FLOAT)
  }
  function Fi(t, e, n, r, o) {
    r = Kt(n, r)
    return Ni(t, e, r[0], r[1], o.internalFormatPackedHalfFloat, t.RGBA, o.textureTypeHalfFloat)
  }
  function Mi(t, e, n, r) {
    return (
      $t(t, e, function () {
        return t.bindBuffer(t.ARRAY_BUFFER, r)
      }),
      pe(t, e, n, 'clipSpacePos', r, 3, 20, 0) && pe(t, e, n, 'uv', r, 2, 20, 12)
    )
  }
  function Pi(t, e, n, r, o, i, a) {
    var s, u, c
    $t(t, e, function () {
      return t.bindTexture(t.TEXTURE_2D, n)
    }),
      (c =
        i instanceof Uint8Array
          ? ((s = new Uint8Array(r * o * 4)), (u = t.UNSIGNED_BYTE), t.RGBA)
          : ((s = new Float32Array(r * o * 4)), (u = t.FLOAT), a.internalFormatPackedFloat)),
      s.set(i),
      $t(t, e, function () {
        return t.texImage2D(t.TEXTURE_2D, 0, c, r, o, 0, t.RGBA, u, s)
      }),
      $t(t, e, function () {
        return t.bindTexture(t.TEXTURE_2D, null)
      })
  }
  function Bi(t, e, n, r) {
    $t(t, e, function () {
      return t.bindTexture(t.TEXTURE_2D, n)
    }),
      r.data instanceof Uint8Array
        ? $t(t, e, function () {
            return t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, r.width, r.height, 0, t.RGBA, t.UNSIGNED_BYTE, r.data)
          })
        : $t(t, e, function () {
            return t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, r)
          }),
      $t(t, e, function () {
        return t.bindTexture(t.TEXTURE_2D, null)
      })
  }
  function Li(t, e, n, r, o) {
    var i = t.createBuffer()
    $t(t, e, function () {
      return t.bindBuffer(t.PIXEL_PACK_BUFFER, i)
    })
    var a = 16 * n * r
    return (
      $t(t, e, function () {
        return t.bufferData(t.PIXEL_PACK_BUFFER, a, t.STREAM_READ)
      }),
      $t(t, e, function () {
        return t.readPixels(0, 0, r, n, t.RGBA, t.FLOAT, 0)
      }),
      $t(t, e, function () {
        return t.bindBuffer(t.PIXEL_PACK_BUFFER, null)
      }),
      i
    )
  }
  function Wi(t, e, n) {
    n = new Float32Array(n)
    return (
      t.bindBuffer(t.PIXEL_PACK_BUFFER, e),
      t.getBufferSubData(t.PIXEL_PACK_BUFFER, 0, n),
      t.bindBuffer(t.PIXEL_PACK_BUFFER, null),
      n
    )
  }
  function zi(t, e, n, r, o) {
    var i = [r, n],
      a = i[0],
      s = i[1],
      u = new Uint8Array(n * r * 4)
    return (
      $t(t, e, function () {
        return t.readPixels(0, 0, a, s, o.downloadTextureFormat, t.UNSIGNED_BYTE, u)
      }),
      new Float32Array(u.buffer)
    )
  }
  function Gi(t, e, n, r, o, i, a, s) {
    a = new Float32Array((a = Kt(i, a))[0] * a[1] * 4)
    return (
      t.bindBuffer(t.PIXEL_PACK_BUFFER, e),
      t.getBufferSubData(t.PIXEL_PACK_BUFFER, 0, a),
      t.bindBuffer(t.PIXEL_PACK_BUFFER, null),
      a
    )
  }
  function Ui(t, e, n, r) {
    var o = new Float32Array(n * r * 4)
    return (
      $t(t, e, function () {
        return t.readPixels(0, 0, r, n, t.RGBA, t.FLOAT, o)
      }),
      o
    )
  }
  var Vi = Object.freeze({
      createVertexShader: Ri,
      createVertexBuffer: Ii,
      createIndexBuffer: Ai,
      createFloat32MatrixTexture: ki,
      createFloat16MatrixTexture: Ti,
      createUnsignedBytesMatrixTexture: Di,
      createPackedMatrixTexture: Oi,
      createFloat16PackedMatrixTexture: Fi,
      bindVertexProgramAttributeStreams: Mi,
      uploadDenseMatrixToTexture: Pi,
      uploadPixelDataToTexture: Bi,
      createBufferFromOutputTexture: Li,
      downloadFloat32MatrixFromBuffer: Wi,
      downloadByteEncodedFloatMatrixFromOutputTexture: zi,
      downloadPackedMatrixFromBuffer: Gi,
      downloadMatrixFromPackedOutputTexture: Ui,
    }),
    Hi =
      (Object.defineProperty(ji.prototype, 'debug', {
        get: function () {
          return f.getBool('DEBUG')
        },
        enumerable: !0,
        configurable: !0,
      }),
      (ji.prototype.dispose = function () {
        var t,
          e = this
        this.disposed ||
          (null != this.program &&
            console.warn(
              'Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing.',
            ),
          null != this.outputTexture &&
            console.warn(
              'Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.',
            ),
          $t((t = this.gl), this.debug, function () {
            return t.finish()
          }),
          $t(t, this.debug, function () {
            return t.bindFramebuffer(t.FRAMEBUFFER, null)
          }),
          $t(t, this.debug, function () {
            return t.deleteFramebuffer(e.framebuffer)
          }),
          $t(t, this.debug, function () {
            return t.bindBuffer(t.ARRAY_BUFFER, null)
          }),
          $t(t, this.debug, function () {
            return t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, null)
          }),
          $t(t, this.debug, function () {
            return t.deleteBuffer(e.indexBuffer)
          }),
          (this.disposed = !0))
      }),
      (ji.prototype.createFloat32MatrixTexture = function (t, e) {
        return this.throwIfDisposed(), ki(this.gl, this.debug, t, e, this.textureConfig)
      }),
      (ji.prototype.createFloat16MatrixTexture = function (t, e) {
        return this.throwIfDisposed(), Ti(this.gl, this.debug, t, e, this.textureConfig)
      }),
      (ji.prototype.createUnsignedBytesMatrixTexture = function (t, e) {
        return this.throwIfDisposed(), Di(this.gl, this.debug, t, e, this.textureConfig)
      }),
      (ji.prototype.uploadPixelDataToTexture = function (t, e) {
        this.throwIfDisposed(), Bi(this.gl, this.debug, t, e)
      }),
      (ji.prototype.uploadDenseMatrixToTexture = function (t, e, n, r) {
        this.throwIfDisposed(), Pi(this.gl, this.debug, t, e, n, r, this.textureConfig)
      }),
      (ji.prototype.createFloat16PackedMatrixTexture = function (t, e) {
        return this.throwIfDisposed(), Fi(this.gl, this.debug, t, e, this.textureConfig)
      }),
      (ji.prototype.createPackedMatrixTexture = function (t, e) {
        return this.throwIfDisposed(), Oi(this.gl, this.debug, t, e, this.textureConfig)
      }),
      (ji.prototype.deleteMatrixTexture = function (t) {
        var e = this
        this.throwIfDisposed(),
          this.outputTexture === t && (ye(this.gl, this.debug, this.framebuffer), (this.outputTexture = null)),
          $t(this.gl, this.debug, function () {
            return e.gl.deleteTexture(t)
          })
      }),
      (ji.prototype.downloadByteEncodedFloatMatrixFromOutputTexture = function (t, e, n) {
        var r = this
        return this.downloadMatrixDriver(t, function () {
          return zi(r.gl, r.debug, e, n, r.textureConfig)
        })
      }),
      (ji.prototype.downloadPackedMatrixFromBuffer = function (t, e, n, r, o, i) {
        return Gi(this.gl, t, 0, 0, 0, o, i, this.textureConfig)
      }),
      (ji.prototype.downloadFloat32MatrixFromBuffer = function (t, e) {
        return Wi(this.gl, t, e)
      }),
      (ji.prototype.createBufferFromTexture = function (t, e, n) {
        this.bindTextureToFrameBuffer(t)
        n = Li(this.gl, this.debug, e, n, this.textureConfig)
        return this.unbindTextureToFrameBuffer(), n
      }),
      (ji.prototype.createAndWaitForFence = function () {
        var t = this.createFence(this.gl)
        return this.pollFence(t)
      }),
      (ji.prototype.createFence = function (t) {
        var e,
          n,
          r,
          o,
          i = this
        return (
          f.getBool('WEBGL_FENCE_API_ENABLED')
            ? ((o = (r = t).fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE, 0)),
              t.flush(),
              (n = function () {
                var t = r.clientWaitSync(o, 0, 0)
                return t === r.ALREADY_SIGNALED || t === r.CONDITION_SATISFIED
              }),
              (e = o))
            : (n =
                0 < f.getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION')
                  ? ((e = this.beginQuery()),
                    this.endQuery(),
                    function () {
                      return i.isQueryAvailable(e, f.getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'))
                    })
                  : function () {
                      return !0
                    }),
          { query: e, isFencePassed: n }
        )
      }),
      (ji.prototype.downloadMatrixFromPackedTexture = function (t, e, n) {
        var r = this
        return this.downloadMatrixDriver(t, function () {
          return Ui(r.gl, r.debug, e, n)
        })
      }),
      (ji.prototype.createProgram = function (t) {
        this.throwIfDisposed()
        var e = this.gl,
          n = te(e, this.debug, t),
          r = Ri(e, this.debug),
          o = oe(e, this.debug)
        return (
          $t(e, this.debug, function () {
            return e.attachShader(o, r)
          }),
          $t(e, this.debug, function () {
            return e.attachShader(o, n)
          }),
          ie(e, this.debug, o),
          this.debug && ae(e, this.debug, o),
          this.vertexAttrsAreBound ||
            (this.setProgram(o), (this.vertexAttrsAreBound = Mi(e, this.debug, this.program, this.vertexBuffer))),
          o
        )
      }),
      (ji.prototype.deleteProgram = function (t) {
        var e = this
        this.throwIfDisposed(),
          t === this.program && (this.program = null),
          null != t &&
            $t(this.gl, this.debug, function () {
              return e.gl.deleteProgram(t)
            })
      }),
      (ji.prototype.setProgram = function (t) {
        var e = this
        this.throwIfDisposed(),
          (this.program = t),
          null != this.program && this.debug && ae(this.gl, this.debug, this.program),
          $t(this.gl, this.debug, function () {
            return e.gl.useProgram(t)
          })
      }),
      (ji.prototype.getUniformLocation = function (t, e, n) {
        return void 0 === n && (n = !0), this.throwIfDisposed(), n ? fe(this.gl, this.debug, t, e) : ve(this.gl, t, e)
      }),
      (ji.prototype.getAttributeLocation = function (t, e) {
        var n = this
        return (
          this.throwIfDisposed(),
          $t(this.gl, this.debug, function () {
            return n.gl.getAttribLocation(t, e)
          })
        )
      }),
      (ji.prototype.getUniformLocationNoThrow = function (t, e) {
        return this.throwIfDisposed(), this.gl.getUniformLocation(t, e)
      }),
      (ji.prototype.setInputMatrixTexture = function (t, e, n) {
        this.throwIfDisposed(), this.throwIfNoProgram(), me(this.gl, this.debug, this.program, t, e, n)
      }),
      (ji.prototype.setOutputMatrixTexture = function (t, e, n) {
        this.setOutputMatrixTextureDriver(t, n, e)
      }),
      (ji.prototype.setOutputPackedMatrixTexture = function (t, e, n) {
        this.throwIfDisposed()
        ;(e = Kt(e, n)), (n = e[0]), (e = e[1])
        this.setOutputMatrixTextureDriver(t, n, e)
      }),
      (ji.prototype.setOutputMatrixWriteRegion = function (t, e, n, r) {
        this.setOutputMatrixWriteRegionDriver(n, t, r, e)
      }),
      (ji.prototype.setOutputPackedMatrixWriteRegion = function (t, e, n, r) {
        throw new Error('setOutputPackedMatrixWriteRegion not implemented.')
      }),
      (ji.prototype.debugValidate = function () {
        null != this.program && ae(this.gl, this.debug, this.program), be(this.gl)
      }),
      (ji.prototype.executeProgram = function () {
        this.throwIfDisposed(), this.throwIfNoProgram()
        var t = this.gl
        this.debug && this.debugValidate(),
          $t(t, this.debug, function () {
            return t.drawElements(t.TRIANGLES, 6, t.UNSIGNED_SHORT, 0)
          })
      }),
      (ji.prototype.blockUntilAllProgramsCompleted = function () {
        var t = this
        this.throwIfDisposed(),
          $t(this.gl, this.debug, function () {
            return t.gl.finish()
          })
      }),
      (ji.prototype.getQueryTimerExtension = function () {
        return (
          null == this.disjointQueryTimerExtension &&
            (this.disjointQueryTimerExtension = Qt(
              this.gl,
              this.debug,
              2 === f.getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION')
                ? 'EXT_disjoint_timer_query_webgl2'
                : 'EXT_disjoint_timer_query',
            )),
          this.disjointQueryTimerExtension
        )
      }),
      (ji.prototype.getQueryTimerExtensionWebGL2 = function () {
        return this.getQueryTimerExtension()
      }),
      (ji.prototype.getQueryTimerExtensionWebGL1 = function () {
        return this.getQueryTimerExtension()
      }),
      (ji.prototype.beginQuery = function () {
        if (2 === f.getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION')) {
          var t = this.gl,
            e = this.getQueryTimerExtensionWebGL2(),
            n = t.createQuery()
          return t.beginQuery(e.TIME_ELAPSED_EXT, n), n
        }
        ;(e = this.getQueryTimerExtensionWebGL1()), (n = e.createQueryEXT())
        return e.beginQueryEXT(e.TIME_ELAPSED_EXT, n), n
      }),
      (ji.prototype.endQuery = function () {
        var t, e
        2 !== f.getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION')
          ? (e = this.getQueryTimerExtensionWebGL1()).endQueryEXT(e.TIME_ELAPSED_EXT)
          : ((t = this.gl), (e = this.getQueryTimerExtensionWebGL2()), t.endQuery(e.TIME_ELAPSED_EXT))
      }),
      (ji.prototype.waitForQueryAndGetTime = function (n) {
        return x(this, void 0, void 0, function () {
          var e = this
          return w(this, function (t) {
            switch (t.label) {
              case 0:
                return [
                  4,
                  k(function () {
                    return e.disposed || e.isQueryAvailable(n, f.getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'))
                  }),
                ]
              case 1:
                return t.sent(), [2, this.getQueryTime(n, f.getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'))]
            }
          })
        })
      }),
      (ji.prototype.getQueryTime = function (t, e) {
        if (0 === e) return null
        if (2 === e) {
          var n = this.gl
          return n.getQueryParameter(t, n.QUERY_RESULT) / 1e6
        }
        n = this.getQueryTimerExtensionWebGL1()
        return n.getQueryObjectEXT(t, n.QUERY_RESULT_EXT) / 1e6
      }),
      (ji.prototype.isQueryAvailable = function (t, e) {
        if (0 === e) return !0
        if (2 !== e)
          return (
            (r = (n = this.getQueryTimerExtensionWebGL1()).getQueryObjectEXT(t, n.QUERY_RESULT_AVAILABLE_EXT)),
            null == this.disjoint && (this.disjoint = this.gl.getParameter(n.GPU_DISJOINT_EXT)),
            r && !this.disjoint
          )
        var e = this.gl,
          n = this.getQueryTimerExtensionWebGL2(),
          r = e.getQueryParameter(t, e.QUERY_RESULT_AVAILABLE)
        return null == this.disjoint && (this.disjoint = this.gl.getParameter(n.GPU_DISJOINT_EXT)), r && !this.disjoint
      }),
      (ji.prototype.pollFence = function (e) {
        var n = this
        return new Promise(function (t) {
          n.addItemToPoll(
            function () {
              return e.isFencePassed()
            },
            function () {
              return t()
            },
          )
        })
      }),
      (ji.prototype.pollItems = function () {
        for (
          var t = (function (t) {
              for (var e = 0; e < t.length && t[e](); ++e);
              return e - 1
            })(
              this.itemsToPoll.map(function (t) {
                return t.isDoneFn
              }),
            ),
            e = 0;
          e <= t;
          ++e
        )
          (0, this.itemsToPoll[e].resolveFn)()
        this.itemsToPoll = this.itemsToPoll.slice(t + 1)
      }),
      (ji.prototype.addItemToPoll = function (t, e) {
        var n = this
        this.itemsToPoll.push({ isDoneFn: t, resolveFn: e }),
          1 < this.itemsToPoll.length ||
            k(function () {
              return n.pollItems(), 0 === n.itemsToPoll.length
            })
      }),
      (ji.prototype.bindTextureToFrameBuffer = function (t) {
        this.throwIfDisposed(), ge(this.gl, this.debug, t, this.framebuffer), this.debug && be(this.gl)
      }),
      (ji.prototype.unbindTextureToFrameBuffer = function () {
        null != this.outputTexture
          ? (ge(this.gl, this.debug, this.outputTexture, this.framebuffer), this.debug && be(this.gl))
          : ye(this.gl, this.debug, this.framebuffer)
      }),
      (ji.prototype.downloadMatrixDriver = function (t, e) {
        this.bindTextureToFrameBuffer(t)
        e = e()
        return this.unbindTextureToFrameBuffer(), e
      }),
      (ji.prototype.setOutputMatrixTextureDriver = function (t, e, n) {
        this.throwIfDisposed()
        var r = this.gl
        ge(r, this.debug, t, this.framebuffer),
          this.debug && be(r),
          (this.outputTexture = t),
          $t(r, this.debug, function () {
            return r.viewport(0, 0, e, n)
          }),
          $t(r, this.debug, function () {
            return r.scissor(0, 0, e, n)
          })
      }),
      (ji.prototype.setOutputMatrixWriteRegionDriver = function (t, e, n, r) {
        var o = this
        this.throwIfDisposed(),
          $t(this.gl, this.debug, function () {
            return o.gl.scissor(t, e, n, r)
          })
      }),
      (ji.prototype.throwIfDisposed = function () {
        if (this.disposed) throw new Error('Attempted to use disposed GPGPUContext.')
      }),
      (ji.prototype.throwIfNoProgram = function () {
        if (null == this.program) throw new Error('No GPU program is currently set.')
      }),
      ji)
  function ji(t) {
    ;(this.outputTexture = null),
      (this.program = null),
      (this.disposed = !1),
      (this.vertexAttrsAreBound = !1),
      (this.itemsToPoll = [])
    var e = f.getNumber('WEBGL_VERSION')
    null != t ? Ht(e, (this.gl = t)) : (this.gl = jt(e))
    e = 'WEBGL_color_buffer_float'
    if (1 === f.getNumber('WEBGL_VERSION')) {
      if (((this.textureFloatExtension = Qt(this.gl, this.debug, 'OES_texture_float')), De(this.gl, 'OES_texture_half_float')))
        this.textureHalfFloatExtension = Qt(this.gl, this.debug, 'OES_texture_half_float')
      else if (f.get('WEBGL_FORCE_F16_TEXTURES'))
        throw new Error(
          'GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.',
        )
      if (((this.colorBufferFloatExtension = this.gl.getExtension(e)), De(this.gl, 'EXT_color_buffer_half_float')))
        this.colorBufferHalfFloatExtension = Qt(this.gl, this.debug, 'EXT_color_buffer_half_float')
      else if (f.get('WEBGL_FORCE_F16_TEXTURES'))
        throw new Error(
          'GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.',
        )
    } else if (((e = 'EXT_color_buffer_float'), De(this.gl, e))) this.colorBufferFloatExtension = this.gl.getExtension(e)
    else {
      if (!De(this.gl, 'EXT_color_buffer_half_float')) throw new Error('GL context does not support color renderable floats')
      this.colorBufferHalfFloatExtension = this.gl.getExtension('EXT_color_buffer_half_float')
    }
    ;(this.vertexBuffer = Ii(this.gl, this.debug)),
      (this.indexBuffer = Ai(this.gl, this.debug)),
      (this.framebuffer = he(this.gl, this.debug)),
      (this.textureConfig = Xt(this.gl, this.textureHalfFloatExtension))
  }
  function qi(t, o) {
    if (t.length !== o.length)
      throw Error('Binary was compiled with ' + t.length + ' inputs, but was executed with ' + o.length + ' inputs')
    t.forEach(function (t, e) {
      var n = t.logicalShape,
        r = o[e],
        e = r.shape
      if (!S(n, e))
        throw Error(
          'Binary was compiled with different shapes than the current args. Shapes ' + n + ' and ' + e + ' must match',
        )
      if (!t.isUniform || !r.isUniform) {
        ;(t = t.texShape), (r = r.isUniform ? null : r.texData.texShape)
        if (!S(t, r))
          throw Error(
            'Binary was compiled with different texture shapes than the current args. Shape ' + t + ' and ' + r + ' must match',
          )
      }
    })
  }
  function Ki(t, e, n) {
    ;(this.variableNames = ['A']), (this.packedInputs = !0), (this.packedOutput = !0), (this.outputShape = t)
    for (
      var r = n.filterWidth,
        o = n.inChannels,
        i = n.strideWidth,
        a = n.strideHeight,
        s = n.padInfo,
        u = n.outWidth,
        c = n.dilationWidth,
        l = n.dilationHeight,
        n = n.dataFormat,
        h = s.left,
        p = s.top,
        d = o * r,
        r = Co(),
        f = 'channelsLast' === n,
        v = f ? 0 : 1,
        m = f ? 1 : 2,
        g = '',
        y = 0;
      y <= 1;
      y++
    )
      for (var b = 0; b <= 1; b++)
        g +=
          '\n          blockIndex = rc.y + ' +
          b +
          ';\n          pos = rc.x + ' +
          y +
          ';\n\n          if(blockIndex < ' +
          t[1] +
          ' && pos < ' +
          t[0] +
          ') {\n            offsetY = int(blockIndex / (' +
          u +
          ')) * ' +
          a +
          ' - ' +
          p +
          ';\n            d0 = offsetY + ' +
          l +
          ' * (pos / ' +
          d +
          ');\n\n            if(d0 < ' +
          e[v] +
          ' && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), ' +
          u +
          '.) * ' +
          i +
          '. - ' +
          h +
          '.);\n              d1 = offsetX + ' +
          c +
          ' * (int(mod(float(pos), ' +
          d +
          '.) / ' +
          o +
          '.));\n\n              if(d1 < ' +
          e[m] +
          ' && d1 >= 0) {\n\n                ch = int(mod(float(pos), ' +
          o +
          '.));\n\n                if (' +
          f +
          ') {\n                  innerDims = vec2(d1, ch);\n                  result[' +
          (2 * y + b) +
          '] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[' +
          (2 * y + b) +
          '] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        '
    this.userCode =
      '\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ' +
      g +
      '\n\n        ' +
      r.output +
      ' = result;\n      }\n    '
  }
  function Xi(t, e, n, r, o) {
    ;(this.variableNames = ['x']), (this.outputShape = [])
    var i = e,
      e = t[3] - 1
    ;(this.outputShape = t),
      (r = 'float(' + n + ') + float(' + r + ') * sum'),
      (o = 0.5 === o ? 'inversesqrt(' + r + ')' : 1 === o ? '1.0/(' + r + ')' : 'exp(log(' + r + ') * float(-' + o + '));'),
      (this.userCode =
        '\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -' +
        i +
        '; j <= ' +
        i +
        '; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ' +
        e +
        ') {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ' +
        o +
        ';\n        setOutput(val);\n      }\n    ')
  }
  function $i(t, e, n, r, o) {
    ;(this.variableNames = ['inputImage', 'outputImage', 'dy']),
      (this.outputShape = []),
      (this.outputShape = t),
      (this.depth = t[3]),
      (this.depthRadius = e),
      (this.bias = n),
      (this.alpha = r),
      (this.beta = o),
      (this.userCode =
        '\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ' +
        this.depth +
        '; ++d) {\n          int depthBegin = int(max(0.0, float(d - ' +
        e +
        ')));\n          int depthEnd = int(min(float(' +
        this.depth +
        '),\n              float(d + ' +
        e +
        ' + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ' +
        this.depth +
        ';\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(' +
        r +
        ') * norm + float(' +
        n +
        ');\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(' +
        r +
        ')\n                * float(' +
        o +
        ')\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ' +
        o +
        ');\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    ')
  }
  function Yi(t, e, n, r, o) {
    ;(this.variableNames = ['x']), (this.outputShape = []), (this.packedInputs = !0), (this.packedOutput = !0)
    var i = e,
      e = t[3] - 1
    ;(this.outputShape = t),
      (r = 'float(' + n + ') + float(' + r + ') * sum'),
      (o = 0.5 === o ? 'inversesqrt(' + r + ')' : 1 === o ? '1.0/(' + r + ')' : 'exp(log(' + r + ') * float(-' + o + '));'),
      (this.userCode =
        '\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ' +
        this.outputShape[3] +
        ';\n        bool hasNextRow = c < ' +
        this.outputShape[2] +
        ';\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ' +
        i +
        ';\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ' +
        i +
        '; j <= ' +
        i +
        '; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(' +
        e +
        '));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ' +
        o +
        ';\n        setOutput(result);\n      }\n    ')
  }
  function Ji(t) {
    ;(this.variableNames = ['dy', 'maxPos']), (this.outputShape = t.inShape)
    var e = t.strideHeight,
      n = t.strideWidth,
      r = t.dilationHeight,
      o = t.effectiveFilterHeight,
      i = t.effectiveFilterWidth,
      a = o - 1 - t.padInfo.top,
      s = i - 1 - t.padInfo.left,
      u = o * i - 1
    this.userCode =
      '\n      const ivec2 pads = ivec2(' +
      a +
      ', ' +
      s +
      ');\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ' +
      o +
      ';\n          wR += ' +
      r +
      ') {\n          float dyR = float(dyRCorner + wR) / ' +
      e +
      '.0;\n\n          if (dyR < 0.0 || dyR >= ' +
      t.outHeight +
      '.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ' +
      i +
      '; wC++) {\n            float dyC = float(dyCCorner + wC) / ' +
      n +
      '.0;\n\n            if (dyC < 0.0 || dyC >= ' +
      t.outWidth +
      '.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ' +
      u +
      ' - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ' +
      i +
      ' + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    '
  }
  function Qi(t) {
    ;(this.variableNames = ['dy', 'maxPos']), (this.outputShape = t.inShape)
    var e = t.strideDepth,
      n = t.strideHeight,
      r = t.strideWidth,
      o = t.dilationDepth,
      i = t.dilationHeight,
      a = t.dilationWidth,
      s = t.effectiveFilterDepth,
      u = t.effectiveFilterHeight,
      c = t.effectiveFilterWidth,
      l = s - 1 - t.padInfo.front,
      h = u - 1 - t.padInfo.top,
      p = c - 1 - t.padInfo.left,
      d = s * u * c - 1
    this.userCode =
      '\n      const ivec3 pads = ivec3(' +
      l +
      ', ' +
      h +
      ', ' +
      p +
      ');\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ' +
      s +
      ';\n           wD += ' +
      o +
      ') {\n          float dyD = float(dyDCorner + wD) / ' +
      e +
      '.0;\n\n          if (dyD < 0.0 || dyD >= ' +
      t.outDepth +
      '.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ' +
      u +
      ';\n              wR += ' +
      i +
      ') {\n            float dyR = float(dyRCorner + wR) / ' +
      n +
      '.0;\n\n            if (dyR < 0.0 || dyR >= ' +
      t.outHeight +
      '.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ' +
      c +
      ';\n                wC += ' +
      a +
      ') {\n              float dyC = float(dyCCorner + wC) / ' +
      r +
      '.0;\n\n              if (dyC < 0.0 || dyC >= ' +
      t.outWidth +
      '.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ' +
      d +
      ' -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ' +
      u +
      ' * ' +
      c +
      ' +\n                  wR * ' +
      c +
      ' + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    '
  }
  function Zi(t, e, n, r, o, i, a) {
    void 0 === n && (n = !1),
      void 0 === r && (r = !1),
      void 0 === o && (o = !1),
      void 0 === i && (i = null),
      void 0 === a && (a = !1),
      (this.variableNames = ['matrixA', 'matrixB']),
      (this.packedInputs = !0),
      (this.packedOutput = !0),
      (this.outputShape = e)
    var s = n ? t[1] : t[2],
      u = Math.ceil(s / 2),
      c = n ? 'i * 2, rc.y' : 'rc.y, i * 2',
      e = r ? 'rc.z, i * 2' : 'i * 2, rc.z',
      t = n ? ['a.xxyy', 'a.zzww'] : ['a.xxzz', 'a.yyww'],
      s = r ? ['b.xzxz', 'b.ywyw'] : ['b.xyxy', 'b.zwzw'],
      n = '',
      r = ''
    i &&
      ((n = a
        ? 'vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ' +
          i +
          '\n        }'
        : 'vec4 activation(vec4 x) {\n          ' + i + '\n        }'),
      (r = 'result = activation(result);')),
      (i = o ? 'result += getBiasAtOutCoords();' : ''),
      o && this.variableNames.push('bias'),
      a && this.variableNames.push('preluActivationWeights'),
      (this.userCode =
        '\n      ' +
        n +
        '\n\n      const float sharedDimension = ' +
        u +
        '.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ' +
        u +
        '; i++) {\n          vec4 a = getMatrixA(rc.x, ' +
        c +
        ');\n          vec4 b = getMatrixB(rc.x, ' +
        e +
        ');\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (' +
        t[0] +
        ' * ' +
        s[0] +
        ');\n          result += (' +
        t[1] +
        ' * ' +
        s[1] +
        ');\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ' +
        i +
        '\n\n        ' +
        r +
        '\n\n        setOutput(result);\n      }\n    ')
  }
  function ta(t, e, n, r) {
    ;(this.variableNames = ['indices']),
      (this.outputShape = [t, e]),
      (this.userCode =
        '\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(' +
        r +
        '), float(' +
        n +
        '),\n                      float(index == coords.y)));\n      }\n    ')
  }
  function ea(t) {
    ;(this.variableNames = ['A']), (this.packedInputs = !1), (this.packedOutput = !0)
    var r,
      e,
      n,
      o,
      i,
      a,
      s = (this.outputShape = t).length
    0 === s
      ? (this.userCode = '\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ')
      : ((r = wo('rc', s)),
        (e = No(s)),
        (n = (function (t, e, n) {
          if (1 === t) return 'rc > ' + e[0]
          for (var r = '', o = t - 2; o < t; o++) (r += n[o] + ' >= ' + e[o]), o < t - 1 && (r += '||')
          return r
        })(s, t, r)),
        (o = (function (t, e) {
          if (1 === s) return ''
          var n = r.slice(-2)
          return (
            '\n    int r = ' +
            n[0] +
            ';\n    int c = ' +
            n[1] +
            ';\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= ' +
            t +
            ';\n    bool rEdge = rp1 >= ' +
            e +
            ';\n  '
          )
        })(t[t.length - 1], t[t.length - 2])),
        (a = (i = t).length),
        (t = (function (t, e) {
          for (var n = [], r = 0; r <= 1; r++)
            for (var o = 0; o <= 1; o++) {
              for (var i = (0 === r ? 'r' : 'rp1') + ', ' + (0 === o ? 'c' : 'cp1'), a = 2; a < t; a++)
                i = e[e.length - 1 - a] + ',' + i
              n.push(i)
            }
          return n
        })(a, r)),
        (t =
          1 === a
            ? 'getA(rc),\n            rc + 1 >= ' + i[0] + ' ? 0. : getA(rc + 1),\n            0, 0'
            : 'getA(' +
              t[0] +
              '),\n          cEdge ? 0. : getA(' +
              t[1] +
              '),\n          rEdge ? 0. : getA(' +
              t[2] +
              '),\n          rEdge || cEdge ? 0. : getA(' +
              t[3] +
              ')'),
        (this.userCode =
          '\n        void main() {\n          ' +
          e +
          ' rc = getOutputCoords();\n\n          if(' +
          n +
          ') {\n            setOutput(vec4(0));\n          } else {\n            ' +
          o +
          '\n\n            setOutput(vec4(' +
          t +
          '));\n          }\n        }\n      '))
  }
  var na =
    ((ra.prototype.getCustomSetupFunc = function (n) {
      var r = this
      return function (t, e) {
        null == r.seedLoc && (r.seedLoc = t.getUniformLocation(e, 'seed')), t.gl.uniform1f(r.seedLoc, n)
      }
    }),
    ra)
  function ra(t, e, n) {
    ;(this.variableNames = ['probs']),
      (this.outputShape = [t, n]),
      (this.userCode =
        '\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ' +
        (e - 1) +
        '; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(' +
        (e - 1) +
        '));\n      }\n    ')
  }
  function oa(n, t, e) {
    ;(this.variableNames = ['x']),
      (this.outputShape = t.map(function (t, e) {
        return t[0] + n[e] + t[1]
      }))
    var r = n.length,
      o = No(r),
      i = t
        .map(function (t) {
          return t[0]
        })
        .join(','),
      a = t
        .map(function (t, e) {
          return t[0] + n[e]
        })
        .join(','),
      t = ['coords[0]', 'coords[1]', 'coords[2]', 'coords[3]'].slice(0, r)
    this.userCode =
      1 !== r
        ? '\n      ' +
          o +
          ' start = ' +
          o +
          '(' +
          i +
          ');\n      ' +
          o +
          ' end = ' +
          o +
          '(' +
          a +
          ');\n\n      void main() {\n        ' +
          o +
          ' outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float(' +
          e +
          '));\n        } else {\n          ' +
          o +
          ' coords = outC - start;\n          setOutput(getX(' +
          t +
          '));\n        }\n      }\n    '
        : '\n        int start = ' +
          i +
          ';\n        int end = ' +
          a +
          ';\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float(' +
          e +
          '));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      '
  }
  function ia(n, t, e) {
    ;(this.variableNames = ['x']),
      (this.packedInputs = !0),
      (this.packedOutput = !0),
      (this.outputShape = t.map(function (t, e) {
        return t[0] + n[e] + t[1]
      }))
    for (
      var r = n.length,
        o = No(r),
        i = t
          .map(function (t) {
            return t[0]
          })
          .join(','),
        a = t
          .map(function (t, e) {
            return t[0] + n[e]
          })
          .join(','),
        s = wo('rc', r),
        u = wo('source', r),
        t = s[r - 1] + ' < ' + this.outputShape[r - 1],
        c = 1 === r ? 'source' : 'vec2(' + u.slice(-2).join() + ')',
        l = [
          o + ' rc = outputLoc;',
          s[r - 1] + ' += 1;\n       if(' + t + ') {\n      ',
          1 === r
            ? ''
            : '}\n       rc = outputLoc;\n       ' +
              s[r - 2] +
              ' += 1;\n       if(' +
              s[r - 2] +
              ' < ' +
              this.outputShape[r - 2] +
              ') {',
          1 === r ? '' : '  ' + s[r - 1] + ' += 1;\n         if(' + t + ') {',
        ],
        h = 1 === r ? 'rc < start || rc >= end' : 'any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))',
        p = '',
        d = 0,
        f = 1 === r ? 2 : 4;
      d < f;
      d++
    )
      p +=
        '\n        ' +
        l[d] +
        '\n        if (' +
        h +
        ') {\n          result[' +
        d +
        '] = float(' +
        e +
        ');\n        } else {\n          ' +
        o +
        ' source = rc - start;\n          result[' +
        d +
        '] = getChannel(getX(' +
        u.join() +
        '), ' +
        c +
        ');\n        }\n      '
    ;(p += 1 === r ? '} ' : '}}'),
      (this.userCode =
        '\n      const ' +
        o +
        ' start = ' +
        o +
        '(' +
        i +
        ');\n      const ' +
        o +
        ' end = ' +
        o +
        '(' +
        a +
        ');\n\n      void main() {\n        ' +
        o +
        ' outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ' +
        p +
        '\n        setOutput(result);\n      }\n    ')
  }
  function aa(t, e, n) {
    if (((this.variableNames = ['x']), 'avg' === e && n)) throw new Error('Cannot compute positions for average pool.')
    var r = t.filterWidth,
      o = t.strideHeight,
      i = t.strideWidth,
      a = t.dilationHeight,
      s = t.dilationWidth,
      u = t.effectiveFilterHeight,
      c = t.effectiveFilterWidth,
      l = t.padInfo.top,
      h = t.padInfo.left
    this.outputShape = t.outShape
    var p = 'avg' === e,
      d = p ? '0.0' : '-1.0 / 1e-20'
    n
      ? (this.userCode =
          '\n        const ivec2 strides = ivec2(' +
          o +
          ', ' +
          i +
          ');\n        const ivec2 pads = ivec2(' +
          l +
          ', ' +
          h +
          ');\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ' +
          u +
          ';\n              wR += ' +
          a +
          ') {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ' +
          t.inHeight +
          ') {\n              continue;\n            }\n\n            for (int wC = 0; wC < ' +
          c +
          ';\n                wC += ' +
          s +
          ') {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ' +
          t.inWidth +
          ') {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = wR * ' +
          c +
          ' + wC;\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ')
      : ((c =
          'avg' === e
            ? 'avgValue / count'
            : e + '(' + e + '(' + e + '(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])'),
        (e = 4 * Math.floor(r / 4)),
        (r = r % 4),
        (p =
          '\n      if (' +
          p +
          ') {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    '),
        (this.userCode =
          '\n      const ivec2 strides = ivec2(' +
          o +
          ', ' +
          i +
          ');\n      const ivec2 pads = ivec2(' +
          l +
          ', ' +
          h +
          ');\n      const float initializationValue = ' +
          d +
          ';\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ' +
          t.inWidth +
          ') {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(' +
          d +
          ');\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ' +
          u +
          ';\n            wR += ' +
          a +
          ') {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ' +
          t.inHeight +
          ') {\n            continue;\n          }\n\n          for (int wC = 0; wC < ' +
          e +
          '; wC += 4) {\n            int xC = xCCorner + wC * ' +
          s +
          ';\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ' +
          s +
          ', d),\n              getValue(batch, xR, xC + 2 * ' +
          s +
          ', d),\n              getValue(batch, xR, xC + 3 * ' +
          s +
          ', d)\n            );\n\n            ' +
          p +
          '\n          }\n\n          int xC = xCCorner + ' +
          e +
          ';\n          if (' +
          (1 == r) +
          ') {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ' +
          p +
          '\n          } else if (' +
          (2 == r) +
          ') {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ' +
          s +
          ', d),\n              initializationValue,\n              initializationValue\n            );\n\n            ' +
          p +
          '\n          } else if (' +
          (3 == r) +
          ') {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ' +
          s +
          ', d),\n              getValue(batch, xR, xC + 2 * ' +
          s +
          ', d),\n              initializationValue\n            );\n\n            ' +
          p +
          '\n          }\n        }\n        setOutput(' +
          c +
          ');\n      }\n    '))
  }
  function sa(t, e, n) {
    if (((this.variableNames = ['x']), 'avg' === e && n)) throw new Error('Cannot compute positions for average pool.')
    var r = t.filterWidth,
      o = t.strideDepth,
      i = t.strideHeight,
      a = t.strideWidth,
      s = t.dilationDepth,
      u = t.dilationHeight,
      c = t.dilationWidth,
      l = t.effectiveFilterDepth,
      h = t.effectiveFilterHeight,
      p = t.effectiveFilterWidth,
      d = t.padInfo.front,
      f = t.padInfo.top,
      v = t.padInfo.left
    this.outputShape = t.outShape
    var m = 'avg' === e,
      g = m ? '0.0' : '-1.0 / 1e-20'
    n
      ? (this.userCode =
          '\n        const ivec3 strides =\n            ivec3(' +
          o +
          ', ' +
          i +
          ', ' +
          a +
          ');\n        const ivec3 pads = ivec3(' +
          d +
          ', ' +
          f +
          ', ' +
          v +
          ');\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ' +
          l +
          ';\n              wD += ' +
          s +
          ') {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ' +
          t.inDepth +
          ') {\n              continue;\n            }\n\n            for (int wR = 0; wR < ' +
          h +
          ';\n                wR += ' +
          u +
          ') {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ' +
          t.inHeight +
          ') {\n                continue;\n              }\n\n              for (int wC = 0; wC < ' +
          p +
          ';\n                  wC += ' +
          c +
          ') {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ' +
          t.inWidth +
          ') {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition =\n                      wD * ' +
          h +
          ' * ' +
          p +
          ' +\n                      wR * ' +
          p +
          ' + wC;;\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ')
      : ((p =
          'avg' === e
            ? 'avgValue / count'
            : e + '(' + e + '(' + e + '(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])'),
        (e = 4 * Math.floor(r / 4)),
        (r = r % 4),
        (m =
          '\n      if (' +
          m +
          ') {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    '),
        (this.userCode =
          '\n      const ivec3 strides =\n        ivec3(' +
          o +
          ', ' +
          i +
          ', ' +
          a +
          ');\n      const ivec3 pads = ivec3(' +
          d +
          ', ' +
          f +
          ', ' +
          v +
          ');\n      const float initializationValue = ' +
          g +
          ';\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ' +
          t.inWidth +
          ') {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(' +
          g +
          ');\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ' +
          l +
          ';\n            wD += ' +
          s +
          ') {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ' +
          t.inDepth +
          ') {\n            continue;\n          }\n\n          for (int wR = 0; wR < ' +
          h +
          ';\n            wR += ' +
          u +
          ') {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ' +
          t.inHeight +
          ') {\n              continue;\n            }\n\n            for (int wC = 0; wC < ' +
          e +
          '; wC += 4) {\n              int xC = xCCorner + wC * ' +
          c +
          ';\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ' +
          c +
          ', ch),\n                getValue(batch, xD, xR, xC + 2 * ' +
          c +
          ', ch),\n                getValue(batch, xD, xR, xC + 3 * ' +
          c +
          ', ch)\n              );\n\n              ' +
          m +
          '\n            }\n\n            int xC = xCCorner + ' +
          e +
          ';\n            if (' +
          (1 == r) +
          ') {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ' +
          m +
          '\n            } else if (' +
          (2 == r) +
          ') {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ' +
          c +
          ', ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ' +
          m +
          '\n            } else if (' +
          (3 == r) +
          ') {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ' +
          c +
          ', ch),\n                getValue(batch, xD, xR, xC + 2 * ' +
          c +
          ', ch),\n                initializationValue\n              );\n\n              ' +
          m +
          '\n            }\n          }\n          setOutput(' +
          p +
          ');\n        }\n      }\n    '))
  }
  function ua(t, e) {
    this.variableNames = ['x']
    var n = t.windowSize,
      r = t.batchSize,
      o = t.inSize,
      i = Math.ceil(o / n)
    this.outputShape = [r, i]
    var a = '0.0',
      s = ''
    'prod' === e
      ? (a = '1.0')
      : 'min' === e
      ? ((a = '1.0 / 1e-20'), (s = 'min'))
      : 'max' === e && ((a = '-1.0 / 1e-20'), (s = 'max'))
    var u = e + '(' + e + '(' + e + '(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])'
    'sum' === e
      ? (u = 'sumValue')
      : 'prod' === e
      ? (u = 'prodValue')
      : 'all' === e
      ? (u = 'allValue')
      : 'any' === e && (u = 'anyValue'),
      (t = 4 * Math.floor(n / 4)),
      (r = n % 4),
      (i =
        '\n      if (' +
        ('sum' === e) +
        ') {\n        sumValue += dot(values, ones);\n      } else if (' +
        ('prod' === e) +
        ') {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ' +
        s +
        '(values, minMaxValue);\n      }\n    '),
      (s = 'vec4'),
      'all' === e
        ? ((a = '1.0'),
          (i =
            '\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      '),
          (s = 'bvec4'))
        : 'any' === e &&
          ((a = '0.0'),
          (i =
            '\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      '),
          (s = 'bvec4')),
      (o =
        0 < o % n
          ? '\n        if (inIdx < 0 || inIdx >= ' + o + ') {\n          return initializationValue;\n        }\n      '
          : ''),
      (this.userCode =
        '\n      const float initializationValue = ' +
        a +
        ';\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ' +
        o +
        '\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ' +
        n +
        ';\n\n        vec4 minMaxValue = vec4(' +
        a +
        ');\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ' +
        t +
        '; i += 4) {\n          int inIdx = inOffset + i;\n          ' +
        s +
        ' values = ' +
        s +
        '(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ' +
        i +
        '\n        }\n\n        int inIdx = inOffset + ' +
        t +
        ';\n        if (' +
        (1 == r) +
        ') {\n          ' +
        s +
        ' values = ' +
        s +
        '(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ' +
        i +
        '\n        } else if (' +
        (2 == r) +
        ') {\n          ' +
        s +
        ' values = ' +
        s +
        '(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ' +
        i +
        '\n        } else if (' +
        (3 == r) +
        ') {\n          ' +
        s +
        ' values = ' +
        s +
        '(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ' +
        i +
        '\n        }\n        setOutput(' +
        u +
        ');\n      }\n    ')
  }
  function ca(t, e) {
    ;(this.variableNames = ['A']), (this.packedInputs = !0), (this.packedOutput = !0), (this.outputShape = t)
    for (var n = '', r = 0; r < 4; r++) {
      var o = 'thisRC = rc;'
      r % 2 == 1 && (o += 'thisRC.z += 1;'),
        1 < r && (o += 'thisRC.y += 1;'),
        (n +=
          '\n        ' +
          o +
          '\n        ' +
          (0 < r ? 'if(thisRC.y < rows && thisRC.z < cols){' : '') +
          '\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[' +
          r +
          '] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ' +
          (0 < r ? '}' : '') +
          '\n      ')
    }
    this.userCode =
      '\n      \n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ' +
      Eo(['r', 'c', 'd'], e) +
      '\n      return ivec3(r, c, d);\n    }\n  \n      ' +
      So(t) +
      '\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ' +
      t[1] +
      ';\n        int cols = ' +
      t[2] +
      ';\n\n        ' +
      n +
      '\n\n        setOutput(result);\n      }\n    '
  }
  function la(t, e, n) {
    ;(this.variableNames = ['dy']), (this.outputShape = []), (this.outputShape = e.shape)
    var r = (s = e.shape)[1],
      o = s[2],
      i = (u = t.shape)[1],
      a = u[2],
      s = (c = [n && 1 < i ? r - 1 : r, n && 1 < a ? o - 1 : o])[0] / (e = [n && 1 < i ? i - 1 : i, n && 1 < a ? a - 1 : a])[0],
      t = c[1] / e[1],
      u = 1 / s,
      n = 1 / t,
      c = 2 * Math.ceil(u) + 2,
      e = 2 * Math.ceil(n) + 2
    this.userCode =
      '\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(' +
      s +
      ');\n        const float widthScale = float(' +
      t +
      ');\n\n        const float invHeightScale = float(' +
      u +
      ');\n        const float invWidthScale = float(' +
      n +
      ');\n\n        const int winHeight = int(' +
      c +
      ');\n        const int winWidth = int(' +
      e +
      ');\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ' +
      i +
      ') {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ' +
      a +
      ') {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ' +
      (r - 1) +
      '.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ' +
      (o - 1) +
      '.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    '
  }
  function ha(t, e, n, r) {
    ;(this.variableNames = ['A']), (this.outputShape = [])
    var o = t[0],
      i = t[1],
      a = t[2],
      t = t[3]
    ;(this.outputShape = [o, e, n, t]),
      (t = [r && 1 < e ? i - 1 : i, r && 1 < n ? a - 1 : a]),
      (n = [r && 1 < e ? e - 1 : e, r && 1 < n ? n - 1 : n]),
      (this.userCode =
        '\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ' +
        t[0] / n[0] +
        ',\n          ' +
        t[1] / n[1] +
        ');\n      const vec2 inputShapeRC = vec2(' +
        i +
        '.0, ' +
        a +
        '.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    ')
  }
  function pa(t, e, n, r) {
    ;(this.variableNames = ['A']), (this.packedInputs = !0), (this.packedOutput = !0), (this.outputShape = [])
    var o = t[0],
      i = t[1],
      a = t[2],
      t = t[3]
    ;(this.outputShape = [o, e, n, t]),
      (o = [r && 1 < e ? i - 1 : i, r && 1 < n ? a - 1 : a]),
      (r = [r && 1 < e ? e - 1 : e, r && 1 < n ? n - 1 : n]),
      (this.userCode =
        '\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ' +
        o[0] / r[0] +
        ',\n          ' +
        o[1] / r[1] +
        ',\n          ' +
        o[1] / r[1] +
        ');\n      const vec3 inputShapeRC = vec3(' +
        i +
        '.0, ' +
        a +
        '.0,\n                                     ' +
        a +
        '.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = vec3(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(sourceFracIndexRC);\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ' +
        (t - 1) +
        ';\n        bool hasNextRow = coords.z < ' +
        (n - 1) +
        ';\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    ')
  }
  function da(t, e, n) {
    ;(this.variableNames = ['dy']), (this.outputShape = []), (this.outputShape = e.shape)
    var r = (h = e.shape)[1],
      o = h[2],
      i = (p = t.shape)[1],
      a = p[2],
      s = [n && 1 < i ? r - 1 : r, n && 1 < a ? o - 1 : o],
      u = [n && 1 < i ? i - 1 : i, n && 1 < a ? a - 1 : a],
      c = s[0] / u[0],
      l = s[1] / u[1],
      e = 1 / c,
      h = 1 / l,
      t = 2 * Math.ceil(e) + 2,
      p = 2 * Math.ceil(h) + 2
    this.userCode =
      '\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(' +
      c +
      ');\n        const float widthScale = float(' +
      l +
      ');\n\n        const float invHeightScale = float(' +
      e +
      ');\n        const float invWidthScale = float(' +
      h +
      ');\n\n        const int winHeight = int(' +
      t +
      ');\n        const int winWidth = int(' +
      p +
      ');\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ' +
      i +
      ') {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ' +
      a +
      ') {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(' +
      s[0] +
      ') *\n                (float(dyR) / float(' +
      u[0] +
      '));\n\n            float sourceFracCol =\n                float(' +
      s[1] +
      ') *\n                  (float(dyC) / float(' +
      u[1] +
      '));\n\n            int sourceNearestRow = int(min(\n                float(int(' +
      r +
      ') - 1),\n                ' +
      n +
      ' ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(' +
      o +
      ') - 1),\n                ' +
      n +
      ' ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    '
  }
  function fa(t, e, n, r) {
    ;(this.variableNames = ['A']), (this.outputShape = [])
    var o = t[0],
      i = t[1],
      a = t[2],
      t = t[3]
    ;(this.outputShape = [o, e, n, t]),
      (t = [r && 1 < e ? i - 1 : i, r && 1 < n ? a - 1 : a]),
      (n = [r && 1 < e ? e - 1 : e, r && 1 < n ? n - 1 : n]),
      (r = r ? '0.5' : '0.0'),
      (this.userCode =
        '\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ' +
        t[0] / n[0] +
        ',\n          ' +
        t[1] / n[1] +
        ');\n      const vec2 inputShapeRC = vec2(' +
        i +
        '.0, ' +
        a +
        '.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ' +
        r +
        ')));\n\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    ')
  }
  function va(n, r) {
    this.variableNames = ['x']
    var t,
      e = n.length
    if (4 < e) throw new Error('WebGL backend: Reverse of rank-' + e + ' tensor is not yet supported')
    ;(this.outputShape = n),
      1 !== e
        ? ((t = n
            .map(function (t, e) {
              return (e = e), -1 !== r.indexOf(e) && 1 !== n[e] ? n[e] + ' - coords[' + e + '] - 1' : 'coords[' + e + ']'
            })
            .join(',')),
          (e = No(e)),
          (this.userCode =
            '\n      void main() {\n        ' +
            e +
            ' coords = getOutputCoords();\n        setOutput(getX(' +
            t +
            '));\n      }\n    '))
        : (this.userCode =
            '\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(' +
            n[0] +
            ' - coord - 1));\n        }\n      ')
  }
  function ma(o, i) {
    ;(this.variableNames = ['x']), (this.packedInputs = !0), (this.packedOutput = !0)
    var t = o.length
    if (4 < t) throw new Error('WebGL backend: Reverse of rank-' + t + ' tensor is not yet supported')
    this.outputShape = o
    var e,
      n = (e = wo('rc', t))[t - 1] + ' + 1 < ' + this.outputShape[t - 1],
      r = e[t - 2] + ' + 1 < ' + this.outputShape[t - 2],
      a = No(t)
    function s(r) {
      var t = o.map(function (t, e) {
        return (n = e), (e = r), -1 !== i.indexOf(n) && 1 !== o[n] ? o[n] + ' - ' + e[n] + ' - 1' : '' + e[n]
        var n
      })
      return 'getChannel(getX(' + t.join(',') + '), vec2(' + t.slice(-2).join(',') + '))'
    }
    this.userCode =
      1 === t
        ? '\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(' +
          o[0] +
          ' - rc - 1),\n            ' +
          o[0] +
          ' - rc - 1);\n          if(' +
          n +
          '){\n              result.g = getChannel(getX(' +
          o[0] +
          ' - (rc  + 1) - 1),\n                ' +
          o[0] +
          ' - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      '
        : '\n        void main() {\n          ' +
          a +
          ' rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ' +
          s(e.slice()) +
          ';\n          if(' +
          n +
          '){\n            result.g = ' +
          (((a = e.slice())[t - 1] = '(' + a[t - 1] + ' + 1)'), s(a)) +
          ';\n          }\n          if(' +
          r +
          ') {\n            result.b = ' +
          (((r = e.slice())[t - 2] = '(' + r[t - 2] + ' + 1)'), s(r)) +
          ';\n            if(' +
          n +
          ') {\n              result.a = ' +
          (((e = e.slice())[t - 1] = '(' + e[t - 1] + ' + 1)'), (e[t - 2] = '(' + e[t - 2] + ' + 1)'), s(e)) +
          ';\n            }\n          }\n          setOutput(result);\n        }\n    '
  }
  function ga(t, e, n, r, o, i, a) {
    ;(this.variableNames = ['updates', 'indices', 'defaultValue']), (this.outputShape = i)
    var s = No(o.length),
      u = No(i.length),
      i = ''
    1 === n ? (i = 'i') : 2 === n && (i = 'i, j'),
      (n = 'getIndices(' + i + ')'),
      (i = ''),
      1 === r ? (i = 'i') : 2 === r && (i = 'i, coords[1]'),
      (r = 'getUpdates(' + i + ')'),
      (i = 1 < e ? 'strides[j]' : 'strides'),
      (this.userCode =
        '\n        ' +
        s +
        ' strides = ' +
        s +
        '(' +
        o +
        ');\n\n        void main() {\n          ' +
        u +
        ' coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ' +
        t +
        '; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ' +
        e +
        '; j++) {\n              int index = round(' +
        n +
        ');\n              flattenedIndex += index * ' +
        i +
        ';\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ' +
        r +
        ';\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      ')
  }
  function ya(t, e) {
    this.variableNames = ['x', 'segmentIds']
    var n = t.windowSize,
      r = t.batchSize,
      o = t.inSize,
      i = t.numSegments,
      a = i * Math.ceil(o / n)
    this.outputShape = [r, a]
    var s = 4 * Math.floor(n / 4),
      t = n % 4,
      r = '\n        sumValue += dot(values, segFilter);\n    ',
      a =
        0 < o % n
          ? '\n        if (inIdx < 0 || inIdx >= ' + o + ') {\n          return initializationValue;\n        }\n      '
          : ''
    ;(o = 0 < o % n ? '\n        if (inIdx < 0 || inIdx >= ' + o + ') {\n          return -1.0;\n        }\n      ' : ''),
      (this.userCode =
        '\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ' +
        a +
        '\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ' +
        o +
        '\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ' +
        i +
        ')) * float(' +
        n +
        '));\n        int currentSeg = int(mod(float(outIdx), float(' +
        i +
        ')));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ' +
        s +
        '; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ' +
        r +
        '\n        }\n\n        int inIdx = inOffset + ' +
        s +
        ';\n        if (' +
        (1 == t) +
        ') {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ' +
        r +
        '\n        } else if (' +
        (2 == t) +
        ') {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ' +
        r +
        '\n        } else if (' +
        (3 == t) +
        ') {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ' +
        r +
        '\n        }\n        setOutput(sumValue);\n      }\n    ')
  }
  function ba(t, e, n) {
    var r, o
    if (((this.variableNames = ['c', 'a', 'b']), (this.outputShape = e), 4 < n))
      throw Error('Where for rank ' + n + ' is not yet supported')
    if (1 === n) r = o = 'resRC'
    else {
      for (var i = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'], a = [], s = [], u = 0; u < e.length; u++)
        s.push('' + i[u]), u < t && a.push('' + i[u])
      ;(r = a.join()), (o = s.join())
    }
    ;(n = No(n)),
      (this.userCode =
        '\n      void main() {\n        ' +
        n +
        ' resRC = getOutputCoords();\n        float cVal = getC(' +
        r +
        ');\n        if (cVal >= 1.0) {\n          setOutput(getA(' +
        o +
        '));\n        } else {\n          setOutput(getB(' +
        o +
        '));\n        }\n      }\n    ')
  }
  var xa =
      ((Ca.prototype.getCustomSetupFunc = function (n) {
        var r = this
        if (n.length !== this.rank)
          throw Error('The rank (' + this.rank + ') of the program must match the length of start (' + n.length + ')')
        return function (t, e) {
          ;(null == r.startLoc && ((r.startLoc = t.getUniformLocationNoThrow(e, 'start')), null == r.startLoc)) ||
            t.gl.uniform1iv(r.startLoc, n)
        }
      }),
      Ca),
    wa = ['x', 'y', 'z', 'w', 'u', 'v']
  function Ca(t) {
    ;(this.variableNames = ['source']), (this.outputShape = t), (this.rank = t.length)
    var e = No(this.rank),
      n = 'uniform int start[' + this.rank + '];',
      r = (function (t) {
        if (1 === t) return 'sourceLoc'
        if (t <= 6)
          return wa
            .slice(0, t)
            .map(function (t) {
              return 'sourceLoc.' + t
            })
            .join(',')
        throw Error('Slicing for rank ' + t + ' is not yet supported')
      })(this.rank),
      t =
        '\n        ' +
        e +
        ' sourceLoc;\n        ' +
        e +
        ' coords = getOutputCoords();\n        ' +
        t
          .map(function (t, e) {
            return 'sourceLoc.' + wa[e] + ' = start[' + e + '] + coords.' + wa[e] + ';'
          })
          .join('\n') +
        '\n      '
    this.userCode =
      '\n      ' + n + '\n      void main() {\n        ' + t + '\n        setOutput(getSource(' + r + '));\n      }\n    '
  }
  function Ea(t, e, n) {
    this.variableNames = ['x']
    var r,
      o = (this.outputShape = n).length,
      i = No(n.length),
      a = No(n.length),
      s = ''
    ;(s =
      1 === o
        ? 'coords * strides + begin'
        : ((r = 0),
          n
            .map(function (t, e) {
              return (
                r++,
                1 === n.length
                  ? 'coords * strides[' + e + '] + begin[' + e + ']'
                  : 'coords[' + (r - 1) + '] * strides[' + e + '] + begin[' + e + ']'
              )
            })
            .join(','))),
      (this.userCode =
        '\n      ' +
        i +
        ' begin = ' +
        i +
        '(' +
        t +
        ');\n      ' +
        i +
        ' strides = ' +
        i +
        '(' +
        e +
        ');\n\n      void main() {\n        ' +
        a +
        ' coords = getOutputCoords();\n        setOutput(getX(' +
        s +
        '));\n      }\n    ')
  }
  var Sa =
      ((Ia.prototype.getCustomSetupFunc = function (n) {
        var r = this
        if (n.length !== this.rank)
          throw Error('The rank (' + this.rank + ') of the program must match the length of start (' + n.length + ')')
        return function (t, e) {
          ;(null == r.startLoc && ((r.startLoc = t.getUniformLocationNoThrow(e, 'start')), null == r.startLoc)) ||
            t.gl.uniform1iv(r.startLoc, n)
        }
      }),
      Ia),
    _a =
      ((Ra.prototype.acquireTexture = function (t, e, n) {
        var r,
          o = Aa(e, n),
          e = Na(t, o, n)
        if (
          (e in this.freeTextures || (this.freeTextures[e] = []),
          e in this.usedTextures || (this.usedTextures[e] = []),
          0 < this.freeTextures[e].length)
        ) {
          this.numFreeTextures--, this.numUsedTextures++, this.log()
          n = this.freeTextures[e].shift()
          return this.usedTextures[e].push(n), n
        }
        return (
          this.numUsedTextures++,
          this.log(),
          o === Gt.PACKED_2X2_FLOAT32
            ? (r = this.gpgpu.createPackedMatrixTexture(t[0], t[1]))
            : o === Gt.PACKED_2X2_FLOAT16
            ? (r = this.gpgpu.createFloat16PackedMatrixTexture(t[0], t[1]))
            : o === Gt.UNPACKED_FLOAT32
            ? (r = this.gpgpu.createFloat32MatrixTexture(t[0], t[1]))
            : o === Gt.UNPACKED_FLOAT16
            ? (r = this.gpgpu.createFloat16MatrixTexture(t[0], t[1]))
            : o === Gt.PACKED_4X1_UNSIGNED_BYTE && (r = this.gpgpu.createUnsignedBytesMatrixTexture(t[0], t[1])),
          this.usedTextures[e].push(r),
          r
        )
      }),
      (Ra.prototype.releaseTexture = function (t, e, n, r) {
        if (null != this.freeTextures) {
          r = Na(e, Aa(n, r), r)
          r in this.freeTextures || (this.freeTextures[r] = []),
            this.freeTextures[r].push(t),
            this.numFreeTextures++,
            this.numUsedTextures--
          ;(r = this.usedTextures[r]), (t = r.indexOf(t))
          if (t < 0) throw new Error('Cannot release a texture that was never provided by this texture manager')
          r.splice(t, 1), this.log()
        }
      }),
      (Ra.prototype.log = function () {
        var t
        this.logEnabled &&
          ((t = this.numFreeTextures + this.numUsedTextures),
          console.log('Free/Used', this.numFreeTextures + ' / ' + this.numUsedTextures, '(' + t + ')'))
      }),
      (Ra.prototype.getNumUsedTextures = function () {
        return this.numUsedTextures
      }),
      (Ra.prototype.getNumFreeTextures = function () {
        return this.numFreeTextures
      }),
      (Ra.prototype.dispose = function () {
        var e = this
        if (null != this.freeTextures) {
          for (var t in this.freeTextures)
            this.freeTextures[t].forEach(function (t) {
              e.gpgpu.deleteMatrixTexture(t)
            })
          for (var t in this.usedTextures)
            this.usedTextures[t].forEach(function (t) {
              e.gpgpu.deleteMatrixTexture(t)
            })
          ;(this.freeTextures = null), (this.usedTextures = null), (this.numUsedTextures = 0), (this.numFreeTextures = 0)
        }
      }),
      Ra)
  function Ra(t) {
    ;(this.gpgpu = t),
      (this.numUsedTextures = 0),
      (this.numFreeTextures = 0),
      (this.freeTextures = {}),
      (this.logEnabled = !1),
      (this.usedTextures = {})
  }
  function Ia(t) {
    ;(this.variableNames = ['source']),
      (this.packedInputs = !0),
      (this.packedOutput = !0),
      (this.outputShape = t),
      (this.rank = t.length)
    var e = No(this.rank),
      n = wo('coords', this.rank),
      r = wo('sourceLoc', this.rank),
      o = 1 === this.rank ? 'sourceLoc' : 'vec2(' + r.slice(-2).join() + ')',
      i = 'getChannel(getSource(' + r.join() + '), ' + o + ')',
      o =
        '\n      result.x = ' +
        i +
        ';\n      if (++' +
        n[this.rank - 1] +
        ' < ' +
        t[this.rank - 1] +
        ') {\n        ++' +
        r[this.rank - 1] +
        ';\n        result.y = ' +
        i +
        ';\n        --' +
        r[this.rank - 1] +
        ';\n      }\n    ',
      i =
        1 === this.rank
          ? ''
          : '\n      --' +
            n[this.rank - 1] +
            ';\n      if (++' +
            n[this.rank - 2] +
            ' < ' +
            t[this.rank - 2] +
            ') {\n        ++' +
            r[this.rank - 2] +
            ';\n        result.z = ' +
            i +
            ';\n        if (++' +
            n[this.rank - 1] +
            ' < ' +
            t[this.rank - 1] +
            ') {\n          ++' +
            r[this.rank - 1] +
            ';\n          result.w = ' +
            i +
            ';\n        }\n      }\n    ',
      t =
        this.rank <= 4
          ? 'sourceLoc = coords +\n            ' +
            e +
            '(' +
            t
              .map(function (t, e) {
                return 'start[' + e + ']'
              })
              .join() +
            ');'
          : t
              .map(function (t, e) {
                return r[e] + ' = ' + n[e] + ' + start[' + e + '];'
              })
              .join('\n')
    this.userCode =
      '\n      uniform int start[' +
      this.rank +
      '];\n      void main() {\n        ' +
      e +
      ' coords = getOutputCoords();\n        ' +
      e +
      ' sourceLoc;\n        ' +
      t +
      '\n        vec4 result = vec4(0.);\n        ' +
      o +
      '\n        ' +
      i +
      '\n        setOutput(result);\n      }\n    '
  }
  function Aa(t, e) {
    if (t === zt.UPLOAD) return Gt.PACKED_2X2_FLOAT32
    if (t === zt.RENDER || null == t)
      return (
        (e = e),
        f.getBool('WEBGL_RENDER_FLOAT32_ENABLED')
          ? e
            ? Gt.PACKED_2X2_FLOAT32
            : Gt.UNPACKED_FLOAT32
          : e
          ? Gt.PACKED_2X2_FLOAT16
          : Gt.UNPACKED_FLOAT16
      )
    if (t === zt.DOWNLOAD || t === zt.PIXELS) return Gt.PACKED_4X1_UNSIGNED_BYTE
    throw new Error('Unknown logical texture type ' + t)
  }
  function Na(t, e, n) {
    return t[0] + '_' + t[1] + '_' + e + '_' + n
  }
  function ka(t, e) {
    this.variableNames = ['A']
    for (var n = new Array(t.length), r = 0; r < n.length; r++) n[r] = t[r] * e[r]
    ;(this.outputShape = n), (this.rank = n.length)
    var o = No(this.rank),
      i = (function (t) {
        var e = t.length
        if (5 < e) throw Error('Tile for rank ' + e + ' is not yet supported')
        if (1 === e) return 'imod(resRC, ' + t[0] + ')'
        for (var n = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w', 'resRC.u'], r = [], o = 0; o < t.length; o++)
          r.push('imod(' + n[o] + ', ' + t[o] + ')')
        return r.join()
      })(t)
    this.userCode =
      '\n      void main() {\n        ' + o + ' resRC = getOutputCoords();\n        setOutput(getA(' + i + '));\n      }\n    '
  }
  function Ta(t, e) {
    this.variableNames = ['A']
    for (var n = new Array(t.length), r = 0; r < n.length; r++) n[r] = t[e[r]]
    ;(this.outputShape = n), (this.rank = n.length)
    var o = No(this.rank),
      i = (function (t) {
        var e = t.length
        if (6 < e) throw Error('Transpose for rank ' + e + ' is not yet supported')
        for (
          var n = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w', 'resRC.u', 'resRC.v'], r = new Array(e), o = 0;
          o < t.length;
          o++
        )
          r[t[o]] = n[o]
        return r.join()
      })(e)
    this.userCode =
      '\n    void main() {\n      ' + o + ' resRC = getOutputCoords();\n      setOutput(getA(' + i + '));\n    }\n    '
  }
  function Da(t, e) {
    ;(this.variableNames = ['A']), (this.packedInputs = !0), (this.packedOutput = !0)
    for (var n = new Array(t.length), r = 0; r < n.length; r++) n[r] = t[e[r]]
    if (((this.outputShape = n), (this.rank = n.length), 6 < this.rank))
      throw Error('Packed transpose for rank ' + this.rank + ' is not yet supported.')
    for (var o = No(this.rank), i = xo('rc', this.rank), a = new Array(this.rank), r = 0; r < e.length; r++) a[e[r]] = i[r]
    var s = 'vec2(' + a.slice(-2).join() + ')',
      u = '++' + i[this.rank - 1] + ' < ' + n[this.rank - 1],
      s = 'getChannel(getA(' + a.join() + '), ' + s + ')'
    this.userCode =
      '\n    void main() {\n      ' +
      o +
      ' rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ' +
      s +
      ';\n      if(' +
      u +
      ') {\n        result[1] = ' +
      s +
      ';\n      }\n      --' +
      i[this.rank - 1] +
      ';\n      if(++' +
      i[this.rank - 2] +
      ' < ' +
      n[this.rank - 2] +
      ') {\n        result[2] = ' +
      s +
      ';\n        if(' +
      u +
      ') {\n          result[3] = ' +
      s +
      ';\n        }\n      }\n      setOutput(result);\n    }\n    '
  }
  function Oa(t, e) {
    ;(this.variableNames = ['A']),
      (this.outputShape = t),
      (this.userCode =
        '\n      float unaryOperation(float x) {\n        ' +
        e +
        '\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ')
  }
  function Fa(t, e) {
    ;(this.variableNames = ['A']),
      (this.packedInputs = !0),
      (this.packedOutput = !0),
      (this.outputShape = t),
      (this.userCode =
        '\n      vec4 unaryOperation(vec4 x) {\n        ' +
        e +
        '\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ')
  }
  function Ma(t) {
    ;(this.variableNames = ['A']), (this.packedInputs = !0), (this.packedOutput = !1)
    var e = (this.outputShape = t).length,
      n = wo('rc', e),
      r = No(e),
      t = (function (t, e) {
        if (1 === t) return 'rc'
        for (var n = '', r = 0; r < t; r++) (n += e[r]), r < t - 1 && (n += ',')
        return n
      })(e, n),
      n = n.slice(-2),
      n = e <= 1 ? 'rc' : 'vec2(' + n.join(',') + ')'
    this.userCode =
      '\n      void main() {\n        ' +
      r +
      ' rc = getOutputCoords();\n        vec4 packedInput = getA(' +
      t +
      ');\n\n        setOutput(getChannel(packedInput, ' +
      n +
      '));\n      }\n    '
  }
  var Pa = 1.7580993408473768,
    Ba = 1.0507009873554805,
    La = 'if (isnan(x)) return x;',
    Wa = 'return abs(x);',
    za = La + '\n  return (x < 0.0) ? 0.0 : x;\n',
    Ga = La + '\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n',
    Ua = 'return (x >= 0.0) ? x : (exp(x) - 1.0);',
    Va = 'return -x;',
    Ha = 'return ceil(x);',
    ja = 'return floor(x);',
    qa = 'return exp(x);',
    Ka = 'return exp(x) - 1.0;',
    Xa = 'return x;',
    $a =
      '\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n',
    Ya =
      '\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n',
    Ja =
      '\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n',
    Qa = {}
  function Za(t, e) {
    if ((void 0 === e && (e = !1), 'linear' === t)) return 'return x;'
    if ('relu' === t) return e ? $a : za
    if ('elu' === t) return e ? Ja : Ua
    if ('relu6' === t) return e ? Ya : Ga
    if ('prelu' === t) return e ? Ko : qo
    throw new Error('Activation ' + t + ' has not been implemented for the WebGL backend.')
  }
  var ts,
    es =
      (n(ns, (ts = Br)),
      (ns.prototype.numDataIds = function () {
        return this.texData.numDataIds() + (this.cpuBackend ? this.cpuBackend.numDataIds() : 0) - this.pendingDeletes
      }),
      (ns.prototype.write = function (t, e, n) {
        if ((f.getBool('DEBUG') && this.checkNumericalProblems(t), 'complex64' === n && null != t))
          throw new Error('Cannot write to a complex64 dtype. Please use tf.complex(real, imag).')
        var r = {}
        return this.texData.set(r, { shape: e, dtype: n, values: t, usage: zt.UPLOAD }), r
      }),
      (ns.prototype.move = function (t, e, n, r) {
        if ((f.getBool('DEBUG') && this.checkNumericalProblems(e), 'complex64' === r))
          throw new Error('Cannot write to a complex64 dtype. Please use tf.complex(real, imag).')
        this.texData.set(t, { shape: n, dtype: r, values: e, usage: zt.UPLOAD })
      }),
      (ns.prototype.readSync = function (t) {
        var e = this.texData.get(t),
          n = e.values,
          r = e.dtype,
          o = e.complexTensors,
          i = e.slice,
          a = e.shape,
          e = e.isPacked
        if (null != i) {
          ;(i = new (e ? Fa : Oa)(a, Xa)),
            (i = this.runWebGLProgram(i, [{ dataId: t, shape: a, dtype: r }], r)),
            (a = this.readSync(i.dataId))
          return this.disposeData(i.dataId), a
        }
        if (null != n) return this.convertAndCacheOnCPU(t)
        if ('string' === r) return n
        var s,
          n = null != this.activeTimers
        return (
          n && (s = tt()),
          (o = 'complex64' === r ? io(o.real.dataSync(), o.imag.dataSync()) : this.getValuesFromTexture(t)),
          n && (this.downloadWaitMs += tt() - s),
          this.convertAndCacheOnCPU(t, o)
        )
      }),
      (ns.prototype.read = function (d) {
        return x(this, void 0, void 0, function () {
          var e, n, r, o, i, a, s, u, c, l, h, p
          return w(this, function (t) {
            switch (t.label) {
              case 0:
                if (this.pendingRead.has(d))
                  return (
                    (e = this.pendingRead.get(d)),
                    [
                      2,
                      new Promise(function (t) {
                        return e.push(t)
                      }),
                    ]
                  )
                if (
                  ((o = this.texData.get(d)),
                  (p = o.values),
                  (c = o.shape),
                  (n = o.slice),
                  (r = o.dtype),
                  (u = o.complexTensors),
                  (o = o.isPacked),
                  null != n)
                )
                  return (
                    (s = void 0),
                    (s = new (o ? Fa : Oa)(c, Xa)),
                    (i = this.runWebGLProgram(s, [{ dataId: d, shape: c, dtype: r }], r)),
                    (s = this.read(i.dataId)),
                    this.disposeData(i.dataId),
                    [2, s]
                  )
                if (null != p) return [2, this.convertAndCacheOnCPU(d)]
                if (!f.getBool('WEBGL_DOWNLOAD_FLOAT_ENABLED') && 2 === f.getNumber('WEBGL_VERSION'))
                  throw new Error(
                    'tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.',
                  )
                return (
                  (i = null),
                  'complex64' !== r &&
                    f.get('WEBGL_BUFFER_SUPPORTED') &&
                    ((a = this.decode(d)),
                    (s = this.texData.get(a.dataId)),
                    (i = (p = this.gpgpu).createBufferFromTexture.apply(p, [s.texture].concat(qt(c))))),
                  this.pendingRead.set(d, []),
                  'complex64' === r ? [3, 2] : [4, this.gpgpu.createAndWaitForFence()]
                )
              case 1:
                t.sent(), (t.label = 2)
              case 2:
                return 'complex64' !== r ? [3, 4] : [4, Promise.all([u.real.data(), u.imag.data()])]
              case 3:
                return (h = t.sent()), (u = h[0]), (h = h[1]), (h = io(u, h)), [3, 5]
              case 4:
                ;(h =
                  null == i ? this.getValuesFromTexture(d) : ((c = D(c)), this.gpgpu.downloadFloat32MatrixFromBuffer(i, c))),
                  (t.label = 5)
              case 5:
                return (
                  null != a && this.disposeData(a.dataId),
                  (l = this.convertAndCacheOnCPU(d, h)),
                  (h = this.pendingRead.get(d)),
                  this.pendingRead.delete(d),
                  h.forEach(function (t) {
                    return t(l)
                  }),
                  this.pendingDisposal.has(d) && (this.pendingDisposal.delete(d), this.disposeData(d), this.pendingDeletes--),
                  [2, l]
                )
            }
          })
        })
      }),
      (ns.prototype.checkNumericalProblems = function (t) {
        if (null != t)
          for (var e = 0; e < t.length; e++) {
            var n = t[e]
            if (!Yt(n)) {
              if (f.getBool('WEBGL_RENDER_FLOAT32_CAPABLE'))
                throw Error(
                  'The value ' +
                    n +
                    " cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'",
                )
              throw Error('The value ' + n + ' cannot be represented on this device.')
            }
          }
      }),
      (ns.prototype.getValuesFromTexture = function (t) {
        var e = this.texData.get(t),
          n = e.shape,
          r = e.dtype,
          o = e.isPacked,
          i = D(n)
        if (f.getBool('WEBGL_DOWNLOAD_FLOAT_ENABLED')) {
          var a = this.decode(t),
            s = this.texData.get(a.dataId),
            s = (e = this.gpgpu).downloadMatrixFromPackedTexture.apply(e, [s.texture].concat(qt(n))).subarray(0, i)
          return this.disposeData(a.dataId), s
        }
        ;(o = f.getBool('WEBGL_PACK') && !0 === o),
          (n = o ? _e(n) : n),
          (o = new (o ? mi : vi)(n)),
          (r = this.runWebGLProgram(o, [{ shape: n, dtype: r, dataId: t }], 'float32')),
          (t = this.texData.get(r.dataId)),
          (i = this.gpgpu
            .downloadByteEncodedFloatMatrixFromOutputTexture(t.texture, t.texShape[0], t.texShape[1])
            .subarray(0, i))
        return this.disposeData(r.dataId), i
      }),
      (ns.prototype.time = function (a) {
        return x(this, void 0, void 0, function () {
          var e, n, r, o, i
          return w(this, function (t) {
            switch (t.label) {
              case 0:
                return (
                  (e = this.activeTimers),
                  (o = !(n = [])),
                  null == this.programTimersStack ? ((this.programTimersStack = n), (o = !0)) : this.activeTimers.push(n),
                  (this.activeTimers = n),
                  a(),
                  (n = E(
                    this.activeTimers.map(function (t) {
                      return t.query
                    }),
                  ).filter(function (t) {
                    return null != t
                  })),
                  (r = E(
                    this.activeTimers.map(function (t) {
                      return t.name
                    }),
                  ).filter(function (t) {
                    return null != t
                  })),
                  (this.activeTimers = e),
                  o && (this.programTimersStack = null),
                  (o = { uploadWaitMs: this.uploadWaitMs, downloadWaitMs: this.downloadWaitMs, kernelMs: null, wallMs: null }),
                  0 < f.getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') ? [4, Promise.all(n)] : [3, 2]
                )
              case 1:
                return (
                  (i = t.sent()),
                  (o.kernelMs = m(i)),
                  (o.getExtraProfileInfo = function () {
                    return i
                      .map(function (t, e) {
                        return { name: r[e], ms: t }
                      })
                      .map(function (t) {
                        return t.name + ': ' + t.ms
                      })
                      .join(', ')
                  }),
                  [3, 3]
                )
              case 2:
                ;(o.kernelMs = { error: 'WebGL query timers are not supported in this environment.' }), (t.label = 3)
              case 3:
                return (this.uploadWaitMs = 0), (this.downloadWaitMs = 0), [2, o]
            }
          })
        })
      }),
      (ns.prototype.memory = function () {
        return { unreliable: !1, numBytesInGPU: this.numBytesInGPU }
      }),
      (ns.prototype.startTimer = function () {
        return 0 < f.getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE')
          ? this.gpgpu.beginQuery()
          : { startMs: tt(), endMs: null }
      }),
      (ns.prototype.endTimer = function (t) {
        return 0 < f.getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') ? this.gpgpu.endQuery() : (t.endMs = tt()), t
      }),
      (ns.prototype.getQueryTime = function (e) {
        return x(this, void 0, void 0, function () {
          return w(this, function (t) {
            return 0 < f.getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE')
              ? [2, this.gpgpu.waitForQueryAndGetTime(e)]
              : [2, e.endMs - e.startMs]
          })
        })
      }),
      (ns.prototype.disposeData = function (t) {
        if (!this.pendingDisposal.has(t)) {
          if (this.pendingRead.has(t)) return this.pendingDisposal.add(t), void this.pendingDeletes++
          var e
          this.texData.has(t) &&
            (this.releaseGPUData(t),
            null != (e = this.texData.get(t).complexTensors) && (e.real.dispose(), e.imag.dispose()),
            this.texData.delete(t))
        }
      }),
      (ns.prototype.releaseGPUData = function (t) {
        var e = this.texData.get(t),
          n = e.texture,
          r = e.dtype,
          o = e.texShape,
          i = e.usage,
          a = e.isPacked,
          s = e.slice,
          e = (s && s.origDataId) || t,
          s = this.dataRefCount.get(e)
        1 < s
          ? this.dataRefCount.set(e, s - 1)
          : (this.dataRefCount.delete(e),
            null != n && ((this.numBytesInGPU -= this.computeBytes(o, r)), this.textureManager.releaseTexture(n, o, i, a)))
        t = this.texData.get(t)
        ;(t.texture = null), (t.texShape = null), (t.isPacked = !1), (t.slice = null)
      }),
      (ns.prototype.getTexture = function (t) {
        return this.uploadToGPU(t), this.texData.get(t).texture
      }),
      (ns.prototype.getDataInfo = function (t) {
        return this.texData.get(t)
      }),
      (ns.prototype.getCPUBackend = function () {
        return f.getBool('WEBGL_CPU_FORWARD')
          ? (null == this.cpuBackend && (this.cpuBackend = Pt.findBackend('cpu')), this.cpuBackend)
          : null
      }),
      (ns.prototype.shouldExecuteOnCPU = function (t, e) {
        var n = this
        return (
          void 0 === e && (e = 128),
          null != this.getCPUBackend() &&
            t.every(function (t) {
              return null == n.texData.get(t.dataId).texture && t.size < e
            })
        )
      }),
      (ns.prototype.getGPGPUContext = function () {
        return this.gpgpu
      }),
      (ns.prototype.complex = function (t, e) {
        var n = this.makeOutput(t.shape, 'complex64')
        return (this.texData.get(n.dataId).complexTensors = { real: Pt.keep(t.clone()), imag: Pt.keep(e.clone()) }), n
      }),
      (ns.prototype.real = function (t) {
        return this.texData.get(t.dataId).complexTensors.real.clone()
      }),
      (ns.prototype.imag = function (t) {
        return this.texData.get(t.dataId).complexTensors.imag.clone()
      }),
      (ns.prototype.slice = function (t, e, n) {
        if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.slice(t, e, n)
        if (0 === D(n)) return cn([], n, t.dtype)
        var r = this.texData.get(t.dataId).isPacked,
          o = Tr(t.shape, e, n)
        if (!r && o) return this.uploadToGPU(t.dataId), this.shallowSlice(t, e, n)
        ;(n = new (f.getBool('WEBGL_PACK_ARRAY_OPERATIONS') ? Sa : xa)(n)), (e = n.getCustomSetupFunc(e))
        return this.compileAndRun(n, [t], null, e)
      }),
      (ns.prototype.shallowSlice = function (t, e, n) {
        var r = this.texData.get(t.dataId),
          o = this.makeOutput(n, t.dtype),
          i = this.texData.get(o.dataId)
        Object.assign(i, r), (i.shape = n), (i.dtype = t.dtype)
        e = Dr(e, t.strides)
        r.slice && (e += r.slice.flatOffset),
          (i.slice = { flatOffset: e, origDataId: (r.slice && r.slice.origDataId) || t.dataId })
        t = this.dataRefCount.get(i.slice.origDataId) || 1
        return this.dataRefCount.set(i.slice.origDataId, t + 1), o
      }),
      (ns.prototype.stridedSlice = function (t, e, n, r) {
        if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.stridedSlice(t, e, n, r)
        n = Ar(e, n, r)
        if (
          n.some(function (t) {
            return 0 === t
          })
        )
          return cn([], n)
        n = new Ea(e, r, n)
        return this.compileAndRun(n, [t])
      }),
      (ns.prototype.reverse = function (t, e) {
        e = new (f.getBool('WEBGL_PACK_ARRAY_OPERATIONS') ? ma : va)(t.shape, e)
        return this.compileAndRun(e, [t])
      }),
      (ns.prototype.concat = function (t, e) {
        if ('complex64' === t[0].dtype) {
          var n = t.map(function (t) {
              return sn(t)
            }),
            r = t.map(function (t) {
              return un(t)
            })
          return an(this.concat(n, e), this.concat(r, e))
        }
        if (this.shouldExecuteOnCPU(t)) return this.cpuBackend.concat(t, e)
        if (1 === t.length) return t[0]
        if (t.length > f.getNumber('WEBGL_MAX_TEXTURES_IN_SHADER')) {
          var o = Math.floor(t.length / 2),
            r = this.concat(t.slice(0, o), e),
            o = this.concat(t.slice(o), e)
          return this.concat([r, o], e)
        }
        if (f.getBool('WEBGL_PACK_ARRAY_OPERATIONS') && 1 < t[0].rank) {
          var i = new Uo(
            t.map(function (t) {
              return t.shape
            }),
            e,
          )
          return this.compileAndRun(i, t)
        }
        ;(o = rn(
          t.map(function (t) {
            return t.shape
          }),
          e,
        )),
          (i = t.map(function (t) {
            return t.as2D(-1, D(t.shape.slice(e)))
          })),
          (t = new Go(
            i.map(function (t) {
              return t.shape
            }),
          ))
        return this.compileAndRun(t, i).reshape(o)
      }),
      (ns.prototype.neg = function (t) {
        if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.neg(t)
        if (f.getBool('WEBGL_PACK_UNARY_OPERATIONS')) return this.packedUnaryOp(t, Va, t.dtype)
        var e = new Oa(t.shape, Va)
        return this.compileAndRun(e, [t])
      }),
      (ns.prototype.batchMatMul = function (t, e, n, r) {
        var o = n ? t.shape[2] : t.shape[1],
          i = r ? e.shape[1] : e.shape[2],
          a = n ? t.shape[1] : t.shape[2],
          s = t.shape[0]
        if ((1 === o || 1 === i) && 1e3 < a) {
          n && (t = t.transpose([0, 2, 1])), r && (e = e.transpose([0, 2, 1]))
          var u = 1 === i ? t : t.as3D(s, a, 1),
            c = 1 === i ? 2 : 1,
            a = 1 === i ? e.as3D(s, 1, a) : e
          return this.multiply(u, a).sum(c, !0)
        }
        ;(c = Rt(t.dtype, e.dtype)), (r = new Zi(t.shape, [s, o, i], n, r))
        return this.compileAndRun(r, [t, e], c)
      }),
      (ns.prototype.fusedBatchMatMul = function (t) {
        var e = t.a,
          n = t.b,
          r = t.transposeA,
          o = t.transposeB,
          i = t.bias,
          a = t.activation,
          s = t.preluActivationWeights,
          u = r ? e.shape[2] : e.shape[1],
          c = o ? n.shape[1] : n.shape[2],
          l = e.shape[0],
          h = Rt(e.dtype, n.dtype),
          p = null != i,
          t = null != s,
          a = a ? Za(a, !0) : null,
          t = new Zi(e.shape, [l, u, c], r, o, p, a, t),
          n = [e, n]
        return i && n.push(i), s && n.push(s), this.compileAndRun(t, n, h)
      }),
      (ns.prototype.multiply = function (t, e) {
        if ('complex64' === t.dtype) {
          var n = this.texData.get(t.dataId),
            r = this.texData.get(e.dataId),
            o = new Bo('return areal * breal - aimag * bimag;', t.shape, e.shape),
            i = new Bo('return areal * bimag + aimag * breal;', t.shape, e.shape),
            r = [
              this.makeComplexComponentTensorInfo(t, n.complexTensors.real),
              this.makeComplexComponentTensorInfo(t, n.complexTensors.imag),
              this.makeComplexComponentTensorInfo(e, r.complexTensors.real),
              this.makeComplexComponentTensorInfo(e, r.complexTensors.imag),
            ],
            o = this.compileAndRun(o, r),
            i = this.compileAndRun(i, r),
            r = this.complex(o, i)
          return o.dispose(), i.dispose(), r
        }
        if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.multiply(t, e)
        if (f.getBool('WEBGL_PACK_BINARY_OPERATIONS')) return this.packedBinaryOp(t, e, jo, t.dtype)
        r = new Lo(jo, t.shape, e.shape)
        return this.compileAndRun(r, [t, e], t.dtype)
      }),
      (ns.prototype.batchNormalization = function (t, e, n, r, o, i) {
        var a = [t, e, n],
          s = null
        null != i && ((s = i.shape), a.push(i))
        i = null
        if ((null != o && ((i = o.shape), a.push(o)), f.getBool('WEBGL_PACK_NORMALIZATION'))) {
          o = new Po(t.shape, e.shape, n.shape, s, i, r)
          return this.compileAndRun(o, a)
        }
        r = new Mo(t.shape, e.shape, n.shape, s, i, r)
        return this.compileAndRun(r, a)
      }),
      (ns.prototype.localResponseNormalization4D = function (t, e, n, r, o) {
        o = new (f.getBool('WEBGL_PACK_NORMALIZATION') ? Yi : Xi)(t.shape, e, n, r, o)
        return this.compileAndRun(o, [t])
      }),
      (ns.prototype.LRNGrad = function (t, e, n, r, o, i, a) {
        a = new $i(e.shape, r, o, i, a)
        return this.compileAndRun(a, [e, n, t])
      }),
      (ns.prototype.tile = function (t, e) {
        if ('string' === t.dtype) {
          var n = this.readSync(t.dataId).map(function (t) {
            return rt(t)
          })
          return fo(Vn(t.shape, t.dtype, n), e)
        }
        e = new ka(t.shape, e)
        return this.compileAndRun(e, [t])
      }),
      (ns.prototype.pad = function (t, e, n) {
        n = new (f.getBool('WEBGL_PACK_ARRAY_OPERATIONS') ? ia : oa)(t.shape, e, n)
        return this.compileAndRun(n, [t])
      }),
      (ns.prototype.transpose = function (t, e) {
        if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.transpose(t, e)
        e = new (f.getBool('WEBGL_PACK_ARRAY_OPERATIONS') ? Da : Ta)(t.shape, e)
        return this.compileAndRun(e, [t])
      }),
      (ns.prototype.gather = function (t, e, n) {
        if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.gather(t, e, n)
        n = new xi(t.shape, e.size, n)
        return this.compileAndRun(n, [t, e])
      }),
      (ns.prototype.batchToSpaceND = function (t, e, n) {
        A(t.rank <= 4, function () {
          return 'batchToSpaceND for rank > 4 with a WebGL backend not implemented yet'
        })
        var r = e.reduce(function (t, e) {
            return t * e
          }),
          o = mr(t.shape, e, r),
          i = gr(o.length, e.length),
          a = yr(t.shape, e, r),
          r = br(n, e.length),
          e = xr(a, n, e.length)
        return t.reshape(o).transpose(i).reshape(a).slice(r, e)
      }),
      (ns.prototype.spaceToBatchND = function (t, e, n) {
        A(t.rank <= 4, function () {
          return 'spaceToBatchND for rank > 4 with a WebGL backend not implemented yet'
        })
        var r = e.reduce(function (t, e) {
            return t * e
          }),
          o = [[0, 0]]
        o.push.apply(o, n)
        for (var i = 1 + e.length; i < t.shape.length; ++i) o.push([0, 0])
        var a = t.pad(o),
          s = mr(a.shape, e, r, !1),
          n = gr(s.length, e.length, !1),
          r = yr(a.shape, e, r, !1)
        return a.reshape(s).transpose(n).reshape(r)
      }),
      (ns.prototype.reduce = function (t, e, n) {
        var r = t.shape[0],
          o = t.shape[1],
          i = Cr(o),
          r = new ua({ windowSize: i, inSize: o, batchSize: r }, e),
          t = this.compileAndRun(r, [t], n)
        return 1 === t.shape[1] ? t : this.reduce(t, e, n)
      }),
      (ns.prototype.argReduce = function (t, e, n) {
        void 0 === n && (n = null)
        var r = t.shape[0],
          o = t.shape[1]
        null != n && ((r = n.shape[0]), (o = n.shape[1]))
        var i = Cr(o),
          o = new bo({ windowSize: i, inSize: o, batchSize: r }, e, null == n),
          r = [t]
        null != n && r.push(n)
        r = this.compileAndRun(o, r, 'int32')
        return 1 === r.shape[1] ? r : this.argReduce(t, e, r)
      }),
      (ns.prototype.argReducePacked = function (t, e, n) {
        var r = (null != (n = void 0 === n ? null : n) ? n : t).shape,
          o = Cr(r[r.length - 1]),
          o = new Do(r, o, e, null == n),
          n = null == n ? [t] : [t, n],
          n = this.compileAndRun(o, n, 'int32')
        return n.rank === t.rank ? this.argReducePacked(t, e, n) : n
      }),
      (ns.prototype.sum = function (t, e) {
        Qe('sum', e, t.rank)
        var n = Ye(t.shape, e),
          e = n[0],
          n = D(n[1]),
          n = t.as2D(-1, n),
          t = It(t.dtype)
        return this.reduce(n, 'sum', t).reshape(e)
      }),
      (ns.prototype.prod = function (t, e) {
        if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.prod(t, e)
        var n = Ye(t.shape, e),
          e = n[0],
          n = D(n[1]),
          n = t.as2D(-1, n),
          t = It(t.dtype)
        return this.reduce(n, 'prod', t).reshape(e)
      }),
      (ns.prototype.unsortedSegmentSum = function (t, e, n) {
        var r = 0,
          o = Ze([r], t.rank),
          i = t
        null != o && ((i = t.transpose(o)), (r = en(1, t.rank)[0]))
        var a = (function (t, e, n) {
            for (var r = [], o = t.length, i = 0; i < o; i++) i !== e ? r.push(t[i]) : r.push(n)
            return r
          })(i.shape, r, n),
          r = D([i.shape[r]]),
          r = i.as2D(-1, r),
          t = It(t.dtype),
          a = this.segOpCompute(r, 'unsortedSegmentSum', e, t, n).reshape(a)
        return (a = null != o ? a.transpose(tn(o)) : a)
      }),
      (ns.prototype.segOpCompute = function (t, e, n, r, o) {
        var i = t.shape[0],
          a = t.shape[1],
          s = (function (t, e) {
            var n,
              r = !1
            for (t <= 30 ? ((n = t), (r = !0)) : (n = X(t, Math.floor(Math.sqrt(t)))); !r; )
              e < n || n === t ? (r = !0) : (n = X(t, n + 1))
            return n
          })(a, o),
          i = new ya({ windowSize: s, inSize: a, batchSize: i, numSegments: o }),
          t = this.compileAndRun(i, [t, n], r)
        return t.shape[1] === o ? t : ((n = bn(0, o).tile([a / s])), this.segOpCompute(t, e, n, r, o))
      }),
      (ns.prototype.argMinMaxReduce = function (t, e, n) {
        var r = [e]
        if ((Qe('arg' + n.charAt(0).toUpperCase() + n.slice(1), r, t.rank), !f.getBool('WEBGL_PACK_REDUCE') || t.rank <= 2)) {
          ;(e = Ye(t.shape, r)), (r = e[0]), (e = D(e[1])), (e = t.as2D(-1, e))
          return this.argReduce(e, n).reshape(r)
        }
        return this.argReducePacked(t, n)
      }),
      (ns.prototype.argMin = function (t, e) {
        return this.argMinMaxReduce(t, e, 'min')
      }),
      (ns.prototype.argMax = function (t, e) {
        return this.argMinMaxReduce(t, e, 'max')
      }),
      (ns.prototype.cumsum = function (t, e, n, r) {
        if (e !== t.rank - 1)
          throw new Error('WebGL cumsum shader expects an inner-most axis=' + (t.rank - 1) + ' but got axis=' + e)
        r = new li(t.shape, n, r)
        return this.compileAndRun(r, [t])
      }),
      (ns.prototype.equal = function (t, e) {
        if (f.getBool('WEBGL_PACK_BINARY_OPERATIONS'))
          return this.packedBinaryOp(t, e, '\n  return vec4(equal(a, b));\n', 'bool')
        var n = new Lo('return float(a == b);', t.shape, e.shape)
        return this.compileAndRun(n, [t, e], 'bool')
      }),
      (ns.prototype.notEqual = function (t, e) {
        if (f.getBool('WEBGL_PACK_BINARY_OPERATIONS'))
          return this.packedBinaryOp(t, e, '\n  return vec4(notEqual(a, b));\n', 'bool')
        var n = new Lo('return float(a != b);', t.shape, e.shape)
        return this.compileAndRun(n, [t, e], 'bool')
      }),
      (ns.prototype.less = function (t, e) {
        if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.less(t, e)
        if (f.getBool('WEBGL_PACK_BINARY_OPERATIONS'))
          return this.packedBinaryOp(t, e, '\n  return vec4(lessThan(a, b));\n', 'bool')
        var n = new Lo('return float(a < b);', t.shape, e.shape)
        return this.compileAndRun(n, [t, e], 'bool')
      }),
      (ns.prototype.lessEqual = function (t, e) {
        if (f.getBool('WEBGL_PACK_BINARY_OPERATIONS'))
          return this.packedBinaryOp(t, e, '\n  return vec4(lessThanEqual(a, b));\n', 'bool')
        var n = new Lo('return float(a <= b);', t.shape, e.shape)
        return this.compileAndRun(n, [t, e], 'bool')
      }),
      (ns.prototype.greater = function (t, e) {
        if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.greater(t, e)
        if (f.getBool('WEBGL_PACK_BINARY_OPERATIONS'))
          return this.packedBinaryOp(t, e, '\n  return vec4(greaterThan(a, b));\n', 'bool')
        var n = new Lo('return float(a > b);', t.shape, e.shape)
        return this.compileAndRun(n, [t, e], 'bool')
      }),
      (ns.prototype.greaterEqual = function (t, e) {
        if (f.getBool('WEBGL_PACK_BINARY_OPERATIONS'))
          return this.packedBinaryOp(t, e, '\n  return vec4(greaterThanEqual(a, b));\n', 'bool')
        var n = new Lo('return float(a >= b);', t.shape, e.shape)
        return this.compileAndRun(n, [t, e], 'bool')
      }),
      (ns.prototype.logicalNot = function (t) {
        var e = new Oa(t.shape, 'return float(!(x >= 1.0));')
        return this.compileAndRun(e, [t])
      }),
      (ns.prototype.logicalAnd = function (t, e) {
        if (f.getBool('WEBGL_PACK_BINARY_OPERATIONS'))
          return this.packedBinaryOp(
            t,
            e,
            '\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n',
            'bool',
          )
        var n = new Lo('return float(a >= 1.0 && b >= 1.0);', t.shape, e.shape)
        return this.compileAndRun(n, [t, e], 'bool')
      }),
      (ns.prototype.logicalOr = function (t, e) {
        if (f.getBool('WEBGL_PACK_BINARY_OPERATIONS'))
          return this.packedBinaryOp(
            t,
            e,
            '\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n',
            'bool',
          )
        var n = new Lo('return float(a >= 1.0 || b >= 1.0);', t.shape, e.shape)
        return this.compileAndRun(n, [t, e], 'bool')
      }),
      (ns.prototype.select = function (t, e, n) {
        var r = new ba(t.rank, e.shape, e.rank)
        return this.compileAndRun(r, [t, e, n], Rt(e.dtype, n.dtype))
      }),
      (ns.prototype.where = function (t) {
        Ve('tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead')
        var e = t.dataSync()
        return mo(t.shape, e)
      }),
      (ns.prototype.topk = function (t, e, n) {
        return vo(t.dataSync(), t.shape, t.dtype, e)
      }),
      (ns.prototype.min = function (t, e) {
        Qe('min', e, t.rank)
        var n = Ye(t.shape, e),
          e = n[0],
          n = D(n[1]),
          n = t.as2D(-1, n)
        return this.reduce(n, 'min', n.dtype).reshape(e)
      }),
      (ns.prototype.minimum = function (t, e) {
        if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.minimum(t, e)
        var n = f.getBool('WEBGL_PACK_BINARY_OPERATIONS')
          ? new Wo(
              '\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n',
              t.shape,
              e.shape,
            )
          : new Lo('\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n', t.shape, e.shape)
        return this.compileAndRun(n, [t, e])
      }),
      (ns.prototype.mod = function (t, e) {
        var n = f.getBool('WEBGL_PACK_BINARY_OPERATIONS')
          ? new Wo(
              '\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n',
              t.shape,
              e.shape,
            )
          : new Lo('if (b == 0.0) return NAN;\n  return mod(a, b);', t.shape, e.shape)
        return this.compileAndRun(n, [t, e])
      }),
      (ns.prototype.max = function (t, e) {
        if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.max(t, e)
        Qe('max', e, t.rank)
        var n = Ye(t.shape, e),
          e = n[0],
          n = D(n[1]),
          n = t.as2D(-1, n)
        return this.reduce(n, 'max', n.dtype).reshape(e)
      }),
      (ns.prototype.maximum = function (t, e) {
        if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.maximum(t, e)
        var n = f.getBool('WEBGL_PACK_BINARY_OPERATIONS')
          ? new Wo(
              '\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n',
              t.shape,
              e.shape,
            )
          : new Lo('\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n', t.shape, e.shape)
        return this.compileAndRun(n, [t, e])
      }),
      (ns.prototype.all = function (t, e) {
        Qe('all', e, t.rank)
        var n = Ye(t.shape, e),
          e = n[0],
          n = D(n[1]),
          n = t.as2D(-1, n)
        return this.reduce(n, 'all', n.dtype).reshape(e)
      }),
      (ns.prototype.any = function (t, e) {
        Qe('any', e, t.rank)
        var n = Ye(t.shape, e),
          e = n[0],
          n = D(n[1]),
          n = t.as2D(-1, n)
        return this.reduce(n, 'any', n.dtype).reshape(e)
      }),
      (ns.prototype.realDivide = function (t, e) {
        if (f.getBool('WEBGL_PACK_BINARY_OPERATIONS'))
          return this.packedBinaryOp(
            t,
            e,
            '\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n',
            'float32',
            !0,
          )
        var n = new Lo('\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;', t.shape, e.shape)
        return this.compileAndRun(n, [t, e], 'float32')
      }),
      (ns.prototype.floorDiv = function (t, e) {
        if (f.getBool('WEBGL_PACK_BINARY_OPERATIONS'))
          return this.packedBinaryOp(
            t,
            e,
            '\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n',
            'int32',
          )
        var n = new Lo(
          '\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n',
          t.shape,
          e.shape,
        )
        return this.compileAndRun(n, [t, e], 'int32')
      }),
      (ns.prototype.add = function (t, e) {
        if ('complex64' === t.dtype && 'complex64' === e.dtype) return this.complexSeparableBinaryOp(t, e, Vo)
        if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.add(t, e)
        var n = Rt(t.dtype, e.dtype)
        if (f.getBool('WEBGL_PACK_BINARY_OPERATIONS')) return this.packedBinaryOp(t, e, Vo, n)
        var r = new Lo(Vo, t.shape, e.shape)
        return this.compileAndRun(r, [t, e], n)
      }),
      (ns.prototype.packedUnaryOp = function (t, e, n) {
        e = new Fa(t.shape, e)
        return this.compileAndRun(e, [t], n)
      }),
      (ns.prototype.packedBinaryOp = function (t, e, n, r, o) {
        void 0 === o && (o = !1)
        o = new Wo(n, t.shape, e.shape, o)
        return this.compileAndRun(o, [t, e], r)
      }),
      (ns.prototype.complexSeparableBinaryOp = function (i, a, s) {
        var u = this,
          t = this.texData.get(i.dataId),
          e = this.texData.get(a.dataId),
          n = [
            [t.complexTensors.real, e.complexTensors.real],
            [t.complexTensors.imag, e.complexTensors.imag],
          ].map(function (t) {
            var e = t[0],
              n = t[1],
              r = u.makeComplexComponentTensorInfo(i, e),
              o = u.makeComplexComponentTensorInfo(a, n),
              t = new Lo(s, i.shape, a.shape)
            return u.compileAndRun(t, [r, o], Rt(e.dtype, n.dtype))
          }),
          t = n[0],
          e = n[1],
          n = this.complex(t, e)
        return t.dispose(), e.dispose(), n
      }),
      (ns.prototype.makeComplexComponentTensorInfo = function (t, e) {
        return { dataId: e.dataId, dtype: e.dtype, shape: t.shape }
      }),
      (ns.prototype.addN = function (t) {
        if (1 === t.length) return t[0]
        if (t.length > f.get('WEBGL_MAX_TEXTURES_IN_SHADER')) {
          var e = Math.floor(t.length / 2),
            n = this.addN(t.slice(0, e)),
            e = this.addN(t.slice(e))
          return this.addN([n, e])
        }
        ;(n = t
          .map(function (t) {
            return t.dtype
          })
          .reduce(Rt)),
          (e = t.map(function (t) {
            return t.shape
          })),
          (e = new (f.getBool('WEBGL_PACK') ? yo : go)(t[0].shape, e))
        return this.compileAndRun(e, t, n)
      }),
      (ns.prototype.subtract = function (t, e) {
        if ('complex64' === t.dtype && 'complex64' === e.dtype) return this.complexSeparableBinaryOp(t, e, Ho)
        if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.subtract(t, e)
        var n = Rt(t.dtype, e.dtype)
        if (f.getBool('WEBGL_PACK_BINARY_OPERATIONS')) return this.packedBinaryOp(t, e, Ho, t.dtype)
        var r = new Lo(Ho, t.shape, e.shape)
        return this.compileAndRun(r, [t, e], n)
      }),
      (ns.prototype.pow = function (t, e) {
        var n = f.getBool('WEBGL_PACK_BINARY_OPERATIONS')
            ? new Wo(
                '\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n',
                t.shape,
                e.shape,
              )
            : new Lo(
                '\nif(a < 0.0 && floor(b) < b){\n  return NAN;\n}\nif (b == 0.0) {\n  return 1.0;\n}\nreturn (round(mod(b, 2.0)) != 1) ?\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\n',
                t.shape,
                e.shape,
              ),
          r = Rt(t.dtype, e.dtype)
        return this.compileAndRun(n, [t, e], r)
      }),
      (ns.prototype.ceil = function (t) {
        if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.ceil(t)
        if (f.getBool('WEBGL_PACK_UNARY_OPERATIONS')) return this.packedUnaryOp(t, Ha, t.dtype)
        var e = new Oa(t.shape, Ha)
        return this.compileAndRun(e, [t])
      }),
      (ns.prototype.floor = function (t) {
        if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.floor(t)
        if (f.getBool('WEBGL_PACK_UNARY_OPERATIONS')) return this.packedUnaryOp(t, ja, t.dtype)
        var e = new Oa(t.shape, ja)
        return this.compileAndRun(e, [t])
      }),
      (ns.prototype.sign = function (t) {
        var e = new Oa(t.shape, '\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n')
        return this.compileAndRun(e, [t])
      }),
      (ns.prototype.isNaN = function (t) {
        var e = new Oa(t.shape, 'return float(isnan(x));')
        return this.compileAndRun(e, [t], 'bool')
      }),
      (ns.prototype.isInf = function (t) {
        var e = new Oa(t.shape, 'return float(isinf(x));')
        return this.compileAndRun(e, [t], 'bool')
      }),
      (ns.prototype.isFinite = function (t) {
        var e = new Oa(t.shape, 'return float(!isnan(x) && !isinf(x));')
        return this.compileAndRun(e, [t], 'bool')
      }),
      (ns.prototype.round = function (t) {
        var e = new Oa(
          t.shape,
          "\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n",
        )
        return this.compileAndRun(e, [t])
      }),
      (ns.prototype.exp = function (t) {
        if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.exp(t)
        if (f.getBool('WEBGL_PACK_UNARY_OPERATIONS')) return this.packedUnaryOp(t, qa, t.dtype)
        var e = new Oa(t.shape, qa)
        return this.compileAndRun(e, [t])
      }),
      (ns.prototype.expm1 = function (t) {
        if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.expm1(t)
        if (f.getBool('WEBGL_PACK_UNARY_OPERATIONS')) return this.packedUnaryOp(t, Ka, t.dtype)
        var e = new Oa(t.shape, Ka)
        return this.compileAndRun(e, [t])
      }),
      (ns.prototype.softmax = function (t, e) {
        var n = O([e], t.shape),
          r = this.max(t, n),
          e = Je(r.shape, n),
          r = this.subtract(t, r.reshape(e)),
          r = this.exp(r),
          e = this.sum(r, n).reshape(e)
        return this.realDivide(r, e)
      }),
      (ns.prototype.log = function (t) {
        if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.log(t)
        if (f.getBool('WEBGL_PACK_UNARY_OPERATIONS'))
          return this.packedUnaryOp(
            t,
            '\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n',
            t.dtype,
          )
        var e = new Oa(t.shape, 'if (x < 0.0) return NAN;\n  return log(x);')
        return this.compileAndRun(e, [t])
      }),
      (ns.prototype.log1p = function (t) {
        var e = new Oa(t.shape, 'return log(1.0 + x);')
        return this.compileAndRun(e, [t])
      }),
      (ns.prototype.sqrt = function (t) {
        var e = new Oa(t.shape, 'return sqrt(x);')
        return this.compileAndRun(e, [t])
      }),
      (ns.prototype.rsqrt = function (t) {
        if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.rsqrt(t)
        var e = new Oa(t.shape, 'return inversesqrt(x);')
        return this.compileAndRun(e, [t])
      }),
      (ns.prototype.reciprocal = function (t) {
        var e = new Oa(t.shape, 'return 1.0 / x;')
        return this.compileAndRun(e, [t])
      }),
      (ns.prototype.relu = function (t) {
        var e = f.getBool('WEBGL_PACK') ? new Fa(t.shape, $a) : new Oa(t.shape, za)
        return this.compileAndRun(e, [t])
      }),
      (ns.prototype.relu6 = function (t) {
        var e = f.getBool('WEBGL_PACK') ? new Fa(t.shape, Ya) : new Oa(t.shape, Ga)
        return this.compileAndRun(e, [t])
      }),
      (ns.prototype.prelu = function (t, e) {
        var n = f.getBool('WEBGL_PACK_BINARY_OPERATIONS') ? new Wo(Ko, t.shape, e.shape) : new Lo(qo, t.shape, e.shape)
        return this.compileAndRun(n, [t, e])
      }),
      (ns.prototype.elu = function (t) {
        if (f.getBool('WEBGL_PACK_UNARY_OPERATIONS')) return this.packedUnaryOp(t, Ja, t.dtype)
        var e = new Oa(t.shape, Ua)
        return this.compileAndRun(e, [t])
      }),
      (ns.prototype.eluDer = function (t, e) {
        var n = f.getBool('WEBGL_PACK_BINARY_OPERATIONS')
          ? new Wo(
              '\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n',
              t.shape,
              e.shape,
            )
          : new Lo('return (b >= 1.0) ? a : a * (b + 1.0);', t.shape, e.shape)
        return this.compileAndRun(n, [t, e])
      }),
      (ns.prototype.selu = function (t) {
        var e = new Oa(
          t.shape,
          '\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = 1.7580993408473768;\n  float scale = 1.0507009873554805;\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n',
        )
        return this.compileAndRun(e, [t])
      }),
      (ns.prototype.int = function (t) {
        var e = new Oa(t.shape, 'return float(int(x));')
        return this.compileAndRun(e, [t], 'int32')
      }),
      (ns.prototype.clip = function (t, e, n) {
        var r,
          n = (r = new (f.getBool('WEBGL_PACK_CLIP') ? $o : Xo)(t.shape)).getCustomSetupFunc(e, n)
        return this.compileAndRun(r, [t], null, n)
      }),
      (ns.prototype.abs = function (t) {
        if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.abs(t)
        if (f.getBool('WEBGL_PACK_UNARY_OPERATIONS')) return this.packedUnaryOp(t, Wa, t.dtype)
        var e = new Oa(t.shape, Wa)
        return this.compileAndRun(e, [t])
      }),
      (ns.prototype.complexAbs = function (t) {
        var e = this.texData.get(t.dataId),
          n = new zo(t.shape),
          e = [
            this.makeComplexComponentTensorInfo(t, e.complexTensors.real),
            this.makeComplexComponentTensorInfo(t, e.complexTensors.imag),
          ]
        return this.compileAndRun(n, e)
      }),
      (ns.prototype.sigmoid = function (t) {
        var e = new Oa(t.shape, 'return 1.0 / (1.0 + exp(-1.0 * x));')
        return this.compileAndRun(e, [t])
      }),
      (ns.prototype.softplus = function (t) {
        var e = new Oa(
          t.shape,
          '\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n',
        )
        return this.compileAndRun(e, [t])
      }),
      (ns.prototype.sin = function (t) {
        var e = new Oa(t.shape, 'if (isnan(x)) return x;\n  return sin(x);\n')
        return this.compileAndRun(e, [t])
      }),
      (ns.prototype.cos = function (t) {
        var e = new Oa(t.shape, 'if (isnan(x)) return x;\n  return cos(x);\n')
        return this.compileAndRun(e, [t])
      }),
      (ns.prototype.tan = function (t) {
        var e = new Oa(t.shape, 'return tan(x);')
        return this.compileAndRun(e, [t])
      }),
      (ns.prototype.asin = function (t) {
        var e = new Oa(t.shape, 'if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n')
        return this.compileAndRun(e, [t])
      }),
      (ns.prototype.acos = function (t) {
        var e = new Oa(t.shape, 'if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n')
        return this.compileAndRun(e, [t])
      }),
      (ns.prototype.atan = function (t) {
        var e = new Oa(t.shape, 'if (isnan(x)) return x;\n  return atan(x);\n')
        return this.compileAndRun(e, [t])
      }),
      (ns.prototype.atan2 = function (t, e) {
        var n = f.getBool('WEBGL_PACK_BINARY_OPERATIONS')
          ? new Wo(
              '\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n',
              t.shape,
              e.shape,
            )
          : new Lo('\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n', t.shape, e.shape)
        return this.compileAndRun(n, [t, e])
      }),
      (ns.prototype.sinh = function (t) {
        var e = new Oa(t.shape, '\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n')
        return this.compileAndRun(e, [t])
      }),
      (ns.prototype.cosh = function (t) {
        var e = new Oa(t.shape, '\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n')
        return this.compileAndRun(e, [t])
      }),
      (ns.prototype.tanh = function (t) {
        var e = new Oa(t.shape, '\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n')
        return this.compileAndRun(e, [t])
      }),
      (ns.prototype.asinh = function (t) {
        var e = new Oa(t.shape, 'if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));')
        return this.compileAndRun(e, [t])
      }),
      (ns.prototype.acosh = function (t) {
        var e = new Oa(t.shape, 'if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\n  return log(x + sqrt(x * x - 1.0));')
        return this.compileAndRun(e, [t])
      }),
      (ns.prototype.atanh = function (t) {
        var e = new Oa(
          t.shape,
          'if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;',
        )
        return this.compileAndRun(e, [t])
      }),
      (ns.prototype.erf = function (t) {
        var e = new Oa(
          t.shape,
          '\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = 0.3275911;\n  float a1 = 0.254829592;\n  float a2 = -0.284496736;\n  float a3 = 1.421413741;\n  float a4 = -1.453152027;\n  float a5 = 1.061405429;\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n',
        )
        return this.compileAndRun(e, [t])
      }),
      (ns.prototype.step = function (t, e) {
        e = new Oa(t.shape, La + '\n    return x > 0.0 ? 1.0 : float(' + (void 0 === e ? 0 : e) + ');\n  ')
        return this.compileAndRun(e, [t])
      }),
      (ns.prototype.conv2dByMatMul = function (t, e, n, r, o, i) {
        var a = t.shape,
          s = this.texData.get(t.dataId),
          u = n.inChannels,
          c = a[0] * a[1] * a[2],
          l = n.outChannels,
          h = 'channelsLast' === n.dataFormat,
          l = (1 == c || 1 === l) && 1e3 < u,
          u = a[2] % 2 != 0 && !!s.isPacked
        if (l || !f.getBool('WEBGL_LAZILY_UNPACK') || !f.getBool('WEBGL_PACK_BINARY_OPERATIONS') || !u) {
          ;(l = h ? a[0] * a[1] * a[2] : a[0] * a[2] * a[3]),
            (u = this.reshape(t, [1, l, n.inChannels])),
            (l = this.reshape(e, [1, n.inChannels, n.outChannels]))
          return this.reshape(
            this.fusedBatchMatMul({
              a: u,
              b: l,
              transposeA: !1,
              transposeB: !1,
              bias: r,
              activation: o,
              preluActivationWeights: i,
            }),
            n.outShape,
          )
        }
        var a = h ? a[0] * a[1] * (a[2] + 1) : a[0] * a[2] * (a[3] + 1),
          p = { dataId: t.dataId, shape: [1, a, n.inChannels], dtype: t.dtype },
          t = s.shape
        ;(s.shape = s.shape.slice()),
          s.shape[s.shape.length - 2]++,
          A(Ae(s.shape, p.shape), function () {
            return 'packed reshape ' + s.shape + ' to ' + p.shape + " isn't free"
          })
        ;(e = this.reshape(e, [1, n.inChannels, n.outChannels])),
          (o = this.fusedBatchMatMul({
            a: p,
            b: e,
            transposeA: !1,
            transposeB: !1,
            bias: r,
            activation: o,
            preluActivationWeights: i,
          })),
          (i = this.texData.get(o.dataId))
        return (
          A(i.isPacked, function () {
            return 'batchMatMul result is expected to be packed'
          }),
          (s.shape = t),
          (i.shape = n.outShape),
          Pt.makeTensorFromDataId(o.dataId, n.outShape, o.dtype)
        )
      }),
      (ns.prototype.conv2dWithIm2Row = function (t, e, n, r, o, i) {
        var a = n.filterWidth,
          s = n.filterHeight,
          u = n.inChannels,
          c = n.outWidth,
          l = n.outHeight,
          h = 'channelsLast' === n.dataFormat,
          a = a * s * u,
          s = l * c,
          u = [a, s],
          t = t.squeeze([0]),
          e = e.reshape([1, a, -1]),
          a = new Ki(u, t.shape, n),
          a = this.compileAndRun(a, [t]).reshape([1, u[0], u[1]]),
          t = null != r,
          u = null != i,
          o = o ? Za(o, !0) : null,
          o = new Zi(a.shape, [1, s, n.outChannels], !0, !1, t, o, u),
          e = [a, e]
        r && e.push(r), u && e.push(i)
        e = this.compileAndRun(o, e)
        return h ? e.reshape([1, l, c, n.outChannels]) : e.reshape([1, n.outChannels, l, c])
      }),
      (ns.prototype.fusedConv2d = function (t) {
        var e = t.input,
          n = t.filter,
          r = t.convInfo,
          o = t.bias,
          i = t.activation,
          a = t.preluActivationWeights
        if (
          1 === r.filterHeight &&
          1 === r.filterWidth &&
          1 === r.dilationHeight &&
          1 === r.dilationWidth &&
          1 === r.strideHeight &&
          1 === r.strideWidth &&
          ('SAME' === r.padInfo.type || 'VALID' === r.padInfo.type)
        )
          return this.conv2dByMatMul(e, n, r, o, i, a)
        if (f.getBool('WEBGL_CONV_IM2COL') && 1 === e.shape[0]) return this.conv2dWithIm2Row(e, n, r, o, i, a)
        var s = null != o,
          t = null != a,
          i = i ? Za(i, !1) : null,
          t = new ii(r, s, i, t),
          n = [e, n]
        return o && n.push(o), a && n.push(a), this.compileAndRun(t, n)
      }),
      (ns.prototype.conv2d = function (t, e, n) {
        if (
          1 === n.filterHeight &&
          1 === n.filterWidth &&
          1 === n.dilationHeight &&
          1 === n.dilationWidth &&
          1 === n.strideHeight &&
          1 === n.strideWidth &&
          ('SAME' === n.padInfo.type || 'VALID' === n.padInfo.type)
        )
          return this.conv2dByMatMul(t, e, n)
        if (f.getBool('WEBGL_CONV_IM2COL') && 1 === t.shape[0]) return this.conv2dWithIm2Row(t, e, n)
        n = new ii(n)
        return this.compileAndRun(n, [t, e])
      }),
      (ns.prototype.conv2dDerInput = function (t, e, n) {
        n = new ti(n)
        return this.compileAndRun(n, [t, e])
      }),
      (ns.prototype.conv2dDerFilter = function (t, e, n) {
        n = new Zo(n)
        return this.compileAndRun(n, [t, e])
      }),
      (ns.prototype.fusedDepthwiseConv2D = function (t) {
        var e = t.input,
          n = t.filter,
          r = t.convInfo,
          o = t.bias,
          i = t.activation,
          a = t.preluActivationWeights,
          s = f.getBool('WEBGL_PACK_DEPTHWISECONV') && r.strideWidth <= 2 && r.outChannels / r.inChannels == 1,
          t = i ? Za(i, s) : null,
          i = [e, n],
          e = null != o,
          n = null != a
        return e && i.push(o), n && i.push(a), (n = new (s ? ui : si)(r, e, t, n)), this.compileAndRun(n, i)
      }),
      (ns.prototype.depthwiseConv2D = function (t, e, n) {
        n = new (f.getBool('WEBGL_PACK_DEPTHWISECONV') && n.strideWidth <= 2 && n.outChannels / n.inChannels == 1 ? ui : si)(n)
        return this.compileAndRun(n, [t, e])
      }),
      (ns.prototype.depthwiseConv2DDerInput = function (t, e, n) {
        n = new oi(n)
        return this.compileAndRun(n, [t, e])
      }),
      (ns.prototype.depthwiseConv2DDerFilter = function (t, e, n) {
        n = new ri(n)
        return this.compileAndRun(n, [t, e])
      }),
      (ns.prototype.conv3d = function (t, e, n) {
        n = new ai(n)
        return this.compileAndRun(n, [t, e])
      }),
      (ns.prototype.conv3dDerInput = function (t, e, n) {
        n = new ni(n)
        return this.compileAndRun(n, [t, e])
      }),
      (ns.prototype.conv3dDerFilter = function (t, e, n) {
        n = new ei(n)
        return this.compileAndRun(n, [t, e])
      }),
      (ns.prototype.maxPool = function (t, e) {
        e = new aa(e, 'max', !1)
        return this.compileAndRun(e, [t])
      }),
      (ns.prototype.avgPool = function (t, e) {
        e = new aa(e, 'avg', !1)
        return this.compileAndRun(e, [t], 'float32')
      }),
      (ns.prototype.maxPoolBackprop = function (t, e, n, r) {
        var o = new aa(r, 'max', !0),
          o = this.compileAndRun(o, [e]),
          r = new Ji(r),
          e = this.compileAndRun(r, [t, o], e.dtype)
        return o.dispose(), e
      }),
      (ns.prototype.avgPoolBackprop = function (t, e, n) {
        n = new Oo(n)
        return this.compileAndRun(n, [t], e.dtype)
      }),
      (ns.prototype.cast = function (t, e) {
        return no(t, e, this)
      }),
      (ns.prototype.unstack = function (t, e) {
        for (var n = t.shape[e], r = new Array(t.rank - 1), o = 0, i = 0; i < t.rank; i++) i !== e && (r[o++] = t.shape[i])
        var a = new Array(t.rank).fill(0),
          s = t.shape.slice()
        s[e] = 1
        for (var u = new Array(n), i = 0; i < u.length; i++) u[(a[e] = i)] = this.slice(t, a, s).reshape(r)
        return u
      }),
      (ns.prototype.avgPool3d = function (t, e) {
        e = new sa(e, 'avg', !1)
        return this.compileAndRun(e, [t], 'float32')
      }),
      (ns.prototype.avgPool3dBackprop = function (t, e, n) {
        n = new Fo(n)
        return this.compileAndRun(n, [t], e.dtype)
      }),
      (ns.prototype.maxPool3d = function (t, e) {
        e = new sa(e, 'max', !1)
        return this.compileAndRun(e, [t], 'float32')
      }),
      (ns.prototype.maxPool3dBackprop = function (t, e, n, r) {
        var o = new sa(r, 'max', !0),
          o = this.compileAndRun(o, [e]),
          r = new Qi(r),
          e = this.compileAndRun(r, [t, o], e.dtype)
        return o.dispose(), e
      }),
      (ns.prototype.reshape = function (t, e) {
        var n = this.texData.get(t.dataId)
        if (!n.isPacked || Ae(t.shape, e) || (null !== n.texture && Ae(n.shape, e))) return ro(t, e)
        e = this.packedReshape(t, e)
        return Pt.makeTensorFromDataId(e.dataId, e.shape, e.dtype)
      }),
      (ns.prototype.resizeBilinear = function (t, e, n, r) {
        r = new (f.getBool('WEBGL_PACK_IMAGE_OPERATIONS') ? pa : ha)(t.shape, e, n, r)
        return this.compileAndRun(r, [t], 'float32')
      }),
      (ns.prototype.resizeBilinearBackprop = function (t, e, n) {
        n = new la(t, e, n)
        return this.compileAndRun(n, [t])
      }),
      (ns.prototype.resizeNearestNeighbor = function (t, e, n, r) {
        r = new fa(t.shape, e, n, r)
        return this.compileAndRun(r, [t])
      }),
      (ns.prototype.resizeNearestNeighborBackprop = function (t, e, n) {
        n = new da(t, e, n)
        return this.compileAndRun(n, [t])
      }),
      (ns.prototype.multinomial = function (t, e, n, r) {
        var o = e ? t : Fr(t),
          e = o.shape[0],
          t = o.shape[1],
          n = new na(e, t, n),
          r = n.getCustomSetupFunc(r)
        return this.compileAndRun(n, [o], 'int32', r)
      }),
      (ns.prototype.oneHot = function (t, e, n, r) {
        r = new ta(t.size, e, n, r)
        return this.compileAndRun(r, [t])
      }),
      (ns.prototype.diag = function (t) {
        var e = new fi(t.size)
        return this.compileAndRun(e, [t])
      }),
      (ns.prototype.nonMaxSuppression = function (t, e, n, r, o) {
        return (
          Ve('tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead'),
          uo(t.dataSync(), e.dataSync(), n, r, o)
        )
      }),
      (ns.prototype.cropAndResize = function (t, e, n, r, o, i) {
        i = new ci(t.shape, e.shape, r, o, i)
        return this.compileAndRun(i, [t, e, n], 'float32')
      }),
      (ns.prototype.depthToSpace = function (t, e, n) {
        A(1 < e, function () {
          return 'blockSize should be > 1 for depthToSpace, but was: ' + e
        })
        var r = t.shape[0],
          o = 'NHWC' === n ? t.shape[1] : t.shape[2],
          i = 'NHWC' === n ? t.shape[2] : t.shape[3],
          a = 'NHWC' === n ? t.shape[3] : t.shape[1],
          o = o * e,
          i = i * e,
          a = a / (e * e),
          n = new wi('NHWC' === n ? [r, o, i, a] : [r, a, o, i], e, n)
        return this.compileAndRun(n, [t])
      }),
      (ns.prototype.split = po),
      (ns.prototype.scatterND = function (t, e, n) {
        var r = _r(0, t, n),
          o = r.sliceRank,
          i = r.numUpdates,
          a = r.sliceSize,
          s = r.strides,
          u = r.outputSize,
          r = [u / a, a],
          t = t.reshape([i, o]),
          a = e.reshape([i, a])
        if (0 === u) return ro(cn([]), n)
        ;(u = hn(0)), (r = new ga(i, o, t.rank, a.rank, s, r))
        return this.compileAndRun(r, [a, t, u]).reshape(n)
      }),
      (ns.prototype.sparseToDense = function (t, e, n, r) {
        var o = _r(0, t, n),
          i = o.sliceRank,
          a = o.numUpdates,
          s = o.strides,
          o = o.outputSize,
          o = new ga(a, i, t.rank, e.rank, s, [o, 1])
        return this.compileAndRun(o, [e, t, r]).reshape(n)
      }),
      (ns.prototype.fft = function (t) {
        return this.fftImpl(t, !1)
      }),
      (ns.prototype.ifft = function (t) {
        return this.fftImpl(t, !0)
      }),
      (ns.prototype.fftImpl = function (t, e) {
        var n = this.texData.get(t.dataId),
          r = new bi('return real * expR - imag * expI;', t.shape, e),
          e = new bi('return real * expI + imag * expR;', t.shape, e),
          n = [
            this.makeComplexComponentTensorInfo(t, n.complexTensors.real),
            this.makeComplexComponentTensorInfo(t, n.complexTensors.imag),
          ],
          r = this.compileAndRun(r, n),
          n = this.compileAndRun(e, n),
          t = this.complex(r, n).as2D(t.shape[0], t.shape[1])
        return r.dispose(), n.dispose(), t
      }),
      (ns.prototype.gatherND = function (t, e) {
        var n = e.shape,
          r = n[n.length - 1],
          o = wr(t, e),
          i = o[0],
          a = o[1],
          n = o[2],
          o = o[3],
          e = e.reshape([a, r]),
          t = t.reshape([t.size / n, n]),
          n = new _i(r, o, [a, n])
        return this.compileAndRun(n, [t, e]).reshape(i)
      }),
      (ns.prototype.fill = function (t, e, n) {
        if ('string' === (n = n || q(e))) {
          var r = P(n, D(t))
          return r.fill(e), Pt.makeTensor(r, t, n, this)
        }
        ;(t = new Ci(t, e)), (e = t.getCustomSetupFunc(e))
        return this.compileAndRun(t, [], n, e)
      }),
      (ns.prototype.onesLike = function (t) {
        if ('string' === t.dtype) throw new Error('onesLike is not supported under string dtype')
        return this.fill(t.shape, 1, t.dtype)
      }),
      (ns.prototype.zerosLike = function (t) {
        return this.fill(t.shape, 'string' === t.dtype ? '' : 0, t.dtype)
      }),
      (ns.prototype.linspace = oo),
      (ns.prototype.makeTensorInfo = function (t, e) {
        var n = this.write(null, t, e)
        return (this.texData.get(n).usage = null), { dataId: n, shape: t, dtype: e }
      }),
      (ns.prototype.makeOutput = function (t, e) {
        var n = this.makeTensorInfo(t, e).dataId
        return Pt.makeTensorFromDataId(n, t, e, this)
      }),
      (ns.prototype.unpackTensor = function (t) {
        var e = new Ma(t.shape)
        return this.runWebGLProgram(e, [t], t.dtype)
      }),
      (ns.prototype.packTensor = function (t) {
        var e = new ea(t.shape)
        return this.runWebGLProgram(e, [t], t.dtype, null, !0)
      }),
      (ns.prototype.packedReshape = function (t, e) {
        var n = [Ee(t.shape)].concat(Se(t.shape)),
          r = { dtype: t.dtype, shape: n, dataId: t.dataId },
          o = [Ee(e)].concat(Se(e)),
          n = new ca(o, n),
          t = this.runWebGLProgram(n, [r], t.dtype, null, !0)
        return { dataId: t.dataId, shape: e, dtype: t.dtype }
      }),
      (ns.prototype.decode = function (t) {
        var e = this.texData.get(t),
          n = e.isPacked,
          r = e.shape,
          o = e.dtype,
          e = _e(r),
          n = new (n ? di : pi)(e)
        return { dtype: o, shape: r, dataId: this.runWebGLProgram(n, [{ shape: e, dtype: o, dataId: t }], o, null, !0).dataId }
      }),
      (ns.prototype.runWebGLProgram = function (o, t, e, n, r) {
        var i = this
        void 0 === r && (r = !1)
        var a = this.makeTensorInfo(o.outputShape, e),
          e = this.texData.get(a.dataId)
        if (
          (o.packedOutput && (e.isPacked = !0),
          o.outPackingScheme === Wt.DENSE &&
            ((l = qt(o.outputShape)),
            (e.texShape = l.map(function (t) {
              return 2 * t
            }))),
          null != o.outTexUsage && (e.usage = o.outTexUsage),
          0 === D(a.shape))
        )
          return (e.values = M(a.dtype, 0)), a
        var s = [],
          h = t.map(function (t) {
            if ('complex64' === t.dtype)
              throw new Error(
                'GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.',
              )
            var e,
              n,
              r = i.texData.get(t.dataId)
            if (null == r.texture) {
              if (!o.packedInputs && D(t.shape) <= f.getNumber('WEBGL_SIZE_UPLOAD_UNIFORM'))
                return { shape: t.shape, texData: null, isUniform: !0, uniformValues: r.values }
              o.packedInputs && ((r.isPacked = !0), (r.shape = t.shape))
            } else !!r.isPacked != !!o.packedInputs ? ((t = r.isPacked ? i.unpackTensor(t) : i.packTensor(t)), s.push(t), (r = i.texData.get(t.dataId))) : r.isPacked && !Ae(r.shape, t.shape) && ((n = (e = t).shape), (t.shape = r.shape), (t = i.packedReshape(t, n)), s.push(t), (r = i.texData.get(t.dataId)), (e.shape = n))
            return i.uploadToGPU(t.dataId), { shape: t.shape, texData: r, isUniform: !1 }
          })
        this.uploadToGPU(a.dataId)
        var u,
          c = { shape: a.shape, texData: e, isUniform: !1 },
          l = (function (t) {
            var r = ''
            h.concat(c).forEach(function (t) {
              var e = null != t.texData && null != t.texData.slice && 0 < t.texData.slice.flatOffset,
                n = t.isUniform ? 'uniform' : t.texData.texShape
              r += t.shape + '_' + n + '_' + e
            })
            var e = t.userCode
            return t.constructor.name + '_' + r + '_' + e
          })(o),
          t = this.getAndSaveBinary(l, function () {
            return (function (t, r, e) {
              var n = r.userCode,
                o = h.map(function (t, e) {
                  var n = {
                    logicalShape: t.shape,
                    texShape: t.isUniform ? null : t.texData.texShape,
                    isUniform: t.isUniform,
                    isPacked: !t.isUniform && t.texData.isPacked,
                    flatOffset: null,
                  }
                  return (
                    null != t.texData &&
                      null != t.texData.slice &&
                      0 < t.texData.slice.flatOffset &&
                      (n.flatOffset = t.texData.slice.flatOffset),
                    { name: r.variableNames[e], shapeInfo: n }
                  )
                }),
                i = o.map(function (t) {
                  return t.shapeInfo
                }),
                a = {
                  logicalShape: e.shape,
                  texShape: e.texData.texShape,
                  isUniform: !1,
                  isPacked: e.texData.isPacked,
                  flatOffset: null,
                },
                e = Ro(o, a, n, r.packedInputs),
                s = t.createProgram(e),
                o = null,
                n = t.getUniformLocation(s, 'NAN', !1)
              1 === f.getNumber('WEBGL_VERSION') && (o = t.getUniformLocation(s, 'INFINITY', !1))
              for (var u = {}, c = 0; c < r.variableNames.length; c++) {
                var l = r.variableNames[c]
                ;(u[l] = t.getUniformLocation(s, l, !1)), (u['offset' + l] = t.getUniformLocation(s, 'offset' + l, !1))
              }
              return {
                program: r,
                source: e,
                webGLProgram: s,
                uniformLocations: u,
                inShapeInfos: i,
                outShapeInfo: a,
                infLoc: o,
                nanLoc: n,
              }
            })(i.gpgpu, o, c)
          }),
          l = null != this.activeTimers
        if (
          (l && (u = this.startTimer()),
          (function (i, a, t, e, n) {
            qi(a.inShapeInfos, t), qi([a.outShapeInfo], [e])
            var r = e.texData.texture,
              o = e.texData.texShape
            e.texData.isPacked ? i.setOutputPackedMatrixTexture(r, o[0], o[1]) : i.setOutputMatrixTexture(r, o[0], o[1]),
              i.setProgram(a.webGLProgram),
              1 === f.getNumber('WEBGL_VERSION') && null !== a.infLoc && i.gl.uniform1f(a.infLoc, 1 / 0),
              null !== a.nanLoc && i.gl.uniform1f(a.nanLoc, NaN),
              t.forEach(function (t, e) {
                var n = a.program.variableNames[e],
                  r = a.uniformLocations[n],
                  o = a.uniformLocations['offset' + n]
                null != r &&
                  (t.isUniform
                    ? D(t.shape) < 2
                      ? i.gl.uniform1f(r, t.uniformValues[0])
                      : ((n = t.uniformValues) instanceof Float32Array || (n = new Float32Array(n)), i.gl.uniform1fv(r, n))
                    : (null != t.texData.slice && null != o && i.gl.uniform1i(o, t.texData.slice.flatOffset),
                      i.setInputMatrixTexture(t.texData.texture, r, e)))
              }),
              null != n && n(i, a.webGLProgram),
              i.executeProgram()
          })(this.gpgpu, t, h, c, n),
          s.forEach(function (t) {
            return i.disposeData(t.dataId)
          }),
          l && ((u = this.endTimer(u)), this.activeTimers.push({ name: o.constructor.name, query: this.getQueryTime(u) })),
          f.getBool('WEBGL_LAZILY_UNPACK') || !e.isPacked || !1 !== r)
        )
          return a
        r = this.unpackTensor(a)
        return this.disposeData(a.dataId), r
      }),
      (ns.prototype.compileAndRun = function (t, e, n, r, o) {
        void 0 === o && (o = !1), (n = n || e[0].dtype)
        o = this.runWebGLProgram(t, e, n, r, o)
        return Pt.makeTensorFromDataId(o.dataId, o.shape, o.dtype)
      }),
      (ns.prototype.getAndSaveBinary = function (t, e) {
        return t in this.binaryCache || (this.binaryCache[t] = e()), this.binaryCache[t]
      }),
      (ns.prototype.getTextureManager = function () {
        return this.textureManager
      }),
      (ns.prototype.dispose = function () {
        var e = this
        this.disposed ||
          (f.getBool('IS_TEST') ||
            Object.keys(this.binaryCache).forEach(function (t) {
              e.gpgpu.deleteProgram(e.binaryCache[t].webGLProgram), delete e.binaryCache[t]
            }),
          this.textureManager.dispose(),
          null != this.canvas && 'undefined' != typeof HTMLCanvasElement && this.canvas instanceof HTMLCanvasElement
            ? this.canvas.remove()
            : (this.canvas = null),
          this.gpgpuCreatedLocally && ((this.gpgpu.program = null), this.gpgpu.dispose()),
          (this.disposed = !0))
      }),
      (ns.prototype.floatPrecision = function () {
        var n = this
        return (
          null == this.floatPrecisionValue &&
            (this.floatPrecisionValue = Ge(function () {
              if (!f.get('WEBGL_RENDER_FLOAT32_ENABLED')) {
                var t = f.getBool('DEBUG')
                f.set('DEBUG', !1)
                var e = n.abs(hn(1e-8)).dataSync()[0]
                if ((f.set('DEBUG', t), 0 < e)) return 32
              }
              return 16
            })),
          this.floatPrecisionValue
        )
      }),
      (ns.prototype.epsilon = function () {
        return 32 === this.floatPrecision() ? 1e-7 : 1e-4
      }),
      (ns.prototype.uploadToGPU = function (t) {
        var e,
          n,
          r,
          o,
          i,
          a,
          s = this.texData.get(t),
          u = s.shape,
          c = s.dtype,
          l = s.values,
          h = s.texture,
          p = s.usage,
          d = s.isPacked
        null == h &&
          ((n = null != this.activeTimers) && (e = tt()),
          null == (r = s.texShape) && ((r = Re(u, d)), (s.texShape = r)),
          null != l
            ? ((i = _e(u)),
              (a = void 0),
              (o = r[1]),
              (t = r[0]),
              (h = l instanceof Uint8Array),
              (a = d ? ((o = (u = Kt(r[0], r[1]))[0]), (t = u[1]), new yi(i, [t, o], h)) : new gi(i, [t, o], h)),
              (i = this.makeTensorInfo([t, o], c)),
              (this.texData.get(i.dataId).usage = h ? zt.PIXELS : zt.UPLOAD),
              this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(i.dataId), o, t, l),
              (l = this.runWebGLProgram(a, [i], c, null, !0)),
              (a = this.texData.get(l.dataId)),
              (s.texture = a.texture),
              (s.texShape = a.texShape),
              (s.isPacked = a.isPacked),
              (s.usage = a.usage),
              this.disposeData(i.dataId),
              this.texData.delete(l.dataId),
              (s.values = null),
              n && (this.uploadWaitMs += tt() - e))
            : ((d = this.acquireTexture(r, p, c, d)), (s.texture = d)))
      }),
      (ns.prototype.convertAndCacheOnCPU = function (t, e) {
        var n = this.texData.get(t),
          r = n.dtype
        return (
          this.releaseGPUData(t),
          null != e &&
            (n.values = (function (t, e) {
              if ('float32' === e || 'complex64' === e) return t
              if ('int32' !== e && 'bool' !== e) throw new Error('Unknown dtype ' + e)
              for (var n = new ('int32' === e ? Int32Array : Uint8Array)(t.length), r = 0; r < n.length; ++r)
                n[r] = Math.round(t[r])
              return n
            })(e, r)),
          n.values
        )
      }),
      (ns.prototype.acquireTexture = function (t, e, n, r) {
        return (
          (this.numBytesInGPU += this.computeBytes(t, n)),
          !this.warnedAboutMemory &&
            this.numBytesInGPU > 1024 * this.numMBBeforeWarning * 1024 &&
            ((n = (this.numBytesInGPU / 1024 / 1024).toFixed(2)),
            (this.warnedAboutMemory = !0),
            console.warn('High memory usage in GPU: ' + n + ' MB, most likely due to a memory leak')),
          this.textureManager.acquireTexture(t, e, r)
        )
      }),
      (ns.prototype.computeBytes = function (t, e) {
        return t[0] * t[1] * G(e)
      }),
      ns)
  function ns(t) {
    var e,
      n,
      r = ts.call(this) || this
    if (
      ((r.pendingRead = new WeakMap()),
      (r.pendingDisposal = new WeakSet()),
      (r.dataRefCount = new WeakMap()),
      (r.numBytesInGPU = 0),
      (r.uploadWaitMs = 0),
      (r.downloadWaitMs = 0),
      (r.warnedAboutMemory = !1),
      (r.pendingDeletes = 0),
      (r.disposed = !1),
      !f.getBool('HAS_WEBGL'))
    )
      throw new Error('WebGL is not supported on this device')
    return (
      null == t
        ? ((n = jt(f.getNumber('WEBGL_VERSION'))),
          (r.binaryCache = ((e = f.getNumber('WEBGL_VERSION')) in Qa || (Qa[e] = {}), Qa[e])),
          (r.gpgpu = new Hi(n)),
          (r.canvas = n.canvas),
          (r.gpgpuCreatedLocally = !0))
        : ((r.gpgpu = t), (r.binaryCache = {}), (r.gpgpuCreatedLocally = !1), (r.canvas = t.gl.canvas)),
      (r.textureManager = new _a(r.gpgpu)),
      (r.numMBBeforeWarning =
        null == f.global.screen
          ? 1024
          : (f.global.screen.height * f.global.screen.width * window.devicePixelRatio * 600) / 1024 / 1024),
      (r.texData = new Pr(r, Pt)),
      r
    )
  }
  Bt() &&
    Pt.registerBackend(
      'webgl',
      function () {
        return new es()
      },
      2,
    )
  var rs = on({
      square_: function (t) {
        var n = qe(t, 'x', 'square'),
          t = [n]
        return Pt.runKernelFunc(
          function (t, e) {
            return e([n]), t.square(n)
          },
          { x: n },
          null,
          'Square',
          {},
          t,
          [],
        )
      },
    }),
    os = 'SquaredDifference',
    is = on({
      squaredDifference_: function (t, e) {
        var n = qe(t, 'a', 'squaredDifference'),
          r = qe(e, 'b', 'squaredDifference'),
          t = At(n, r),
          n = t[0],
          r = t[1]
        Vr(n.shape, r.shape)
        ;(e = { a: n, b: r }), (t = [n, r])
        return Pt.runKernelFunc(
          function (t, e) {
            t = t.squaredDifference(n, r)
            return e([n, r]), t
          },
          e,
          function (t, e) {
            var n = e[0],
              r = e[1],
              o = hn(2)
            return {
              a: function () {
                return t.mul(n.sub(r).mul(o))
              },
              b: function () {
                return t.mul(r.sub(n).mul(o))
              },
            }
          },
          os,
          {},
          t,
          [],
        )
      },
    }),
    as = on({
      abs_: function (t) {
        var n = qe(t, 'x', 'abs')
        return 'complex64' === n.dtype
          ? Pt.runKernelFunc(
              function (t) {
                return t.complexAbs(n)
              },
              { $x: n },
            )
          : Pt.runKernelFunc(
              function (t, e) {
                t = t.abs(n)
                return e([n]), t
              },
              { x: n },
              function (t, e) {
                var n = e[0]
                return {
                  x: function () {
                    return t.mul(n.toFloat().step(-1))
                  },
                }
              },
              'Abs',
            )
      },
    }),
    ss = on({
      acos_: function (t) {
        var n = qe(t, 'x', 'acos')
        return Pt.runKernelFunc(
          function (t, e) {
            t = t.acos(n)
            return e([n]), t
          },
          { $x: n },
          function (t, e) {
            var n = e[0]
            return {
              $x: function () {
                return t.divStrict(hn(1).sub(n.toFloat().square()).sqrt()).neg()
              },
            }
          },
        )
      },
    }),
    us = on({
      acosh_: function (t) {
        var n = qe(t, 'x', 'acosh')
        return Pt.runKernelFunc(
          function (t, e) {
            t = t.acosh(n)
            return e([n]), t
          },
          { $x: n },
          function (t, e) {
            var n = e[0]
            return {
              $x: function () {
                return t.divStrict(n.toFloat().square().sub(1).sqrt())
              },
            }
          },
        )
      },
    }),
    cs = on({
      asin_: function (t) {
        var n = qe(t, 'x', 'asin')
        return Pt.runKernelFunc(
          function (t, e) {
            t = t.asin(n)
            return e([n]), t
          },
          { $x: n },
          function (t, e) {
            var n = e[0]
            return {
              $x: function () {
                return t.divStrict(hn(1).sub(n.toFloat().square()).sqrt())
              },
            }
          },
        )
      },
    }),
    ls = on({
      asinh_: function (t) {
        var n = qe(t, 'x', 'asinh')
        return Pt.runKernelFunc(
          function (t, e) {
            t = t.asinh(n)
            return e([n]), t
          },
          { $x: n },
          function (t, e) {
            var n = e[0]
            return {
              $x: function () {
                return t.divStrict(hn(1).add(n.toFloat().square()).sqrt())
              },
            }
          },
        )
      },
    }),
    hs = on({
      atan_: function (t) {
        var n = qe(t, 'x', 'atan')
        return Pt.runKernelFunc(
          function (t, e) {
            t = t.atan(n)
            return e([n]), t
          },
          { $x: n },
          function (t, e) {
            var n = e[0]
            return {
              $x: function () {
                return t.div(n.toFloat().square().add(1))
              },
            }
          },
        )
      },
    }),
    ps = on({
      atanh_: function (t) {
        var n = qe(t, 'x', 'atanh')
        return Pt.runKernelFunc(
          function (t, e) {
            t = t.atanh(n)
            return e([n]), t
          },
          { $x: n },
          function (t, e) {
            var n = e[0]
            return {
              $x: function () {
                return t.div(hn(1).sub(n.toFloat().square()))
              },
            }
          },
        )
      },
    }),
    ds = on({
      ceil_: function (t) {
        var e = qe(t, 'x', 'ceil')
        return Pt.runKernelFunc(
          function (t) {
            return t.ceil(e)
          },
          { $x: e },
          function (t) {
            return {
              $x: function () {
                return wn(t)
              },
            }
          },
        )
      },
    }),
    fs = on({
      clipByValue_: function (t, r, o) {
        var n = qe(t, 'x', 'clipByValue')
        A(r <= o, function () {
          return 'Error in clip: min (' + r + ') must be less than or equal to max (' + o + ').'
        })
        var e = [n],
          t = { min: r, max: o }
        return Pt.runKernelFunc(
          function (t, e) {
            t = t.clip(n, r, o)
            return e([n]), t
          },
          { x: n },
          function (t, e) {
            var n = e[0]
            return {
              x: function () {
                return t.where(n.greaterEqual(r).logicalAnd(n.lessEqual(o)), wn(t))
              },
            }
          },
          'ClipByValue',
          t,
          e,
        )
      },
    }),
    vs = on({
      cos_: function (t) {
        var n = qe(t, 'x', 'cos'),
          t = [n]
        return Pt.runKernelFunc(
          function (t, e) {
            t = t.cos(n)
            return e([n]), t
          },
          { x: n },
          function (t, e) {
            var n = e[0]
            return {
              x: function () {
                return n.toFloat().sin().neg().mul(t)
              },
            }
          },
          'Cos',
          {},
          t,
        )
      },
    }),
    ms = on({
      cosh_: function (t) {
        var n = qe(t, 'x', 'cosh')
        return Pt.runKernelFunc(
          function (t, e) {
            t = t.cosh(n)
            return e([n]), t
          },
          { $x: n },
          function (t, e) {
            var n = e[0]
            return {
              $x: function () {
                return n.toFloat().sinh().mulStrict(t)
              },
            }
          },
        )
      },
    }),
    gs = on({
      erf_: function (t) {
        var n = qe(t, 'x', 'erf')
        return (
          A('int32' === n.dtype || 'float32' === n.dtype, function () {
            return 'Input dtype must be `int32` or `float32`.'
          }),
          'int32' === n.dtype && (n = n.toFloat()),
          Pt.runKernelFunc(
            function (t, e) {
              t = t.erf(n)
              return e([n]), t
            },
            { $x: n },
            function (t, e) {
              var n = e[0]
              return {
                $x: function () {
                  return t.mul(
                    n
                      .square()
                      .neg()
                      .exp()
                      .mul(2 / Math.sqrt(Math.PI)),
                  )
                },
              }
            },
          )
        )
      },
    }),
    ys = on({
      exp_: function (t) {
        var n = qe(t, 'x', 'exp')
        return Pt.runKernelFunc(
          function (t, e) {
            t = t.exp(n)
            return e([t]), t
          },
          { x: n },
          function (t, e) {
            return {
              x: function () {
                return t.mulStrict(e[0])
              },
            }
          },
          'Exp',
          {},
          [],
          [!0],
        )
      },
    }),
    bs = on({
      expm1_: function (t) {
        var n = qe(t, 'x', 'expm1')
        return Pt.runKernelFunc(
          function (t, e) {
            t = t.expm1(n)
            return e([n]), t
          },
          { $x: n },
          function (t, e) {
            var n = e[0]
            return {
              $x: function () {
                return t.mul(n.exp())
              },
            }
          },
        )
      },
    }),
    xs = on({
      floor_: function (t) {
        var e = qe(t, 'x', 'floor')
        return Pt.runKernelFunc(
          function (t) {
            return t.floor(e)
          },
          { $x: e },
          function (t) {
            return {
              $x: function () {
                return wn(t)
              },
            }
          },
        )
      },
    }),
    ws = on({
      log_: function (t) {
        var n = qe(t, 'x', 'log'),
          t = [n]
        return Pt.runKernelFunc(
          function (t, e) {
            t = t.log(n)
            return e([n]), t
          },
          { x: n },
          function (t, e) {
            var n = e[0]
            return {
              x: function () {
                return t.div(n.toFloat())
              },
            }
          },
          'Log',
          {},
          t,
        )
      },
    }),
    Cs = on({
      log1p_: function (t) {
        var n = qe(t, 'x', 'log1p')
        return Pt.runKernelFunc(
          function (t, e) {
            t = t.log1p(n)
            return e([n]), t
          },
          { $x: n },
          function (t, e) {
            var n = e[0]
            return {
              $x: function () {
                return t.div(n.add(1))
              },
            }
          },
        )
      },
    }),
    Es = on({
      logSigmoid_: function (t) {
        var n = qe(t, 'x', 'logSigmoid')
        return Pt.runKernelFunc(
          function (t, e) {
            t = t.softplus(n.neg()).neg()
            return e([n]), t
          },
          { $x: n },
          function (t, e) {
            var n = e[0]
            return {
              $x: function () {
                return t.mul(n.neg().sigmoid())
              },
            }
          },
        )
      },
    }),
    Ss = on({
      neg_: function (t) {
        var e = qe(t, 'x', 'neg'),
          t = [e]
        return Pt.runKernelFunc(
          function (t) {
            return t.neg(e)
          },
          { x: e },
          function (t) {
            return {
              x: function () {
                return t.neg()
              },
            }
          },
          'Neg',
          {},
          t,
        )
      },
    }),
    _s = on({
      reciprocal_: function (t) {
        var n = qe(t, 'x', 'reciprocal')
        return Pt.runKernelFunc(
          function (t, e) {
            t = t.reciprocal(n)
            return e([n]), t
          },
          { $x: n },
          function (t, e) {
            var n = e[0]
            return {
              $x: function () {
                return t.div(n.square().neg())
              },
            }
          },
        )
      },
    }),
    Rs = on({
      round_: function (t) {
        var e = qe(t, 'x', 'round')
        return Pt.runKernelFunc(
          function (t) {
            return t.round(e)
          },
          { $x: e },
          function (t) {
            return {
              $x: function () {
                return wn(t)
              },
            }
          },
        )
      },
    }),
    Is = on({
      rsqrt_: function (t) {
        var n = qe(t, 'x', 'rsqrt'),
          t = [n]
        return Pt.runKernelFunc(
          function (t, e) {
            t = t.rsqrt(n)
            return e([n]), t
          },
          { x: n },
          function (t, e) {
            var n = e[0]
            return {
              x: function () {
                return t.div(n.pow(1.5).mul(2)).neg()
              },
            }
          },
          'Rsqrt',
          {},
          t,
        )
      },
    }),
    As = on({
      sigmoid_: function (t) {
        var n = qe(t, 'x', 'sigmoid')
        return Pt.runKernelFunc(
          function (t, e) {
            t = t.sigmoid(n)
            return e([t]), t
          },
          { x: n },
          function (t, e) {
            var n = e[0]
            return {
              x: function () {
                return t.mul(n.mul(hn(1).sub(n)))
              },
            }
          },
          'Sigmoid',
        )
      },
    }),
    Ns = on({
      sign_: function (t) {
        var e = qe(t, 'x', 'sign')
        return Pt.runKernelFunc(
          function (t) {
            return t.sign(e)
          },
          { $x: e },
          function (t) {
            return {
              $x: function () {
                return wn(t)
              },
            }
          },
        )
      },
    }),
    ks = on({
      isNaN_: function (t) {
        var e = qe(t, 'x', 'isNaN')
        return Pt.runKernelFunc(
          function (t) {
            return t.isNaN(e)
          },
          { $x: e },
          function (t) {
            return {
              $x: function () {
                return wn(t)
              },
            }
          },
        )
      },
    }),
    Ts = on({
      isInf_: function (t) {
        var e = qe(t, 'x', 'isInf')
        return Pt.runKernelFunc(
          function (t) {
            return t.isInf(e)
          },
          { $x: e },
          function (t) {
            return {
              $x: function () {
                return wn(t)
              },
            }
          },
        )
      },
    }),
    Ds = on({
      isFinite_: function (t) {
        var e = qe(t, 'x', 'isFinite')
        return Pt.runKernelFunc(
          function (t) {
            return t.isFinite(e)
          },
          { $x: e },
          function (t) {
            return {
              $x: function () {
                return wn(t)
              },
            }
          },
        )
      },
    }),
    Os = on({
      sin_: function (t) {
        var n = qe(t, 'x', 'sin'),
          t = [n]
        return Pt.runKernelFunc(
          function (t, e) {
            t = t.sin(n)
            return e([n]), t
          },
          { x: n },
          function (t, e) {
            var n = e[0]
            return {
              x: function () {
                return n.toFloat().cos().mul(t)
              },
            }
          },
          'Sin',
          {},
          t,
        )
      },
    }),
    Fs = on({
      sinh_: function (t) {
        var n = qe(t, 'x', 'sinh')
        return Pt.runKernelFunc(
          function (t, e) {
            t = t.sinh(n)
            return e([n]), t
          },
          { $x: n },
          function (t, e) {
            var n = e[0]
            return {
              $x: function () {
                return n.toFloat().cosh().mulStrict(t)
              },
            }
          },
        )
      },
    }),
    Ms = on({
      softplus_: function (t) {
        var n = qe(t, 'x', 'softplus')
        return Pt.runKernelFunc(
          function (t, e) {
            t = t.softplus(n)
            return e([n]), t
          },
          { $x: n },
          function (t, e) {
            var n = e[0]
            return {
              $x: function () {
                return t.mul(n.sigmoid())
              },
            }
          },
        )
      },
    }),
    Ps = on({
      sqrt_: function (t) {
        var n = qe(t, 'x', 'sqrt')
        return Pt.runKernelFunc(
          function (t, e) {
            t = t.sqrt(n)
            return e([n]), t
          },
          { $x: n },
          function (t, e) {
            var n = e[0]
            return {
              $x: function () {
                return t.div(n.toFloat().sqrt().mul(2))
              },
            }
          },
        )
      },
    }),
    Bs = on({
      step_: function (t, e) {
        void 0 === e && (e = 0)
        var n = qe(t, 'x', 'step')
        return Pt.runKernelFunc(
          function (t) {
            return t.step(n, e)
          },
          { $x: n },
          function (t) {
            return {
              $x: function () {
                return wn(t)
              },
            }
          },
        )
      },
    }),
    Ls = on({
      tan_: function (t) {
        var n = qe(t, 'x', 'tan')
        return Pt.runKernelFunc(
          function (t, e) {
            t = t.tan(n)
            return e([n]), t
          },
          { $x: n },
          function (t, e) {
            var n = e[0]
            return {
              $x: function () {
                return t.div(n.cos().square())
              },
            }
          },
        )
      },
    }),
    Ws = on({
      tanh_: function (t) {
        var n = qe(t, 'x', 'tanh')
        return Pt.runKernelFunc(
          function (t, e) {
            t = t.tanh(n)
            return e([t]), t
          },
          { x: n },
          function (t, e) {
            var n = e[0]
            return {
              x: function () {
                return hn(1).sub(n.square()).mulStrict(t)
              },
            }
          },
          'Tanh',
          {},
          null,
          [!0],
        )
      },
    })
  function zs(t, e, n, r, o, i) {
    var a,
      s,
      u = qe(t, 'x', 'batchNorm'),
      c = qe(e, 'mean', 'batchNorm'),
      l = qe(n, 'variance', 'batchNorm')
    return (
      null != o && (a = qe(o, 'scale', 'batchNorm')),
      null != r && (s = qe(r, 'offset', 'batchNorm')),
      A(2 === u.rank, function () {
        return 'Error in batchNorm3D: x must be rank 3 but got rank ' + u.rank + '.'
      }),
      A(2 === c.rank || 1 === c.rank, function () {
        return 'Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ' + c.rank + '.'
      }),
      A(2 === l.rank || 1 === l.rank, function () {
        return 'Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ' + l.rank + '.'
      }),
      null != a &&
        A(2 === a.rank || 1 === a.rank, function () {
          return 'Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ' + a.rank + '.'
        }),
      null != s &&
        A(2 === s.rank || 1 === s.rank, function () {
          return 'Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ' + s.rank + '.'
        }),
      Vs(u, c, l, s, a, i)
    )
  }
  function Gs(t, e, n, r, o, i) {
    var a,
      s,
      u = qe(t, 'x', 'batchNorm'),
      c = qe(e, 'mean', 'batchNorm'),
      l = qe(n, 'variance', 'batchNorm')
    return (
      null != o && (a = qe(o, 'scale', 'batchNorm')),
      null != r && (s = qe(r, 'offset', 'batchNorm')),
      A(3 === u.rank, function () {
        return 'Error in batchNorm3D: x must be rank 3 but got rank ' + u.rank + '.'
      }),
      A(3 === c.rank || 1 === c.rank, function () {
        return 'Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ' + c.rank + '.'
      }),
      A(3 === l.rank || 1 === l.rank, function () {
        return 'Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ' + l.rank + '.'
      }),
      null != a &&
        A(3 === a.rank || 1 === a.rank, function () {
          return 'Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ' + a.rank + '.'
        }),
      null != s &&
        A(3 === s.rank || 1 === s.rank, function () {
          return 'Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ' + s.rank + '.'
        }),
      Vs(u, c, l, s, a, i)
    )
  }
  function Us(t, e, n, r, o, i) {
    var a,
      s,
      u = qe(t, 'x', 'batchNorm'),
      c = qe(e, 'mean', 'batchNorm'),
      l = qe(n, 'variance', 'batchNorm')
    return (
      null != o && (a = qe(o, 'scale', 'batchNorm')),
      null != r && (s = qe(r, 'offset', 'batchNorm')),
      A(4 === u.rank, function () {
        return 'Error in batchNorm4D: x must be rank 4 but got rank ' + u.rank + '.'
      }),
      A(4 === c.rank || 1 === c.rank, function () {
        return 'Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ' + c.rank + '.'
      }),
      A(4 === l.rank || 1 === l.rank, function () {
        return 'Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ' + l.rank + '.'
      }),
      null != a &&
        A(4 === a.rank || 1 === a.rank, function () {
          return 'Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ' + a.rank + '.'
        }),
      null != s &&
        A(4 === s.rank || 1 === s.rank, function () {
          return 'Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ' + s.rank + '.'
        }),
      Vs(u, c, l, s, a, i)
    )
  }
  function Vs(t, e, n, r, o, d) {
    null == d && (d = 0.001)
    var i,
      a,
      s = qe(t, 'x', 'batchNorm'),
      u = qe(e, 'mean', 'batchNorm'),
      c = qe(n, 'variance', 'batchNorm')
    null != o && (i = qe(o, 'scale', 'batchNorm')),
      null != r && (a = qe(r, 'offset', 'batchNorm')),
      A(u.rank === c.rank, function () {
        return 'Batch normalization gradient requires mean and variance to have equal ranks.'
      }),
      A(null == a || u.rank === a.rank, function () {
        return 'Batch normalization gradient requires mean and offset to have equal ranks.'
      }),
      A(null == i || u.rank === i.rank, function () {
        return 'Batch normalization gradient requires mean and scale to have equal ranks.'
      })
    var f =
        0 === s.rank || 1 === s.rank
          ? s.as4D(1, 1, 1, s.size)
          : 2 === s.rank
          ? s.as4D(1, 1, s.shape[0], s.shape[1])
          : 3 === s.rank
          ? s.as4D(1, s.shape[0], s.shape[1], s.shape[2])
          : s,
      r = [s, u, c, i]
    return Pt.runKernelFunc(
      function (t, e) {
        t = t.batchNormalization(f, Hs(u), Hs(c), d, Hs(i), Hs(a))
        return e([s, u, c, i]), t
      },
      { x: s, mean: u, variance: c, scale: i, offset: a },
      function (e, t) {
        var n = t[0],
          r = t[1],
          o = t[2],
          t = t[3],
          i = null == t ? hn(1) : t,
          a = Ur(r.shape, f.shape),
          s = []
        if (1 === r.rank) {
          for (var u = 0; u < f.shape.length - 1; ++u) s.push(f.shape[u])
          s.push(1)
        }
        var c = n.sub(r),
          l = e.mul(i),
          h = Is(o.add(hn(d))),
          p = h.mul(h).mul(h).mul(hn(-0.5))
        return {
          x: function () {
            return (1 === r.rank ? e.mul(dr(h.as4D(1, 1, 1, r.shape[0]), s)) : e.mul(h)).mul(i).reshape(n.shape)
          },
          mean: function () {
            var t = h.mul(hn(-1)).mul(l)
            return (t = 1 === r.rank ? t.sum(a) : t).reshape(r.shape)
          },
          variance: function () {
            var t = p.mul(c).mul(l)
            return (t = 1 === r.rank ? t.sum(a) : t).reshape(r.shape)
          },
          scale: function () {
            var t = c.mul(h),
              t = e.mul(t)
            return (t = 1 === r.rank ? t.sum(a) : t).reshape(r.shape)
          },
          offset: function () {
            var t = e
            return (t = 1 === r.rank ? t.sum(a) : t).reshape(r.shape)
          },
        }
      },
      'BatchNormalization',
      { varianceEpsilon: d },
      r,
    ).reshape(s.shape)
  }
  function Hs(t) {
    return null == t
      ? null
      : 0 === t.rank
      ? t.as1D()
      : 1 === t.rank
      ? t
      : 2 === t.rank
      ? t.as4D(1, 1, t.shape[0], t.shape[1])
      : 3 === t.rank
      ? t.as4D(1, t.shape[0], t.shape[1], t.shape[2])
      : t
  }
  function js() {
    ze(
      'tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon',
    )
  }
  function qs(r) {
    return x(this, void 0, void 0, function () {
      var e, n
      return w(this, function (t) {
        switch (t.label) {
          case 0:
            return [4, (e = qe(r, 'condition', 'whereAsync', 'bool')).data()]
          case 1:
            return (n = t.sent()), (n = mo(e.shape, n)), r !== e && e.dispose(), [2, n]
        }
      })
    })
  }
  var Ks = on({
      batchNormalization2d_: function (t, e, n, r, o, i) {
        return void 0 === r && (r = 0.001), js(), zs(t, e, n, i, o, r)
      },
    }),
    Xs = on({
      batchNormalization3d_: function (t, e, n, r, o, i) {
        return void 0 === r && (r = 0.001), js(), Gs(t, e, n, i, o, r)
      },
    }),
    $s = on({
      batchNormalization4d_: function (t, e, n, r, o, i) {
        return void 0 === r && (r = 0.001), js(), Us(t, e, n, i, o, r)
      },
    }),
    Ys = on({
      batchNormalization_: function (t, e, n, r, o, i) {
        return void 0 === r && (r = 0.001), js(), Vs(t, e, n, i, o, r)
      },
    }),
    Js = on({ batchNorm_: Vs }),
    Qs = on({ batchNorm2d_: zs }),
    Zs = on({ batchNorm3d_: Gs }),
    tu = on({ batchNorm4d_: Us }),
    eu = on({
      logicalAnd_: function (t, e) {
        var n = qe(t, 'a', 'logicalAnd', 'bool'),
          r = qe(e, 'b', 'logicalAnd', 'bool')
        return (
          Vr(n.shape, r.shape),
          Pt.runKernelFunc(
            function (t) {
              return t.logicalAnd(n, r)
            },
            { a: n, b: r },
            null,
            'LogicalAnd',
          )
        )
      },
    }),
    nu = on({
      logicalNot_: function (t) {
        var e = qe(t, 'x', 'logicalNot', 'bool')
        return Pt.runKernelFunc(
          function (t) {
            return t.logicalNot(e)
          },
          { $x: e },
        )
      },
    }),
    ru = on({
      logicalOr_: function (t, e) {
        var n = qe(t, 'a', 'logicalOr', 'bool'),
          r = qe(e, 'b', 'logicalOr', 'bool')
        return (
          Vr(n.shape, r.shape),
          Pt.runKernelFunc(
            function (t) {
              return t.logicalOr(n, r)
            },
            { $a: n, $b: r },
          )
        )
      },
    }),
    ou = on({
      logicalXor_: function (t, e) {
        var n = qe(t, 'a', 'logicalXor', 'bool'),
          r = qe(e, 'b', 'logicalXor', 'bool')
        return Vr(n.shape, r.shape), ru(t, e).logicalAnd(eu(t, e).logicalNot())
      },
    }),
    iu = on({
      where_: function (t, e, n) {
        var r = qe(e, 'a', 'where'),
          o = qe(n, 'b', 'where'),
          i = qe(t, 'condition', 'where', 'bool')
        return (
          y(r.shape, o.shape, 'Error in where: '),
          1 === i.rank
            ? A(i.shape[0] === r.shape[0], function () {
                return 'The first dimension of `a` must match the size of `condition`.'
              })
            : y(i.shape, o.shape, 'Error in where: '),
          Pt.runKernelFunc(
            function (t, e) {
              t = t.select(i, r, o)
              return e([i]), t
            },
            { $condition: i, $a: r, $b: o },
            function (t, e) {
              var n = e[0]
              return {
                $condition: function () {
                  return wn(n).toFloat()
                },
                $a: function () {
                  return t.mul(n.cast(t.dtype))
                },
                $b: function () {
                  return t.mul(n.logicalNot().cast(t.dtype))
                },
              }
            },
          )
        )
      },
    }),
    au = on({
      add_: function (t, e) {
        var r = qe(t, 'a', 'add'),
          o = qe(e, 'b', 'add'),
          e = At(r, o),
          r = e[0],
          o = e[1],
          i = Vr(r.shape, o.shape)
        return Pt.runKernelFunc(
          function (t) {
            return t.add(r, o)
          },
          { a: r, b: o },
          function (n) {
            return {
              a: function () {
                var t = n,
                  e = Ur(r.shape, i)
                return (t = 0 < e.length ? t.sum(e) : t).reshape(r.shape)
              },
              b: function () {
                var t = n,
                  e = Ur(o.shape, i)
                return (t = 0 < e.length ? t.sum(e) : t).reshape(o.shape)
              },
            }
          },
          'Add',
        )
      },
    }),
    su = on({
      addN_: function (t) {
        A(Array.isArray(t), function () {
          return 'The argument passed to tf.addN() must be a list of tensors'
        }),
          A(1 <= t.length, function () {
            return 'Must pass at least one tensor to tf.addN(), but got ' + t.length
          })
        var e = t.map(function (t, e) {
            return qe(t, 'tensors' + e, 'addN')
          }),
          n = e[0]
        e.forEach(function (t) {
          if (t.dtype !== n.dtype) throw new Error('All tensors passed to tf.addN() must have the same dtype')
        }),
          e.forEach(function (t) {
            if (!S(t.shape, n.shape)) throw new Error('All tensors passed to tf.addN() must have the same shape')
          })
        return Pt.runKernelFunc(
          function (t) {
            return t.addN(e)
          },
          e,
          function (n) {
            var r = {}
            return (
              e.forEach(function (t, e) {
                r[e] = function () {
                  return n.clone()
                }
              }),
              r
            )
          },
          'AddN',
        )
      },
    }),
    uu = on({
      addStrict_: function (t, e) {
        ;(t = qe(t, 'a', 'addStrict')), (e = qe(e, 'b', 'addStrict'))
        return y(t.shape, e.shape, 'Error in addStrict: '), t.add(e)
      },
    }),
    cu = on({
      atan2_: function (t, e) {
        var n = qe(t, 'a', 'atan2'),
          r = qe(e, 'b', 'atan2'),
          e = At(n, r),
          n = e[0],
          r = e[1],
          i = Vr(n.shape, r.shape)
        return Pt.runKernelFunc(
          function (t, e) {
            t = t.atan2(n, r)
            return e([n, r]), t
          },
          { $a: n, $b: r },
          function (n, t) {
            var r = t[0],
              o = t[1]
            return {
              $a: function () {
                var t = au(r.square(), o.square()),
                  e = n.mul(o.div(t)),
                  t = Ur(r.shape, i)
                return (e = 0 < t.length ? e.sum(t) : e).reshape(r.shape)
              },
              $b: function () {
                var t = au(r.square(), o.square()),
                  e = Ss(n.mul(r.div(t))),
                  t = Ur(o.shape, i)
                return (e = 0 < t.length ? e.sum(t) : e).reshape(o.shape)
              },
            }
          },
        )
      },
    }),
    lu = on({
      div_: function (t, e) {
        var n = qe(t, 'a', 'div'),
          r = qe(e, 'b', 'div'),
          e = At(n, r),
          n = e[0],
          r = e[1]
        if ('int32' === n.dtype && 'int32' === r.dtype) return du(n, r)
        var i = Vr(n.shape, r.shape)
        return Pt.runKernelFunc(
          function (t, e) {
            t = t.realDivide(n, r)
            return e([n, r]), t
          },
          { a: n, b: r },
          function (n, t) {
            var r = t[0],
              o = t[1]
            return {
              a: function () {
                var t = n.div(o.toFloat()),
                  e = Ur(r.shape, i)
                return 0 < e.length ? t.sum(e).reshape(r.shape) : t
              },
              b: function () {
                var t = n.mul(r.toFloat()),
                  e = Ur(o.shape, i)
                0 < e.length && (t = t.sum(e).reshape(o.shape))
                e = o.square()
                return t.div(e.toFloat()).neg()
              },
            }
          },
          'Div',
        )
      },
    }),
    hu = on({
      divNoNan_: function (t, e) {
        var n = (e = At((n = qe(t, 'a', 'div')), (t = qe(e, 'b', 'div'))))[0],
          t = e[1],
          e = lu(n, t),
          n = wn(e),
          t = t.equal(n)
        return iu(t, n, e)
      },
    }),
    pu = on({
      divStrict_: function (t, e) {
        ;(t = qe(t, 'a', 'div')), (e = qe(e, 'b', 'div'))
        return y(t.shape, e.shape, 'Error in divideStrict: '), t.div(e)
      },
    }),
    du = on({
      floorDiv_: function (t, e) {
        var n = qe(t, 'a', 'floorDiv'),
          r = qe(e, 'b', 'floorDiv'),
          e = At(n, r),
          n = e[0],
          r = e[1],
          i = Vr(n.shape, r.shape)
        return Pt.runKernelFunc(
          function (t, e) {
            t = t.floorDiv(n, r)
            return e([n, r]), t
          },
          { a: n, b: r },
          function (n, t) {
            var r = t[0],
              o = t[1]
            return {
              a: function () {
                var t = n.div(o.toFloat()),
                  e = Ur(r.shape, i)
                return 0 < e.length ? t.sum(e).reshape(r.shape) : t
              },
              b: function () {
                var t = n.mul(r.toFloat()),
                  e = Ur(o.shape, i)
                0 < e.length && (t = t.sum(e).reshape(o.shape))
                e = o.square()
                return t.div(e.toFloat()).neg()
              },
            }
          },
          'FloorDiv',
        )
      },
    }),
    fu = on({
      maximum_: function (t, e) {
        var n = qe(t, 'a', 'maximum'),
          r = qe(e, 'b', 'maximum'),
          e = At(n, r),
          n = e[0],
          r = e[1]
        return (
          'bool' === n.dtype && ((n = n.toInt()), (r = r.toInt())),
          Vr(n.shape, r.shape),
          Pt.runKernelFunc(
            function (t, e) {
              t = t.maximum(n, r)
              return e([n, r]), t
            },
            { a: n, b: r },
            function (t, e) {
              var n = e[0],
                r = e[1]
              return {
                a: function () {
                  return t.mul(n.greaterEqual(r).toFloat())
                },
                b: function () {
                  return t.mul(n.less(r).toFloat())
                },
              }
            },
            'Maximum',
          )
        )
      },
    }),
    vu = on({
      maximumStrict_: function (t, e) {
        ;(t = qe(t, 'a', 'maximumStrict')), (e = qe(e, 'b', 'maximumStrict'))
        return y(t.shape, e.shape, 'Error in maximumStrict: '), t.maximum(e)
      },
    }),
    mu = on({
      minimum_: function (t, e) {
        var n = qe(t, 'a', 'minimum'),
          r = qe(e, 'b', 'minimum'),
          e = At(n, r),
          n = e[0],
          r = e[1]
        return (
          'bool' === n.dtype && ((n = n.toInt()), (r = r.toInt())),
          Vr(n.shape, r.shape),
          Pt.runKernelFunc(
            function (t, e) {
              t = t.minimum(n, r)
              return e([n, r]), t
            },
            { a: n, b: r },
            function (t, e) {
              var n = e[0],
                r = e[1]
              return {
                a: function () {
                  return t.mul(n.lessEqual(r).toFloat())
                },
                b: function () {
                  return t.mul(n.greater(r).toFloat())
                },
              }
            },
            'Minimum',
          )
        )
      },
    }),
    gu = on({
      minimumStrict_: function (t, e) {
        ;(t = qe(t, 'a', 'minimumStrict')), (e = qe(e, 'b', 'minimumStrict'))
        return y(t.shape, e.shape, 'Error in minimumStrict: '), t.minimum(e)
      },
    }),
    yu = on({
      mod_: function (t, e) {
        var n = qe(t, 'a', 'mod'),
          r = qe(e, 'b', 'mod'),
          e = At(n, r),
          n = e[0],
          r = e[1],
          i = Vr(n.shape, r.shape)
        return Pt.runKernelFunc(
          function (t, e) {
            t = t.mod(n, r)
            return e([n, r]), t
          },
          { $a: n, $b: r },
          function (n, t) {
            var r = t[0],
              o = t[1]
            return {
              $a: function () {
                var t = Ur(r.shape, i)
                return 0 < t.length ? n.sum(t).reshape(r.shape) : n
              },
              $b: function () {
                var t = n.mul(r.div(o).floor().neg()),
                  e = Ur(o.shape, i)
                return 0 < e.length ? t.sum(e).reshape(o.shape) : t
              },
            }
          },
        )
      },
    }),
    bu = on({
      modStrict_: function (t, e) {
        ;(t = qe(t, 'a', 'modStrict')), (e = qe(e, 'b', 'modStrict'))
        return y(t.shape, e.shape, 'Error in modStrict: '), t.mod(e)
      },
    }),
    xu = on({
      mul_: function (t, e) {
        var n = qe(t, 'a', 'mul'),
          r = qe(e, 'b', 'mul'),
          e = At(n, r),
          n = e[0],
          r = e[1],
          i = Vr(n.shape, r.shape)
        return Pt.runKernelFunc(
          function (t, e) {
            t = t.multiply(n, r)
            return e([n, r]), t
          },
          { a: n, b: r },
          function (n, t) {
            var r = t[0],
              o = t[1]
            return {
              a: function () {
                var t = n.mul(o.toFloat()),
                  e = Ur(r.shape, i)
                return 0 < e.length ? t.sum(e).reshape(r.shape) : t
              },
              b: function () {
                var t = n.mul(r.toFloat()),
                  e = Ur(o.shape, i)
                return 0 < e.length ? t.sum(e).reshape(o.shape) : t
              },
            }
          },
          'Mul',
        )
      },
    }),
    wu = on({
      mulStrict_: function (t, e) {
        ;(t = qe(t, 'a', 'mul')), (e = qe(e, 'b', 'mul'))
        return y(t.shape, e.shape, 'Error in multiplyStrict: '), t.mul(e)
      },
    }),
    Cu = on({
      pow_: function (t, e) {
        var n = qe(t, 'base', 'pow'),
          r = qe(e, 'exp', 'pow'),
          e = At(n, r),
          n = e[0],
          r = e[1],
          a = Vr(n.shape, r.shape),
          e = [n, r]
        return Pt.runKernelFunc(
          function (t, e) {
            t = t.pow(n, r)
            return e([n, r, t]), t
          },
          { a: n, b: r },
          function (n, t) {
            var r = t[0],
              o = t[1],
              i = t[2]
            return {
              a: function () {
                var t = o.toFloat(),
                  e = n.mul(t.mul(r.pow(t.sub(hn(1))))),
                  t = Ur(r.shape, a)
                return (e = 0 < t.length ? e.sum(t) : e).reshape(r.shape)
              },
              b: function () {
                var t = r.greater(0),
                  e = r.log().where(t, wn(r)),
                  t = n.mul(i.mul(e)),
                  e = Ur(o.shape, a)
                return (t = 0 < e.length ? t.sum(e) : t).reshape(o.shape)
              },
            }
          },
          'Pow',
          {},
          e,
          [!0],
        )
      },
    }),
    Eu = on({
      powStrict_: function (t, e) {
        return y(t.shape, e.shape, 'Error in powStrict: '), t.pow(e)
      },
    }),
    Su = on({
      squaredDifferenceStrict_: function (t, e) {
        ;(t = qe(t, 'a', 'squaredDifferenceStrict')), (e = qe(e, 'b', 'squaredDifferenceStrict'))
        return y(t.shape, e.shape, 'Error in squaredDifferenceStrict: '), t.squaredDifference(e)
      },
    }),
    _u = on({
      sub_: function (t, e) {
        var r = qe(t, 'a', 'sub'),
          o = qe(e, 'b', 'sub'),
          e = At(r, o),
          r = e[0],
          o = e[1],
          i = Vr(r.shape, o.shape)
        return Pt.runKernelFunc(
          function (t) {
            return t.subtract(r, o)
          },
          { a: r, b: o },
          function (n) {
            return {
              a: function () {
                var t = n,
                  e = Ur(r.shape, i)
                return (t = 0 < e.length ? t.sum(e) : t).reshape(r.shape)
              },
              b: function () {
                var t = n,
                  e = Ur(o.shape, i)
                return (t = 0 < e.length ? t.sum(e) : t).neg().reshape(o.shape)
              },
            }
          },
          'Sub',
        )
      },
    }),
    Ru = on({
      subStrict_: function (t, e) {
        ;(t = qe(t, 'a', 'subStrict')), (e = qe(e, 'b', 'subStrict'))
        return y(t.shape, e.shape, 'Error in subStrict: '), t.sub(e)
      },
    }),
    Iu = on({
      equal_: function (t, e) {
        var n = qe(t, 'a', 'equal'),
          r = qe(e, 'b', 'equal'),
          e = At(n, r),
          n = e[0],
          r = e[1]
        return (
          Vr(n.shape, r.shape),
          Pt.runKernelFunc(
            function (t) {
              return t.equal(n, r)
            },
            { $a: n, $b: r },
          )
        )
      },
    }),
    Au = on({
      equalStrict_: function (t, e) {
        ;(t = qe(t, 'a', 'equalStrict')), (e = qe(e, 'b', 'equalStrict'))
        return y(t.shape, e.shape, 'Error in equalStrict: '), t.equal(e)
      },
    }),
    Nu = on({
      greater_: function (t, e) {
        var n = qe(t, 'a', 'greater'),
          r = qe(e, 'b', 'greater'),
          e = At(n, r),
          n = e[0],
          r = e[1]
        return (
          Vr(n.shape, r.shape),
          Pt.runKernelFunc(
            function (t) {
              return t.greater(n, r)
            },
            { a: n, b: r },
            null,
            'Greater',
          )
        )
      },
    }),
    ku = on({
      greaterEqual_: function (t, e) {
        var n = qe(t, 'a', 'greaterEqual'),
          r = qe(e, 'b', 'greaterEqual'),
          e = At(n, r),
          n = e[0],
          r = e[1]
        return (
          Vr(n.shape, r.shape),
          Pt.runKernelFunc(
            function (t, e) {
              t = t.greaterEqual(n, r)
              return e([n, r]), t
            },
            { a: n, b: r },
            function (t, e) {
              var n = e[0],
                r = e[1]
              return {
                a: function () {
                  return wn(n)
                },
                b: function () {
                  return wn(r)
                },
              }
            },
            'GreaterEqual',
          )
        )
      },
    }),
    Tu = on({
      greaterEqualStrict_: function (t, e) {
        ;(t = qe(t, 'a', 'greaterEqualStrict')), (e = qe(e, 'b', 'greaterEqualStrict'))
        return y(t.shape, e.shape, 'Error in greaterEqualStrict: '), t.greaterEqual(e)
      },
    }),
    Du = on({
      greaterStrict_: function (t, e) {
        ;(t = qe(t, 'a', 'greaterStrict')), (e = qe(e, 'b', 'greaterStrict'))
        return y(t.shape, e.shape, 'Error in greaterStrict: '), t.greater(e)
      },
    }),
    Ou = on({
      less_: function (t, e) {
        var n = qe(t, 'a', 'less'),
          r = qe(e, 'b', 'less'),
          e = At(n, r),
          n = e[0],
          r = e[1]
        return (
          Vr(n.shape, r.shape),
          Pt.runKernelFunc(
            function (t) {
              return t.less(n, r)
            },
            { a: n, b: r },
            null,
            'Less',
          )
        )
      },
    }),
    Fu = on({
      lessEqual_: function (t, e) {
        var n = qe(t, 'a', 'lessEqual'),
          r = qe(e, 'b', 'lessEqual'),
          e = At(n, r),
          n = e[0],
          r = e[1]
        return (
          Vr(n.shape, r.shape),
          Pt.runKernelFunc(
            function (t, e) {
              t = t.lessEqual(n, r)
              return e([n, r]), t
            },
            { a: n, b: r },
            null,
            'LessEqual',
          )
        )
      },
    }),
    Mu = on({
      lessEqualStrict_: function (t, e) {
        ;(t = qe(t, 'a', 'lessEqualStrict')), (e = qe(e, 'b', 'lessEqualStrict'))
        return y(t.shape, e.shape, 'Error in lessEqualStrict: '), t.lessEqual(e)
      },
    }),
    Pu = on({
      lessStrict_: function (t, e) {
        ;(t = qe(t, 'a', 'lessStrict')), (e = qe(e, 'b', 'lessStrict'))
        return y(t.shape, e.shape, 'Error in lessStrict: '), t.less(e)
      },
    }),
    Bu = on({
      notEqual_: function (t, e) {
        var n = qe(t, 'a', 'notEqual'),
          r = qe(e, 'b', 'notEqual'),
          e = At(n, r),
          n = e[0],
          r = e[1]
        return (
          Vr(n.shape, r.shape),
          Pt.runKernelFunc(
            function (t) {
              return t.notEqual(n, r)
            },
            { a: n, b: r },
            null,
            'NotEqual',
          )
        )
      },
    }),
    Lu = on({
      notEqualStrict_: function (t, e) {
        ;(t = qe(t, 'a', 'notEqualStrict')), (e = qe(e, 'b', 'notEqualStrict'))
        return y(t.shape, e.shape, 'Error in notEqualStrict: '), t.notEqual(e)
      },
    })
  function Wu(t, e) {
    for (var n = [], r = t; r < e; ++r) n.push(r)
    return n
  }
  function zu(t) {
    for (var e = [], n = 0; n < t.length; ++n) for (var r = 0; r < t[n].length; ++r) e.push(t[n][r])
    return e
  }
  var Gu = on({
      gather_: function (t, e, u) {
        void 0 === u && (u = 0)
        var c = qe(t, 'x', 'gather'),
          n = qe(e, 'indices', 'gather', 'int32')
        u = O(u, c.shape)[0]
        e = (function (t, e, n) {
          for (var r = t.shape[n], o = [], i = 1, a = 1, s = 0; s < n; s++) o.push(t.shape[s]), (i *= t.shape[s])
          for (s = 0; s < e.rank; s++) o.push(e.shape[s])
          for (s = n + 1; s < t.rank; s++) o.push(t.shape[s]), (a *= t.shape[s])
          return { batchSize: i, sliceSize: a, dimSize: r, outputShape: o }
        })(c, n, u)
        return Pt.runKernelFunc(
          function (t, e) {
            t = t.gather(c, n.flatten(), u)
            return e([n]), t
          },
          { x: c, indices: n },
          function (a, t) {
            var s = t[0]
            return {
              x: function () {
                var t = c.shape,
                  e = s.size,
                  n = t.slice(0, u),
                  r = n.length,
                  o = t.slice(u, t.length).slice(1),
                  i = o.length,
                  t = Wu(0, r),
                  i = Wu(r + 1, r + 1 + i),
                  o = zu([n, [e], o]),
                  o = a.reshape(o),
                  e = s.reshape([e]),
                  i = zu([[r], t, i]),
                  o = o.transpose(i),
                  e = Uu(o, e, c.shape[u]),
                  i = tn(i)
                return e.transpose(i)
              },
              indices: function () {
                return s
              },
            }
          },
          'Gather',
          { axis: u },
        ).reshape(e.outputShape)
      },
    }),
    Uu = on({
      unsortedSegmentSum_: function (t, e, n) {
        var r = qe(t, 'x', 'unsortedSegmentSum'),
          o = qe(e, 'segmentIds', 'unsortedSegmentSum', 'int32')
        return (
          A(N(n), function () {
            return 'numSegments must be of dtype int'
          }),
          Pt.runKernelFunc(
            function (t, e) {
              t = t.unsortedSegmentSum(r, o, n)
              return e([o]), t
            },
            { $x: r },
            function (t, e) {
              var n = e[0]
              return {
                $x: function () {
                  return (function (t, e) {
                    for (var n = fu(e, wn(e)), n = Gu(t, n), r = ku(e, hn(0, 'int32')), o = n.rank - r.rank, i = 0; i < o; ++i)
                      r = Yn(r, i + 1)
                    ;(r = eu(r, mn(n.shape, 'bool'))), (e = wn(n))
                    return iu(r, n, e)
                  })(t, n)
                },
              }
            },
          )
        )
      },
    })
  function Vu(t, e, n, o, i, a, s) {
    void 0 === a && (a = 'NHWC'),
      A(t.length === e.rank, function () {
        return 'Length of inShape (' + t.length + ') and rank of dy (' + e.rank + ') must match'
      })
    var r = t,
      u = e,
      c = !1
    3 === e.rank && ((c = !0), (u = e.as4D(1, e.shape[0], e.shape[1], e.shape[2])), (r = [1, t[0], t[1], t[2]])),
      A(4 === r.length, function () {
        return 'Error in conv2dDerInput: inShape must be length 4, but got length ' + r.length + '.'
      }),
      A(4 === u.rank, function () {
        return 'Error in conv2dDerInput: dy must be rank 4, but got rank ' + u.rank
      }),
      A(4 === n.rank, function () {
        return 'Error in conv2dDerInput: filter must be rank 4, but got rank ' + n.rank
      })
    var l = 'NHWC' === a ? r[3] : r[1],
      h = 'NHWC' === a ? u.shape[3] : u.shape[1]
    A(l === n.shape[2], function () {
      return 'Error in conv2dDerInput: depth of input (' + l + ') must match input depth for filter ' + n.shape[2] + '.'
    }),
      A(h === n.shape[3], function () {
        return 'Error in conv2dDerInput: depth of output (' + h + ') must match output depth for filter ' + n.shape[3] + '.'
      }),
      null != s &&
        A(N(i), function () {
          return 'Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ' + s + ' but got pad ' + i + '.'
        })
    var p = eo(a),
      d = qr(r, n.shape, o, 1, i, s, !1, p),
      p = Pt.runKernelFunc(
        function (t, e) {
          t = t.conv2dDerInput(u, n, d)
          return e([n, u]), t
        },
        { dy4D: u, filter: n },
        function (t, e) {
          var n = e[0],
            r = e[1]
          return {
            dy4D: function () {
              return Ku(t, n, o, i, a, 1, s)
            },
            filter: function () {
              return $u(t, r, n.shape, o, i, a, s)
            },
          }
        },
      )
    return c ? p.as3D(p.shape[1], p.shape[2], p.shape[3]) : p
  }
  function Hu(t) {
    var e = 'number' == typeof t ? [t, t, t] : 2 === t.length ? [t[0], t[1], 1] : t,
      n = e[0],
      t = e[1],
      e = e[2]
    return 1 === n && 1 === t && 1 === e
  }
  function ju(t, e, n, r, o) {
    A(t.length === e.rank, function () {
      return 'Length of inShape (' + t.length + ') and rank of dy (' + e.rank + ') must match'
    })
    var i = t,
      a = e,
      s = !1
    4 === e.rank &&
      ((s = !0), (a = e.as5D(1, e.shape[0], e.shape[1], e.shape[2], e.shape[3])), (i = [1, t[0], t[1], t[2], t[3]]))
    var u = i[4],
      c = a.shape[4]
    A(5 === i.length, function () {
      return 'Error in conv3dDerInput: inShape must be length 5, but got length ' + i.length + '.'
    }),
      A(5 === a.rank, function () {
        return 'Error in conv3dDerInput: dy must be rank 5, but got rank ' + a.rank
      }),
      A(5 === n.rank, function () {
        return 'Error in conv3dDerInput: filter must be rank 5, but got rank ' + n.rank
      }),
      A(u === n.shape[3], function () {
        return 'Error in conv3dDerInput: depth of input (' + u + ') must match input depth for filter ' + n.shape[3] + '.'
      }),
      A(c === n.shape[4], function () {
        return 'Error in conv3dDerInput: depth of output (' + c + ') must match output depth for filter ' + n.shape[4] + '.'
      })
    var l = Kr(i, n.shape, r, 1, o),
      o = Pt.runKernelFunc(
        function (t) {
          return t.conv3dDerInput(a, n, l)
        },
        { dy5D: a },
      )
    return s ? o.as4D(o.shape[1], o.shape[2], o.shape[3], o.shape[4]) : o
  }
  var qu = on({
      conv1d_: function (t, e, n, r, o, i, a) {
        void 0 === o && (o = 'NWC'), void 0 === i && (i = 1)
        var s = qe(t, 'x', 'conv1d'),
          u = qe(e, 'filter', 'conv1d'),
          c = s,
          t = !1
        2 === s.rank && ((t = !0), (c = s.as3D(1, s.shape[0], s.shape[1]))),
          A(3 === c.rank, function () {
            return 'Error in conv1d: input must be rank 3, but got rank ' + c.rank + '.'
          }),
          A(3 === u.rank, function () {
            return 'Error in conv1d: filter must be rank 3, but got rank ' + u.rank + '.'
          }),
          null != a &&
            A(N(r), function () {
              return 'Error in conv1d: pad must be an integer when using, dimRoundingMode ' + a + ' but got pad ' + r + '.'
            }),
          A(c.shape[2] === u.shape[1], function () {
            return 'Error in conv1d: depth of input (' + c.shape[2] + ') must match input depth for filter ' + u.shape[1] + '.'
          }),
          A(to(n, i), function () {
            return 'Error in conv1D: Either stride or dilation must be 1. Got stride ' + n + " and dilation '" + i + "'"
          }),
          A('NWC' === o, function () {
            return 'Error in conv1d: got dataFormat of ' + o + ' but only NWC is currently supported.'
          })
        ;(e = u.as4D(1, u.shape[0], u.shape[1], u.shape[2])),
          (s = c.as4D(c.shape[0], 1, c.shape[1], c.shape[2])),
          (e = Ku(s, e, [1, n], r, 'NHWC', [1, i], a))
        return t ? e.as2D(e.shape[2], e.shape[3]) : e.as3D(e.shape[0], e.shape[2], e.shape[3])
      },
    }),
    Ku = on({
      conv2d_: function (t, e, o, i, a, s, n) {
        void 0 === a && (a = 'NHWC'), void 0 === s && (s = [1, 1])
        var t = qe(t, 'x', 'conv2d'),
          r = qe(e, 'filter', 'conv2d'),
          u = t,
          e = !1
        3 === t.rank && ((e = !0), (u = t.as4D(1, t.shape[0], t.shape[1], t.shape[2]))),
          A(4 === u.rank, function () {
            return 'Error in conv2d: input must be rank 4, but got rank ' + u.rank + '.'
          }),
          A(4 === r.rank, function () {
            return 'Error in conv2d: filter must be rank 4, but got rank ' + r.rank + '.'
          }),
          null != n &&
            A(N(i), function () {
              return 'Error in conv2d: pad must be an integer when using, dimRoundingMode ' + n + ' but got pad ' + i + '.'
            })
        var c = 'NHWC' === a ? u.shape[3] : u.shape[1]
        A(c === r.shape[2], function () {
          return 'Error in conv2d: depth of input (' + c + ') must match input depth for filter ' + r.shape[2] + '.'
        }),
          A(to(o, s), function () {
            return 'Error in conv2D: Either strides or dilations must be 1. Got strides ' + o + " and dilations '" + s + "'"
          })
        var t = eo(a),
          l = qr(u.shape, r.shape, o, s, i, n, !1, t),
          t = [r, u],
          t = Pt.runKernelFunc(
            function (t, e) {
              t = t.conv2d(u, r, l)
              return e([r, u]), t
            },
            { x: u, filter: r },
            function (t, e) {
              var n = e[0],
                r = e[1]
              return (
                A(Zr(s), function () {
                  return (
                    "Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" +
                    s +
                    "'"
                  )
                }),
                {
                  x: function () {
                    return Yu(r.shape, t, n, o, i, a)
                  },
                  filter: function () {
                    return $u(r, t, n.shape, o, i, a)
                  },
                }
              )
            },
            'Conv2D',
            l,
            t,
          )
        return e ? t.as3D(t.shape[1], t.shape[2], t.shape[3]) : t
      },
    }),
    Xu = on({
      conv3d_: function (t, e, r, o, n, i) {
        void 0 === n && (n = 'NDHWC'), void 0 === i && (i = [1, 1, 1])
        var t = qe(t, 'x', 'conv3d'),
          a = qe(e, 'filter', 'conv3d'),
          s = t,
          e = !1
        4 === t.rank && ((e = !0), (s = t.as5D(1, t.shape[0], t.shape[1], t.shape[2], t.shape[3]))),
          A(5 === s.rank, function () {
            return 'Error in conv3d: input must be rank 5, but got rank ' + s.rank + '.'
          }),
          A(5 === a.rank, function () {
            return 'Error in conv3d: filter must be rank 5, but got rank ' + a.rank + '.'
          }),
          A(s.shape[4] === a.shape[3], function () {
            return 'Error in conv3d: depth of input (' + s.shape[4] + ') must match input depth for filter ' + a.shape[3] + '.'
          }),
          A(Hu(r) || Hu(i), function () {
            return 'Error in conv3D: Either strides or dilations must be 1. Got strides ' + r + " and dilations '" + i + "'"
          }),
          A('NDHWC' === n, function () {
            return 'Error in conv3d: got dataFormat of ' + n + ' but only NDHWC is currently supported.'
          })
        var u = Kr(s.shape, a.shape, r, i, o),
          t = Pt.runKernelFunc(
            function (t, e) {
              t = t.conv3d(s, a, u)
              return e([s, a]), t
            },
            { x: s, $filter: a },
            function (t, e) {
              A(Hu(i), function () {
                return (
                  "Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" +
                  i +
                  "'"
                )
              })
              var s = e[0],
                n = e[1]
              return {
                x: function () {
                  return ju(s.shape, t, n, r, o)
                },
                $filter: function () {
                  return (function (t, e, n, r) {
                    var o = s
                    4 === s.rank && (o = s.as5D(1, s.shape[0], s.shape[1], s.shape[2], s.shape[3]))
                    var i = t
                    4 === i.rank && (i = t.as5D(1, t.shape[0], t.shape[1], t.shape[2], t.shape[3])),
                      A(5 === o.rank, function () {
                        return 'Error in conv3dDerFilter: input must be rank 5, but got shape ' + o.shape + '.'
                      }),
                      A(5 === i.rank, function () {
                        return 'Error in conv3dDerFilter: dy must be rank 5, but got shape ' + i.shape + '.'
                      }),
                      A(5 === e.length, function () {
                        return 'Error in conv3dDerFilter: filterShape must be length 5, but got ' + e + '.'
                      }),
                      A(o.shape[4] === e[3], function () {
                        return (
                          'Error in conv3dDerFilter: depth of input ' +
                          o.shape[4] +
                          ') must match input depth in filter (' +
                          e[3] +
                          '.'
                        )
                      }),
                      A(i.shape[4] === e[4], function () {
                        return (
                          'Error in conv3dDerFilter: depth of dy (' +
                          i.shape[4] +
                          ') must match output depth for filter (' +
                          e[4] +
                          ').'
                        )
                      })
                    var a = Kr(o.shape, e, n, 1, r)
                    return Pt.runKernelFunc(
                      function (t) {
                        return t.conv3dDerFilter(o, i, a)
                      },
                      { x5D: o, dy5D: i },
                    )
                  })(t, n.shape, r, o)
                },
              }
            },
          )
        return e ? t.as4D(t.shape[1], t.shape[2], t.shape[3], t.shape[4]) : t
      },
    }),
    $u = on({
      conv2dDerFilter_: function (t, e, n, r, o, i, a) {
        void 0 === i && (i = 'NHWC')
        var s = t
        3 === t.rank && (s = t.as4D(1, t.shape[0], t.shape[1], t.shape[2]))
        var u = e
        3 === u.rank && (u = e.as4D(1, e.shape[0], e.shape[1], e.shape[2])),
          A(4 === s.rank, function () {
            return 'Error in conv2dDerFilter: input must be rank 4, but got shape ' + s.shape + '.'
          }),
          A(4 === u.rank, function () {
            return 'Error in conv2dDerFilter: dy must be rank 4, but got shape ' + u.shape + '.'
          }),
          A(4 === n.length, function () {
            return 'Error in conv2dDerFilter: filterShape must be length 4, but got ' + n + '.'
          })
        var c = 'NHWC' === i ? s.shape[3] : s.shape[1],
          l = 'NHWC' === i ? u.shape[3] : u.shape[1]
        A(c === n[2], function () {
          return 'Error in conv2dDerFilter: depth of input ' + c + ') must match input depth in filter (' + n[2] + '.'
        }),
          A(l === n[3], function () {
            return 'Error in conv2dDerFilter: depth of dy (' + l + ') must match output depth for filter (' + n[3] + ').'
          }),
          null != a &&
            A(N(o), function () {
              return (
                'Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ' + a + ' but got pad ' + o + '.'
              )
            })
        var i = eo(i),
          h = qr(s.shape, n, r, 1, o, a, !1, i)
        return Pt.runKernelFunc(
          function (t) {
            return t.conv2dDerFilter(s, u, h)
          },
          { x4D: s, dy4D: u },
        )
      },
    }),
    Yu = on({ conv2dDerInput_: Vu }),
    Ju = on({
      depthwiseConv2d_: function (t, e, n, r, o, i, a) {
        void 0 === i && (i = [1, 1])
        var t = qe(t, 'x', 'depthwiseConv2d'),
          s = qe(e, 'filter', 'depthwiseConv2d'),
          u = t,
          e = !1
        3 === t.rank && ((e = !0), (u = t.as4D(1, t.shape[0], t.shape[1], t.shape[2]))),
          A(4 === u.rank, function () {
            return 'Error in depthwiseConv2d: input must be rank 4, but got rank ' + u.rank + '.'
          }),
          A(4 === s.rank, function () {
            return 'Error in depthwiseConv2d: filter must be rank 4, but got rank ' + s.rank + '.'
          }),
          A(u.shape[3] === s.shape[2], function () {
            return (
              'Error in depthwiseConv2d: number of input channels (' +
              u.shape[3] +
              ') must match the inChannels dimension in filter ' +
              s.shape[2] +
              '.'
            )
          }),
          A(to(n, (i = null == i ? [1, 1] : i)), function () {
            return (
              'Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ' + n + " and dilations '" + i + "'"
            )
          }),
          null != a &&
            A(N(r), function () {
              return (
                'Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ' + a + ' but got pad ' + r + '.'
              )
            })
        var c = qr(u.shape, s.shape, n, i, r, a, !0),
          t = [u, s],
          t = Pt.runKernelFunc(
            function (t, e) {
              t = t.depthwiseConv2D(u, s, c)
              return e([u, s]), t
            },
            { x: u, filter: s },
            function (t, e) {
              A(Zr(i), function () {
                return (
                  "Error in gradient of depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '" +
                  i +
                  "'"
                )
              })
              var n = e[0],
                r = e[1]
              return {
                x: function () {
                  return Qu(n.shape, t, r, c)
                },
                filter: function () {
                  return Zu(n, t, r.shape, c)
                },
              }
            },
            'DepthwiseConv2dNative',
            c,
            t,
          )
        return e ? t.as3D(t.shape[1], t.shape[2], t.shape[3]) : t
      },
    }),
    Qu = on({
      depthwiseConv2dDerInput_: function (t, e, n, r) {
        var o = e,
          i = !1
        3 === e.rank && ((i = !0), (o = e.as4D(1, e.shape[0], e.shape[1], e.shape[2])))
        e = Pt.runKernelFunc(
          function (t) {
            return t.depthwiseConv2DDerInput(o, n, r)
          },
          { dy4D: o },
        )
        return i ? e.as3D(e.shape[1], e.shape[2], e.shape[3]) : e
      },
    }),
    Zu = on({
      depthwiseConv2dDerFilter_: function (t, e, n, r) {
        var o = t
        3 === t.rank && (o = t.as4D(1, t.shape[0], t.shape[1], t.shape[2]))
        var i = e
        return (
          3 === i.rank && (i = e.as4D(1, e.shape[0], e.shape[1], e.shape[2])),
          Pt.runKernelFunc(
            function (t) {
              return t.depthwiseConv2DDerFilter(o, i, r)
            },
            { x4D: o, dy4D: i },
          )
        )
      },
    }),
    tc = on({
      separableConv2d_: function (t, e, n, r, o, i, a) {
        void 0 === i && (i = [1, 1]), void 0 === a && (a = 'NHWC')
        var t = qe(t, 'x', 'separableConv2d'),
          s = qe(e, 'depthwiseFilter', 'separableConv2d'),
          u = qe(n, 'pointwiseFilter', 'separableConv2d'),
          c = t,
          n = !1
        if ((3 === t.rank && ((n = !0), (c = t.as4D(1, t.shape[0], t.shape[1], t.shape[2]))), 'NCHW' === a))
          throw new Error('separableConv2d currently does not support dataFormat NCHW; only NHWC is supported')
        A(4 === c.rank, function () {
          return 'Error in separableConv2d: input must be rank 4, but got rank ' + c.rank + '.'
        }),
          A(4 === s.rank, function () {
            return 'Error in separableConv2d: depthwise filter must be rank 4, but got rank ' + s.rank + '.'
          }),
          A(4 === u.rank, function () {
            return 'Error in separableConv2d: pointwise filter must be rank 4, but got rank ' + s.rank + '.'
          }),
          A(1 === u.shape[0], function () {
            return 'Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ' + u.shape[0] + '.'
          }),
          A(1 === u.shape[1], function () {
            return 'Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ' + u.shape[1] + '.'
          })
        var l = s.shape[2],
          h = s.shape[3]
        A(u.shape[2] === l * h, function () {
          return (
            'Error in separableConv2d: the third dimension of pointwise filter must be ' +
            l * h +
            ', but got ' +
            u.shape[2] +
            '.'
          )
        })
        ;(i = Ju(c, s, r, o, a, i)), (a = Ku(i, u, 1, 'valid', a))
        return n ? a.as3D(a.shape[1], a.shape[2], a.shape[3]) : a
      },
    }),
    ec = on({
      conv2dTranspose_: function (t, e, n, r, o, i) {
        return Vu(n, qe(t, 'x', 'conv2dTranspose'), qe(e, 'filter', 'conv2dTranspose'), r, o, 'NHWC', i)
      },
    }),
    nc = on({
      conv3dTranspose_: function (t, e, n, r, o) {
        return ju(n, qe(t, 'x', 'conv3dTranspose'), qe(e, 'filter', 'conv3dTranspose'), r, o)
      },
    }),
    rc = on({
      matMul_: function (t, e, o, i) {
        void 0 === o && (o = !1), void 0 === i && (i = !1)
        var n = qe(t, 'a', 'matMul'),
          r = qe(e, 'b', 'matMul'),
          n = (p = At(n, r))[0],
          r = p[1],
          a = o ? n.shape[n.rank - 2] : n.shape[n.rank - 1],
          s = i ? r.shape[r.rank - 1] : r.shape[r.rank - 2],
          u = o ? n.shape[n.rank - 1] : n.shape[n.rank - 2],
          c = i ? r.shape[r.rank - 2] : r.shape[r.rank - 1],
          l = n.shape.slice(0, -2),
          h = r.shape.slice(0, -2),
          t = D(l),
          e = D(h)
        A(2 <= n.rank && 2 <= r.rank && n.rank === r.rank, function () {
          return 'Error in matMul: inputs must have the same rank of at least 2, got ranks ' + n.rank + ' and ' + r.rank + '.'
        }),
          A(S(l, h), function () {
            return (
              'Error in matMul: outer dimensions (' +
              l +
              ') and (' +
              h +
              ') of Tensors with shapes ' +
              n.shape +
              ' and ' +
              r.shape +
              ' must match.'
            )
          }),
          A(a === s, function () {
            return (
              'Error in matMul: inner shapes (' +
              a +
              ') and (' +
              s +
              ') of Tensors with shapes ' +
              n.shape +
              ' and ' +
              r.shape +
              ' and transposeA=' +
              o +
              ' and transposeB=' +
              i +
              ' must match.'
            )
          })
        var p = n.shape.slice(0, -2).concat([u, c]),
          d = o ? n.as3D(t, a, u) : n.as3D(t, u, a),
          f = i ? r.as3D(e, c, s) : r.as3D(e, s, c),
          c = { transposeA: o, transposeB: i }
        return Pt.runKernelFunc(
          function (t, e) {
            t = t.batchMatMul(d, f, o, i)
            return e([d, f]), t
          },
          { a: d, b: f },
          function (t, e) {
            var n = e[0],
              r = e[1]
            return o || i
              ? !o && i
                ? {
                    a: function () {
                      return t.matMul(r, !1, !1)
                    },
                    b: function () {
                      return t.matMul(n, !0, !1)
                    },
                  }
                : o && !i
                ? {
                    a: function () {
                      return r.matMul(t, !1, !0)
                    },
                    b: function () {
                      return n.matMul(t, !1, !1)
                    },
                  }
                : {
                    a: function () {
                      return r.matMul(t, !0, !0)
                    },
                    b: function () {
                      return t.matMul(n, !0, !0)
                    },
                  }
              : {
                  a: function () {
                    return t.matMul(r, !1, !0)
                  },
                  b: function () {
                    return n.matMul(t, !0, !1)
                  },
                }
          },
          'BatchMatMul',
          c,
        ).reshape(p)
      },
    }),
    oc = on({
      dot_: function (t, e) {
        var n = qe(t, 't1', 'dot'),
          r = qe(e, 't2', 'dot')
        A(!((1 !== n.rank && 2 !== n.rank) || (1 !== r.rank && 2 !== r.rank)), function () {
          return 'Error in dot: inputs must all be rank 1 or 2, but got ranks ' + n.rank + ' and ' + r.rank + '.'
        })
        var o = 1 === n.rank ? n.size : n.shape[1],
          i = 1 === r.rank ? r.size : r.shape[0]
        return (
          A(o === i, function () {
            return 'Error in dot: inner dimensions of inputs must match, but got ' + o + ' and ' + i + '.'
          }),
          1 === n.rank && 1 === r.rank
            ? n.as2D(1, -1).matMul(r.as2D(-1, 1)).asScalar()
            : 1 === n.rank && 2 === r.rank
            ? n.as2D(1, -1).matMul(r.as2D(r.shape[0], r.shape[1])).as1D()
            : 2 === n.rank && 1 === r.rank
            ? n.matMul(r.as2D(-1, 1)).as1D()
            : n.matMul(r.as2D(r.shape[0], r.shape[1]))
        )
      },
    }),
    ic = on({
      outerProduct_: function (t, e) {
        var n = qe(t, 'v1', 'outerProduct'),
          r = qe(e, 'v2', 'outerProduct')
        return (
          A(1 === n.rank && 1 === r.rank, function () {
            return 'Error in outerProduct: inputs must be rank 1, but got ranks ' + n.rank + ' and ' + r.rank + '.'
          }),
          n.as2D(-1, 1).matMul(r.as2D(1, -1))
        )
      },
    }),
    ac = on({
      reverse_: function (t, e) {
        var n = qe(t, 'x', 'reverse')
        if (0 === n.rank) return n.clone()
        var r = O(e, n.shape)
        return Pt.runKernelFunc(
          function (t) {
            return t.reverse(n, r)
          },
          { $x: n },
          function (t) {
            return {
              $x: function () {
                return t.reverse(r)
              },
            }
          },
        ).reshapeAs(n)
      },
    }),
    sc = on({
      reverse1d_: function (t) {
        var e = qe(t, 'x', 'reverse')
        return (
          A(1 === e.rank, function () {
            return 'Error in reverse1D: x must be rank 1 but got rank ' + e.rank + '.'
          }),
          ac(e, 0)
        )
      },
    }),
    uc = on({
      reverse2d_: function (t, e) {
        var n = qe(t, 'x', 'reverse')
        return (
          A(2 === n.rank, function () {
            return 'Error in reverse2D: x must be rank 2 but got rank ' + n.rank + '.'
          }),
          ac(n, e)
        )
      },
    }),
    cc = on({
      reverse3d_: function (t, e) {
        var n = qe(t, 'x', 'reverse')
        return (
          A(3 === n.rank, function () {
            return 'Error in reverse3D: x must be rank 3 but got rank ' + n.rank + '.'
          }),
          ac(n, e)
        )
      },
    }),
    lc = on({
      reverse4d_: function (t, e) {
        var n = qe(t, 'x', 'reverse')
        return (
          A(4 === n.rank, function () {
            return 'Error in reverse4D: x must be rank 4 but got rank ' + n.rank + '.'
          }),
          ac(n, e)
        )
      },
    })
  function hc(t, r, o, i, a, e) {
    var n = qe(t, 'x', 'maxPool'),
      s = n,
      t = !1
    3 === n.rank && ((t = !0), (s = n.as4D(1, n.shape[0], n.shape[1], n.shape[2]))),
      null == i && (i = [1, 1]),
      A(4 === s.rank, function () {
        return 'Error in maxPool: input must be rank 4 but got rank ' + s.rank + '.'
      }),
      A(to(o, i), function () {
        return 'Error in maxPool: Either strides or dilations must be 1. Got strides ' + o + " and dilations '" + i + "'"
      }),
      null != e &&
        A(N(a), function () {
          return 'Error in maxPool: pad must be an integer when using, dimRoundingMode ' + e + ' but got pad ' + a + '.'
        })
    var u = Hr(s.shape, r, o, i, a, e)
    if (1 === u.filterWidth && 1 === u.filterHeight && S(u.inShape, u.outShape)) return n.clone()
    ;(n = [s]),
      (n = Pt.runKernelFunc(
        function (t, e) {
          t = t.maxPool(s, u)
          return e([s, t]), t
        },
        { x: s },
        function (l, t) {
          var e = t[0],
            n = t[1]
          return {
            x: function () {
              return (function (t, e, n, r, o, i) {
                var a = qe(l, 'dy', 'maxPoolBackprop'),
                  s = qe(t, 'input', 'maxPoolBackprop'),
                  u = qe(e, 'output', 'maxPoolBackprop')
                A(s.rank === a.rank, function () {
                  return 'Rank of input (' + s.rank + ') does not match rank of dy (' + a.rank + ')'
                }),
                  A(to(r, (o = null == o ? [1, 1] : o)), function () {
                    return (
                      'Error in maxPoolBackProp: Either strides or dilations must be 1. Got strides ' +
                      r +
                      " and dilations '" +
                      o +
                      "'"
                    )
                  }),
                  A(4 === a.rank, function () {
                    return 'Error in maxPoolBackprop: dy must be rank 4 but got rank ' + a.rank + '.'
                  }),
                  A(4 === s.rank, function () {
                    return 'Error in maxPoolBackprop: input must be rank 4 but got rank ' + s.rank + '.'
                  })
                var c = Hr(s.shape, n, r, o, i, void 0)
                return Pt.runKernelFunc(
                  function (t) {
                    return t.maxPoolBackprop(a, s, u, c)
                  },
                  { $dy: a, $input: s },
                )
              })(e, n, r, o, i, a)
            },
          }
        },
        'MaxPool',
        u,
        n,
      ))
    return t ? n.as3D(n.shape[1], n.shape[2], n.shape[3]) : n
  }
  function pc(t, e, n, r, o, i) {
    var a = qe(t, 'x', 'avgPool', 'float32')
    A(to(n, (r = null == r ? [1, 1] : r)), function () {
      return 'Error in avgPool: Either strides or dilations must be 1. Got strides ' + n + " and dilations '" + r + "'"
    })
    var s = a,
      u = !1
    3 === a.rank && ((u = !0), (s = a.as4D(1, a.shape[0], a.shape[1], a.shape[2]))),
      A(4 === s.rank, function () {
        return 'Error in avgPool: x must be rank 4 but got rank ' + s.rank + '.'
      }),
      null != i &&
        A(N(o), function () {
          return 'Error in avgPool: pad must be an integer when using, dimRoundingMode ' + i + ' but got pad ' + o + '.'
        })
    var c = Hr(s.shape, e, n, r, o, i)
    if (1 === c.filterWidth && 1 === c.filterHeight && S(c.inShape, c.outShape)) return a.clone()
    t = (t = Pt.runKernelFunc(
      function (t) {
        return t.avgPool(s, c)
      },
      { x: s },
      function (l) {
        return {
          x: function () {
            return (function (t, e, n, r, o) {
              var i = qe(l, 'dy', 'avgPoolBackprop'),
                a = qe(t, 'input', 'avgPoolBackprop')
              A(a.rank === i.rank, function () {
                return 'Rank of input (' + a.rank + ') does not match rank of dy (' + i.rank + ')'
              }),
                A(to(n, (r = null == r ? [1, 1] : r)), function () {
                  return (
                    'Error in avgPoolBackprop: Either strides or dilations must be 1. Got strides ' +
                    n +
                    " and dilations '" +
                    r +
                    "'"
                  )
                })
              var s = a,
                u = i,
                t = !1
              3 === a.rank &&
                ((t = !0),
                (s = a.as4D(1, a.shape[0], a.shape[1], a.shape[2])),
                (u = i.as4D(1, i.shape[0], i.shape[1], i.shape[2]))),
                A(4 === u.rank, function () {
                  return 'Error in avgPoolBackprop: dy must be rank 4 but got rank ' + u.rank + '.'
                }),
                A(4 === s.rank, function () {
                  return 'Error in avgPoolBackprop: input must be rank 4 but got rank ' + s.rank + '.'
                })
              var c = Hr(s.shape, e, n, r, o),
                o = Pt.runKernelFunc(
                  function (t) {
                    return t.avgPoolBackprop(u, s, c)
                  },
                  { dy4D: u, input4D: s },
                )
              return t ? o.as3D(o.shape[1], o.shape[2], o.shape[3]) : o
            })(s, e, n, r, o)
          },
        }
      },
      'AvgPool',
      c,
    )).cast(a.dtype)
    return u ? t.as3D(t.shape[1], t.shape[2], t.shape[3]) : t
  }
  var dc = on({
      maxPool_: function (t, e, n, r, o) {
        return hc(t, e, n, 1, r, o)
      },
    }),
    fc = on({
      avgPool_: function (t, e, n, r, o) {
        return pc(t, e, n, 1, r, o)
      },
    }),
    vc = on({
      pool_: function (t, e, n, r, o, i) {
        null == o && (o = [1, 1]), null == i && (i = 1), 0 === r && (r = 'valid')
        var a = qe(t, 'x', 'maxPool'),
          s = a,
          u = !1
        3 === a.rank && ((u = !0), (s = a.as4D(1, a.shape[0], a.shape[1], a.shape[2]))),
          A(to(i, o), function () {
            return 'Error in pool: Either strides or dilations must be 1. Got strides ' + i + " and dilations '" + o + "'"
          })
        var c,
          l,
          h,
          p,
          d,
          f,
          v,
          m,
          g = Hr(s.shape, e, i, o, r),
          y = [g.dilationHeight, g.dilationWidth],
          t =
            'same' === r
              ? ((p = [g.filterHeight, g.filterWidth]),
                (c = y),
                (p = p
                  .map(function (t, e) {
                    return t + (t - 1) * (c[e] - 1)
                  })
                  .map(function (t) {
                    return t - 1
                  })),
                (l = p.map(function (t) {
                  return Math.floor(t / 2)
                })),
                (h = p.map(function (t, e) {
                  return t - l[e]
                })),
                p.map(function (t, e) {
                  return [l[e], h[e]]
                }))
              : [
                  [0, 0],
                  [0, 0],
                ],
          a = 1 === y[0] && 1 === y[1],
          t =
            ((p = [g.inHeight, g.inWidth]),
            (g = y),
            (d = (t = t).map(function (t) {
              return t[0]
            })),
            (t = t.map(function (t) {
              return t[1]
            })),
            (f = p.concat(d, t)),
            (v = g.map(function (t, e) {
              return (t - (f[e] % t)) % t
            })),
            (m = t.map(function (t, e) {
              return t + v[e]
            })),
            [
              g.map(function (t, e) {
                return [d[e], m[e]]
              }),
              g.map(function (t, e) {
                return [0, v[e]]
              }),
            ]),
          g = t[1],
          b = a ? r : 'valid',
          x = a ? s : lr(s, y, t[0]),
          n = (
            'avg' === n
              ? function () {
                  return pc(x, e, i, 1, b)
                }
              : function () {
                  return hc(x, e, i, 1, b)
                }
          )(),
          g = a ? n : Hn(n, y, g)
        return u ? g.as3D(g.shape[1], g.shape[2], g.shape[3]) : g
      },
    }),
    mc = on({
      maxPool3d_: function (t, r, o, i, a, e, s) {
        void 0 === e && (e = 'NDHWC')
        var n = qe(t, 'x', 'maxPool3d'),
          u = n,
          t = !1
        4 === n.rank && ((t = !0), (u = n.as5D(1, n.shape[0], n.shape[1], n.shape[2], n.shape[3]))),
          null == s && (s = [1, 1, 1]),
          A(5 === u.rank, function () {
            return 'Error in maxPool3d: x must be rank 5 but got rank ' + u.rank + '.'
          }),
          A('NDHWC' === e, function () {
            return 'Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ' + e
          }),
          A(to(o, s), function () {
            return 'Error in maxPool3d: Either strides or dilations must be 1. Got strides ' + o + " and dilations '" + s + "'"
          }),
          null != a &&
            A(N(i), function () {
              return 'Error in maxPool3d: pad must be an integer when using, dimRoundingMode ' + a + ' but got pad ' + i + '.'
            })
        var c = jr(u.shape, r, o, s, i, a, e),
          n = Pt.runKernelFunc(
            function (t, e) {
              t = t.maxPool3d(u, c)
              return e([u, t]), t
            },
            { x: u },
            function (d, t) {
              var e = t[0],
                n = t[1]
              return {
                x: function () {
                  return (function (t, e, n, r, o, i, a) {
                    var s = qe(d, 'dy', 'maxPool3dBackprop'),
                      u = qe(t, 'input', 'maxPool3dBackprop'),
                      t = qe(e, 'output', 'maxPool3dBackprop'),
                      c = s,
                      l = u,
                      h = t,
                      e = !1
                    4 === u.rank &&
                      ((e = !0),
                      (c = s.as5D(1, s.shape[0], s.shape[1], s.shape[2], s.shape[3])),
                      (l = u.as5D(1, u.shape[0], u.shape[1], u.shape[2], u.shape[3])),
                      (h = t.as5D(1, t.shape[0], t.shape[1], t.shape[2], t.shape[3]))),
                      A(5 === c.rank, function () {
                        return 'Error in maxPool3dBackprop: dy must be rank 5 but got rank ' + c.rank + '.'
                      }),
                      A(5 === l.rank, function () {
                        return 'Error in maxPool3dBackprop: input must be rank 5 but got rank ' + l.rank + '.'
                      }),
                      A(5 === h.rank, function () {
                        return 'Error in maxPool3dBackprop: output must be rank 5 but got rank ' + h.rank + '.'
                      }),
                      A(to(r, (o = null == o ? [1, 1, 1] : o)), function () {
                        return (
                          'Error in maxPool3dBackprop: Either strides or dilations must be 1. Got strides ' +
                          r +
                          " and dilations '" +
                          o +
                          "'"
                        )
                      }),
                      null != a &&
                        A(N(i), function () {
                          return (
                            'Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode ' +
                            a +
                            ' but got pad ' +
                            i +
                            '.'
                          )
                        })
                    var p = jr(l.shape, n, r, o, i, a),
                      n = Pt.runKernelFunc(
                        function (t) {
                          return t.maxPool3dBackprop(c, l, h, p)
                        },
                        { dy5D: c, input5D: l },
                      )
                    return e ? n.as4D(n.shape[1], n.shape[2], n.shape[3], n.shape[4]) : n
                  })(e, n, r, o, s, i, a)
                },
              }
            },
          )
        return t ? n.as4D(n.shape[1], n.shape[2], n.shape[3], n.shape[4]) : n
      },
    }),
    gc = on({
      avgPool3d_: function (t, e, n, r, o, i, a) {
        void 0 === i && (i = 'NDHWC')
        var s = qe(t, 'x', 'avgPool3d', 'float32'),
          u = s,
          t = !1
        4 === s.rank && ((t = !0), (u = s.as5D(1, s.shape[0], s.shape[1], s.shape[2], s.shape[3]))),
          null == a && (a = [1, 1, 1]),
          A(5 === u.rank, function () {
            return 'Error in avgPool3d: x must be rank 5 but got rank ' + u.rank + '.'
          }),
          A('NDHWC' === i, function () {
            return 'Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ' + i
          }),
          A(to(n, a), function () {
            return 'Error in avgPool3d: Either strides or dilations must be 1. Got strides ' + n + " and dilations '" + a + "'"
          }),
          null != o &&
            A(N(r), function () {
              return 'Error in avgPool3d: pad must be an integer when using, dimRoundingMode ' + o + ' but got pad ' + r + '.'
            })
        var c = jr(u.shape, e, n, a, r, o, i),
          s = (s = Pt.runKernelFunc(
            function (t) {
              return t.avgPool3d(u, c)
            },
            { x: u },
            function (h) {
              return {
                x: function () {
                  return (function (t, e, n, r, o, i) {
                    var a = qe(h, 'dy', 'avgPool3dBackprop'),
                      s = qe(t, 'input', 'avgPool3dBackprop'),
                      u = a,
                      c = s,
                      t = !1
                    4 === s.rank &&
                      ((t = !0),
                      (u = a.as5D(1, a.shape[0], a.shape[1], a.shape[2], a.shape[3])),
                      (c = s.as5D(1, s.shape[0], s.shape[1], s.shape[2], s.shape[3]))),
                      A(5 === u.rank, function () {
                        return 'Error in avgPool3dBackprop: dy must be rank 5 but got rank ' + u.rank + '.'
                      }),
                      A(5 === c.rank, function () {
                        return 'Error in avgPool3dBackprop: input must be rank 5 but got rank ' + c.rank + '.'
                      }),
                      A(to(n, (r = null == r ? [1, 1, 1] : r)), function () {
                        return (
                          'Error in avgPool3dBackprop: Either strides or dilations must be 1. Got strides ' +
                          n +
                          " and dilations '" +
                          r +
                          "'"
                        )
                      }),
                      null != i &&
                        A(N(o), function () {
                          return (
                            'Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode ' +
                            i +
                            ' but got pad ' +
                            o +
                            '.'
                          )
                        })
                    var l = jr(c.shape, e, n, r, o, i),
                      e = Pt.runKernelFunc(
                        function (t) {
                          return t.avgPool3dBackprop(u, c, l)
                        },
                        { dy5D: u, input5D: c },
                      )
                    return t ? e.as4D(e.shape[1], e.shape[2], e.shape[3], e.shape[4]) : e
                  })(u, e, n, a, r, o)
                },
              }
            },
          )).cast(u.dtype)
        return t ? s.as4D(s.shape[1], s.shape[2], s.shape[3], s.shape[4]) : s
      },
    }),
    yc = on({
      slice_: function (t, e, n) {
        var r,
          o,
          i = qe(t, 'x', 'slice')
        if (0 === i.rank) throw new Error('Slicing scalar is not possible')
        ;(r =
          'number' == typeof e
            ? [e].concat(new Array(i.rank - 1).fill(0))
            : e.length < i.rank
            ? e.concat(new Array(i.rank - e.length).fill(0))
            : e.slice()).forEach(function (t) {
          A(-1 !== t, function () {
            return 'slice() does not support negative begin indexing.'
          })
        }),
          (o = (o =
            null == n
              ? new Array(i.rank).fill(-1)
              : 'number' == typeof n
              ? [n].concat(new Array(i.rank - 1).fill(-1))
              : n.length < i.rank
              ? n.concat(new Array(i.rank - n.length).fill(-1))
              : n).map(function (t, e) {
            return 0 <= t
              ? t
              : (A(-1 === t, function () {
                  return 'Negative size values should be exactly -1 but got ' + t + ' for the slice() size at index ' + e + '.'
                }),
                i.shape[e] - r[e])
          })),
          Rr(i, r, o)
        var a = i.shape,
          n = { begin: r, size: o }
        return Pt.runKernelFunc(
          function (t) {
            return t.slice(i, r, o)
          },
          { x: i },
          function (t) {
            for (var e = [], n = 0; n < t.rank; n++) e.push([r[n], a[n] - r[n] - o[n]])
            return {
              x: function () {
                return t.pad(e)
              },
            }
          },
          'Slice',
          n,
        )
      },
    }),
    bc = on({
      slice1d_: function (t, e, n) {
        var r = qe(t, 'x', 'slice1d')
        return (
          A(1 === r.rank, function () {
            return 'slice1d expects a rank-1 tensor, but got a rank-' + r.rank + ' tensor'
          }),
          yc(r, [e], [n])
        )
      },
    }),
    xc = on({
      slice2d_: function (t, e, n) {
        var r = qe(t, 'x', 'slice2d')
        return (
          A(2 === r.rank, function () {
            return 'slice2d expects a rank-2 tensor, but got a rank-' + r.rank + ' tensor'
          }),
          yc(r, e, n)
        )
      },
    }),
    wc = on({
      slice3d_: function (t, e, n) {
        var r = qe(t, 'x', 'slice3d')
        return (
          A(3 === r.rank, function () {
            return 'slice3d expects a rank-3 tensor, but got a rank-' + r.rank + ' tensor'
          }),
          yc(r, e, n)
        )
      },
    }),
    Cc = on({
      slice4d_: function (t, e, n) {
        var r = qe(t, 'x', 'slice4d')
        return (
          A(4 === r.rank, function () {
            return 'slice4d expects a rank-4 tensor, but got a rank-' + r.rank + ' tensor'
          }),
          yc(r, e, n)
        )
      },
    })
  function Ec(e, n, r, t, o) {
    return (
      n.rank < r.rank && (n = n.reshape(Je(n.shape, t))),
      e.rank < r.rank && (e = e.reshape(Je(e.shape, t))),
      {
        x: function () {
          var t = e.mul(r.equal(n).cast(e.dtype))
          return null == o ? t : t.transpose(o)
        },
      }
    )
  }
  var Sc = on({
      all_: function (t, e, n) {
        void 0 === e && (e = null), void 0 === n && (n = !1)
        var r = qe(t, 'x', 'all', 'bool'),
          t = O(e, r.shape),
          o = t,
          e = Ze(o, r.rank)
        null != e && ((r = r.transpose(e)), (o = en(o.length, r.rank)))
        e = Pt.runKernelFunc(
          function (t) {
            return t.all(r, o)
          },
          { $x: r },
        )
        if (n) {
          t = Je(e.shape, t)
          return e.reshape(t)
        }
        return e
      },
    }),
    _c = on({
      any_: function (t, e, n) {
        void 0 === e && (e = null), void 0 === n && (n = !1)
        var r = qe(t, 'x', 'any', 'bool'),
          t = O(e, r.shape),
          o = t,
          e = Ze(o, r.rank)
        null != e && ((r = r.transpose(e)), (o = en(o.length, r.rank)))
        e = Pt.runKernelFunc(
          function (t) {
            return t.any(r, o)
          },
          { $x: r },
        )
        if (n) {
          t = Je(e.shape, t)
          return e.reshape(t)
        }
        return e
      },
    }),
    Rc = on({
      argMax_: function (t, e) {
        void 0 === e && (e = 0)
        var n = qe(t, 'x', 'argMax'),
          r = O((e = null == e ? 0 : e), n.shape),
          t = Ze(r, n.rank)
        null != t && ((n = n.transpose(t)), (r = en(r.length, n.rank)))
        ;(e = { axis: r[0] }), (t = [n])
        return Pt.runKernelFunc(
          function (t, e) {
            t = t.argMax(n, r[0])
            return e([n]), t
          },
          { x: n },
          function (t, e) {
            var n = e[0]
            return {
              x: function () {
                return wn(n)
              },
            }
          },
          'ArgMax',
          e,
          t,
        )
      },
    }),
    Ic = on({
      argMin_: function (t, e) {
        void 0 === e && (e = 0)
        var n = qe(t, 'x', 'argMin'),
          r = O((e = null == e ? 0 : e), n.shape),
          e = Ze(r, n.rank)
        return (
          null != e && ((n = n.transpose(e)), (r = en(r.length, n.rank))),
          Pt.runKernelFunc(
            function (t, e) {
              t = t.argMin(n, r[0])
              return e([n]), t
            },
            { $x: n },
            function (t, e) {
              var n = e[0]
              return {
                $x: function () {
                  return wn(n)
                },
              }
            },
          )
        )
      },
    }),
    Ac = on({
      logSumExp_: function (t, e, n) {
        void 0 === e && (e = null), void 0 === n && (n = !1)
        var r = qe(t, 'x', 'logSumExp'),
          t = O(e, r.shape),
          e = r.max(t, !0),
          r = r.sub(e).exp().sum(t).log(),
          r = e.reshape(r.shape).add(r)
        if (n) {
          t = Je(r.shape, t)
          return r.reshape(t)
        }
        return r
      },
    }),
    Nc = on({
      max_: function (t, e, n) {
        void 0 === e && (e = null), void 0 === n && (n = !1)
        var r = qe(t, 'x', 'max'),
          o = r,
          i = O(e, r.shape),
          a = i,
          s = Ze(a, r.rank)
        null != s && ((r = r.transpose(s)), (a = en(a.length, r.rank)))
        ;(e = [r]),
          (e = Pt.runKernelFunc(
            function (t, e) {
              t = t.max(r, a)
              return e([o, t]), t
            },
            { x: r },
            function (t, e) {
              return Ec(t, e[1], e[0], i, s)
            },
            'Max',
            { axes: a },
            e,
            [!0],
          ))
        return n && ((n = Je(e.shape, i)), (e = e.reshape(n))), e
      },
    }),
    kc = on({
      mean_: function (t, e, r) {
        void 0 === e && (e = null), void 0 === r && (r = !1)
        var t = qe(t, 'x', 'mean'),
          o = O(e, t.shape),
          i = D(Ye(t.shape, o)[1])
        return Or(function (n) {
          var t = hn(i)
          return {
            value: (t.dtype === n.dtype ? n : n.cast(t.dtype)).div(t).sum(e, r),
            gradFunc: function (t) {
              var e = n.shape.slice()
              return (
                o.forEach(function (t) {
                  e[t] = 1
                }),
                t.reshape(e).mul(mn(n.shape, 'float32')).div(i)
              )
            },
          }
        })(t)
      },
    }),
    Tc = on({
      min_: function (t, e, n) {
        void 0 === e && (e = null), void 0 === n && (n = !1)
        var r = qe(t, 'x', 'min'),
          o = r,
          i = O(e, r.shape),
          a = i,
          s = Ze(a, r.rank)
        null != s && ((r = r.transpose(s)), (a = en(a.length, r.rank)))
        ;(e = [r]),
          (e = Pt.runKernelFunc(
            function (t, e) {
              t = t.min(r, a)
              return e([o, t]), t
            },
            { x: r },
            function (t, e) {
              return Ec(t, e[1], e[0], i, s)
            },
            'Min',
            { axes: a },
            e,
            [!0],
          ))
        return n && ((n = Je(e.shape, i)), (e = e.reshape(n))), e
      },
    }),
    Dc = on({
      moments_: function (t, e, n) {
        void 0 === n && (n = !1)
        var r = O((e = void 0 === e ? null : e), (t = qe(t, 'x', 'moments')).shape),
          o = t.mean(r, n),
          e = o.shape
        n || (e = Je(o.shape, r))
        e = t.toFloat().sub(o.reshape(e)).square()
        return { mean: o, variance: e.mean(r, n) }
      },
    }),
    Oc = on({
      sum_: function (t, e, a) {
        void 0 === e && (e = null), void 0 === a && (a = !1)
        var t = qe(t, 'x', 'sum'),
          s = O(e, (t = 'bool' === t.dtype ? t.toInt() : t).shape)
        return Or(function (n) {
          var t = Ze(s, n.rank),
            e = s,
            r = n
          null != t && ((r = n.transpose(t)), (e = en(e.length, n.rank)))
          function o(t) {
            var e = n.shape.slice()
            return (
              s.forEach(function (t) {
                e[t] = 1
              }),
              t.reshape(e).mul(mn(n.shape, 'float32'))
            )
          }
          var i = { axes: e },
            t = Pt.runKernelFunc(
              function (t) {
                return t.sum(r, e)
              },
              { x: r },
              function (t) {
                return {
                  x: function () {
                    return o(t)
                  },
                }
              },
              'Sum',
              i,
            )
          return a && ((i = Je(t.shape, s)), (t = t.reshape(i))), { value: t, gradFunc: o }
        })(t)
      },
    }),
    Fc = on({
      prod_: function (t, e, n) {
        void 0 === e && (e = null), void 0 === n && (n = !1)
        var r = qe(t, 'x', 'prod'),
          t = O(e, (r = 'bool' === r.dtype ? r.toInt() : r).shape),
          e = Ze(t, r.rank),
          o = t,
          i = r
        null != e && ((i = r.transpose(e)), (o = en(o.length, r.rank)))
        r = Pt.runKernelFunc(
          function (t) {
            return t.prod(i, o)
          },
          { permutedX: i },
        )
        return n && ((t = Je(r.shape, t)), (r = r.reshape(t))), r
      },
    }),
    Mc = on({
      elu_: function (t) {
        var n = qe(t, 'x', 'elu')
        return Pt.runKernelFunc(
          function (t, e) {
            t = t.elu(n)
            return e([t]), t
          },
          { $x: n },
          function (e, t) {
            var n = t[0]
            return {
              $x: function () {
                return Pt.runKernelFunc(
                  function (t) {
                    return t.eluDer(e, n)
                  },
                  { dy: e, y: n },
                )
              },
            }
          },
        )
      },
    }),
    Pc = on({
      leakyRelu_: function (t, e) {
        void 0 === e && (e = 0.2)
        t = qe(t, 'x', 'leakyRelu')
        return fu(hn(e).mul(t), t)
      },
    }),
    Bc = on({
      prelu_: function (t, e) {
        var n = qe(t, 'x', 'prelu'),
          r = qe(e, 'alpha', 'prelu')
        return Pt.runKernelFunc(
          function (t, e) {
            t = t.prelu(n, r)
            return e([n, r]), t
          },
          { x: n, alpha: r },
          function (n, t) {
            var r = t[0],
              o = t[1],
              i = r.greater(0)
            return {
              x: function () {
                return iu(i, n, n.mul(o))
              },
              alpha: function () {
                var t = iu(i, wn(n), n.mul(r)),
                  e = Ur(o.shape, n.shape)
                return (t = 0 < e.length ? t.sum(e) : t).reshape(o.shape)
              },
            }
          },
          'Prelu',
        )
      },
    }),
    Lc = on({
      relu_: function (t) {
        var n = qe(t, 'x', 'relu')
        return 'bool' === n.dtype
          ? n.toInt()
          : Pt.runKernelFunc(
              function (t, e) {
                t = t.relu(n)
                return e([n]), t
              },
              { x: n },
              function (t, e) {
                var n = e[0]
                return {
                  x: function () {
                    return t.mulStrict(n.step().toFloat())
                  },
                }
              },
              'Relu',
            )
      },
    }),
    Wc = on({
      relu6_: function (t) {
        var n = qe(t, 'x', 'relu6')
        return 'bool' === n.dtype
          ? n.toInt()
          : Pt.runKernelFunc(
              function (t, e) {
                t = t.relu6(n)
                return e([n]), t
              },
              { x: n },
              function (t, e) {
                var e = e[0],
                  n = e.lessEqual(6).mul(e.step())
                return {
                  x: function () {
                    return t.mulStrict(n.toFloat())
                  },
                }
              },
              'Relu6',
            )
      },
    }),
    zc = on({
      selu_: function (t) {
        var n = qe(t, 'x', 'selu')
        return Pt.runKernelFunc(
          function (t, e) {
            t = t.selu(n)
            return e([n]), t
          },
          { $x: n },
          function (r, t) {
            var o = t[0]
            return {
              $x: function () {
                var t = o.greater(hn(0)),
                  e = hn(Pa),
                  n = hn(Ba),
                  n = r.mul(n),
                  e = r.mul(e).mul(o.toFloat().exp())
                return iu(t, n, e)
              },
            }
          },
        )
      },
    }),
    Gc = on({
      transpose_: function (t, n) {
        var e = qe(t, 'x', 'transpose')
        if (
          (null == n &&
            (n = e.shape
              .map(function (t, e) {
                return e
              })
              .reverse()),
          A(e.rank === n.length, function () {
            return 'Error in transpose: rank of input ' + e.rank + ' must match length of perm ' + n + '.'
          }),
          n.forEach(function (t) {
            A(0 <= t && t < e.rank, function () {
              return "All entries in 'perm' must be between 0 and " + (e.rank - 1) + ' but got ' + n
            })
          }),
          e.rank <= 1)
        )
          return e.clone()
        t = { perm: n }
        return Pt.runKernelFunc(
          function (t) {
            return t.transpose(e, n)
          },
          { x: e },
          function (t) {
            var e = tn(n)
            return {
              x: function () {
                return t.transpose(e)
              },
            }
          },
          'Transpose',
          t,
        )
      },
    }),
    Uc = on({
      localResponseNormalization_: function (t, o, i, a, s) {
        void 0 === o && (o = 5), void 0 === i && (i = 1), void 0 === a && (a = 1), void 0 === s && (s = 0.5)
        var e = qe(t, 'x', 'localResponseNormalization')
        A(4 === e.rank || 3 === e.rank, function () {
          return 'Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ' + e.rank + '.'
        }),
          A(N(o), function () {
            return 'Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ' + o + '.'
          })
        var n = e,
          r = !1
        3 === e.rank && ((r = !0), (n = e.as4D(1, e.shape[0], e.shape[1], e.shape[2])))
        t = Pt.runKernelFunc(
          function (t, e) {
            t = t.localResponseNormalization4D(n, o, i, a, s)
            return e([n, t]), t
          },
          { x4D: n },
          function (e, t) {
            var n = t[0],
              r = t[1]
            return {
              x4D: function () {
                return Pt.runKernelFunc(function (t) {
                  return t.LRNGrad(e, n, r, o, i, a, s)
                }, {})
              },
            }
          },
        )
        return r ? t.as3D(t.shape[1], t.shape[2], t.shape[3]) : t
      },
    }),
    Vc = on({
      norm_: function (t, e, n, r) {
        void 0 === e && (e = 'euclidean'), void 0 === n && (n = null), void 0 === r && (r = !1)
        var o = (function t(e, n, r) {
            if ((void 0 === r && (r = null), 0 === e.rank)) return e.abs()
            if (1 !== e.rank && null === r) return t(e.reshape([-1]), n, r)
            if (1 === e.rank || 'number' == typeof r || (Array.isArray(r) && 1 === r.length)) {
              if (1 === n) return e.abs().sum(r)
              if (n === 1 / 0) return e.abs().max(r)
              if (n === -1 / 0) return e.abs().min(r)
              if ('euclidean' === n || 2 === n) return e.abs().pow(hn(2, 'int32')).sum(r).sqrt()
              throw new Error('Error in norm: invalid ord value: ' + n)
            }
            if (Array.isArray(r) && 2 === r.length) {
              if (1 === n)
                return e
                  .abs()
                  .sum(r[0])
                  .max(r[1] - 1)
              if (n === 1 / 0) return e.abs().sum(r[1]).max(r[0])
              if (n === -1 / 0) return e.abs().sum(r[1]).min(r[0])
              if ('fro' === n || 'euclidean' === n) return e.square().sum(r).sqrt()
              throw new Error('Error in norm: invalid ord value: ' + n)
            }
            throw new Error('Error in norm: invalid axis: ' + r)
          })((t = qe(t, 'x', 'norm')), e, n),
          e = o.shape
        return r && ((t = O(n, t.shape)), (e = Je(o.shape, t))), o.reshape(e)
      },
    }),
    Hc = on({
      basicLSTMCell_: function (t, e, n, r, o, i) {
        var a = qe(t, 'forgetBias', 'basicLSTMCell'),
          s = qe(e, 'lstmKernel', 'basicLSTMCell'),
          t = qe(n, 'lstmBias', 'basicLSTMCell'),
          e = qe(r, 'data', 'basicLSTMCell'),
          n = qe(o, 'c', 'basicLSTMCell'),
          r = qe(i, 'h', 'basicLSTMCell'),
          o = e.concat(r, 1).matMul(s).add(t),
          i = o.shape[0],
          e = o.shape[1] / 4,
          r = [i, e],
          s = o.slice([0, 0], r),
          t = o.slice([0, e], r),
          i = o.slice([0, 2 * e], r),
          r = o.slice([0, 3 * e], r),
          i = s
            .sigmoid()
            .mulStrict(t.tanh())
            .addStrict(n.mulStrict(a.add(i).sigmoid())),
          r = i.tanh().mulStrict(r.sigmoid())
        return [i, r]
      },
    }),
    jc = on({
      multiRNNCell_: function (t, e, n, r) {
        for (
          var e = qe(e, 'data', 'multiRNNCell'),
            o = Ke(n, 'c', 'multiRNNCell'),
            i = Ke(r, 'h', 'multiRNNCell'),
            a = e,
            s = [],
            u = 0;
          u < t.length;
          u++
        ) {
          var c = t[u](a, o[u], i[u])
          s.push(c[0]), s.push(c[1]), (a = c[1])
        }
        for (var l = [], h = [], u = 0; u < s.length; u += 2) l.push(s[u]), h.push(s[u + 1])
        return [l, h]
      },
    }),
    qc = on({
      movingAverage_: function (t, e, n, r, o) {
        void 0 === o && (o = !0)
        var i = qe(t, 'v', 'movingAverage'),
          a = qe(e, 'x', 'movingAverage'),
          t = qe(n, 'decay', 'movingAverage')
        Nt(i, a),
          A(S(i.shape, a.shape), function () {
            return 'Shape mismatch in v and x'
          })
        ;(e = hn(1)), (n = e.sub(t)), (n = a.sub(i).mul(n))
        return (
          o &&
            (A(null != r, function () {
              return 'When using zeroDebias: true, step is required.'
            }),
            (r = qe(r, 'step', 'movingAverage')),
            (n = n.div(e.sub(Cu(t, r))))),
          i.add(n)
        )
      },
    }),
    Kc = on({
      stridedSlice_: function (t, e, n, r, o, i, a, s, u) {
        if (
          (void 0 === o && (o = 0),
          void 0 === i && (i = 0),
          void 0 === a && (a = 0),
          void 0 === s && (s = 0),
          void 0 === u && (u = 0),
          null == r && (r = new Array(e.length)),
          0 !== a)
        )
          throw new Error('ellipsis mask is not yet supported')
        var c = qe(t, 'x', 'stridedSlice'),
          s = Ir(s),
          l = c.shape.slice()
        s.forEach(function (t) {
          ;(e[t] = 0), (n[t] = 1), l.splice(t, 0, 1)
        })
        for (var c = c.reshape(l), h = 0; h < c.rank; h++)
          (e[h] = Nr(o, e, r, c.shape, h)), (n[h] = kr(i, n, r, c.shape, h)), (r[h] = r[h] || 1)
        var p = Ir(u)
        p.forEach(function (t) {
          ;(n[t] = e[t] + 1), (r[t] = 1)
        })
        ;(s = Ar(e, n, r)),
          (u = s.filter(function (t, e) {
            return -1 === p.indexOf(e)
          }))
        return (
          r.every(function (t) {
            return 1 === t
          })
            ? yc(c, e, s)
            : Pt.runKernelFunc(
                function (t) {
                  return t.stridedSlice(c, e, n, r)
                },
                { $x: c },
              )
        ).reshape(u)
      },
    }),
    Xc = on({
      topk_: function (t, e, n) {
        void 0 === e && (e = 1), void 0 === n && (n = !0)
        var r = qe(t, 'x', 'topk')
        if (0 === r.rank) throw new Error('topk() expects the input to be of rank 1 or higher')
        t = r.shape[r.shape.length - 1]
        if (t < e) throw new Error("'k' passed to topk() must be <= the last dimension (" + t + ') but got ' + e)
        t = Pt.runKernelFunc(
          function (t) {
            return t.topk(r, e, n)
          },
          { $x: r },
        )
        return { values: t[0], indices: t[1] }
      },
    }),
    $c = on({
      scatterND_: function (t, e, n) {
        var r = qe(t, 'indices', 'scatterND', 'int32'),
          o = qe(e, 'updates', 'scatterND')
        return (
          Sr(o, r, n),
          Pt.runKernelFunc(
            function (t) {
              return t.scatterND(r, o, n)
            },
            { indices: r, updates: o },
            null,
            'ScatterNd',
            { shape: n },
          )
        )
      },
    }),
    Yc = on({
      fft_: function (t) {
        A('complex64' === t.dtype, function () {
          return 'The dtype for tf.spectral.fft() must be complex64 but got ' + t.dtype + '.'
        })
        var e = t.shape[t.shape.length - 1],
          n = t.size / e,
          r = t.as2D(n, e)
        return Pt.runKernelFunc(
          function (t) {
            return t.fft(r)
          },
          { input: t },
        ).reshape(t.shape)
      },
    }),
    Jc = on({
      ifft_: function (t) {
        A('complex64' === t.dtype, function () {
          return 'The dtype for tf.spectral.ifft() must be complex64 but got ' + t.dtype + '.'
        })
        var e = t.shape[t.shape.length - 1],
          n = t.size / e,
          r = t.as2D(n, e)
        return Pt.runKernelFunc(
          function (t) {
            return t.ifft(r)
          },
          { input: t },
        ).reshape(t.shape)
      },
    }),
    Qc = on({
      rfft_: function (t, e) {
        A('float32' === t.dtype, function () {
          return 'The dtype for rfft() must be real value but got ' + t.dtype
        })
        var n,
          r,
          o = t.shape[t.shape.length - 1],
          i = t.size / o
        null != e && e < o
          ? ((n = t.shape.map(function (t) {
              return 0
            })),
            ((r = t.shape.map(function (t) {
              return t
            }))[t.shape.length - 1] = e),
            (r = t.slice(n, r)),
            (o = e))
          : null != e && o < e
          ? (((a = t.shape.map(function (t) {
              return t
            }))[t.shape.length - 1] = e - o),
            (r = t.concat(gn(a), t.shape.length - 1)),
            (o = e))
          : (r = t)
        var a = r.zerosLike(),
          e = an(r, a).as2D(i, o),
          a = Yc(e),
          i = Math.floor(o / 2) + 1,
          e = sn(a),
          a = un(a),
          e = e.split([i, o - i], e.shape.length - 1),
          o = a.split([i, o - i], a.shape.length - 1),
          a = r.shape.slice()
        return (a[r.shape.length - 1] = i), an(e[0], o[0]).reshape(a)
      },
    }),
    Zc = on({
      irfft_: function (t) {
        var e = t.shape[t.shape.length - 1],
          n = t.size / e
        if (e <= 2) {
          var r = t.as2D(n, e),
            o = Jc(r)
          return sn(o)
        }
        var i = [n, 2 * (e - 1)],
          a = sn(t).as2D(n, e),
          s = un(t).as2D(n, e),
          t = a.slice([0, 1], [n, e - 2]).reverse(1),
          e = s
            .slice([0, 1], [n, e - 2])
            .reverse(1)
            .mul(hn(-1)),
          t = a.concat(t, 1),
          e = s.concat(e, 1),
          r = an(t, e).as2D(i[0], i[1]),
          o = Jc(r)
        return sn(o)
      },
    }),
    tl = Object.freeze({ fft: Yc, ifft: Jc, rfft: Qc, irfft: Zc }),
    el = on({
      sparseToDense_: function (t, e, n, r) {
        void 0 === r && (r = 0)
        var o = qe(t, 'sparseIndices', 'sparseToDense', 'int32'),
          i = qe(e, 'sparseValues', 'sparseToDense'),
          a = qe(r, 'defaultValue', 'sparseToDense', i.dtype)
        return (
          (function (t, e, n, r) {
            if ('int32' !== t.dtype)
              throw new Error('tf.sparseToDense() expects the indices to be int32 type, but the dtype was ' + t.dtype + '.')
            if (2 < t.rank)
              throw new Error('sparseIndices should be a scalar, vector, or matrix, but got shape ' + t.shape + '.')
            var o = 0 < t.rank ? t.shape[0] : 1,
              t = 1 < t.rank ? t.shape[1] : 1
            if (n.length !== t)
              throw new Error('outputShape has incorrect number of elements:, ' + n.length + ', should be: ' + t + '.')
            t = e.size
            if (0 !== e.rank && (1 !== e.rank || t !== o))
              throw new Error('sparseValues has incorrect shape ' + e.shape + ', should be [] or [' + o + ']')
            if (e.dtype !== r.dtype) throw new Error('sparseValues.dtype must match defaultValues.dtype')
          })(o, i, n, a),
          Pt.runKernelFunc(
            function (t) {
              return t.sparseToDense(o, i, n, a)
            },
            { $sparseIndices: o, $sparseValues: i, $defaultValue: a },
          )
        )
      },
    }),
    nl = on({
      gatherND_: function (t, e) {
        var n = qe(e, 'indices', 'gatherND', 'int32'),
          r = qe(t, 'x', 'gatherND')
        return Pt.runKernelFunc(
          function (t) {
            return t.gatherND(r, n)
          },
          { x: r, indices: n },
          null,
          'GatherNd',
        )
      },
    }),
    o = on({
      diag_: function (t) {
        var e = qe(t, 'x', 'diag').flatten(),
          t = t.shape.concat(t.shape)
        return Pt.runKernelFunc(
          function (t) {
            return t.diag(e)
          },
          { $x: e },
        ).reshape(t)
      },
    }),
    Dt = on({
      dropout_: function (t, e, n, r) {
        var o = qe(t, 'x', 'dropout')
        if (
          (A('float32' === o.dtype, function () {
            return (
              "x has to be a floating point tensor since it's going to be scaled, but got a " + o.dtype + ' tensor instead.'
            )
          }),
          A(0 <= e && e < 1, function () {
            return 'rate must be a float in the range [0, 1), but got ' + e + '.'
          }),
          0 === e)
        )
          return t instanceof bt ? o.clone() : o
        ;(t = (function (t, e) {
          if (null == e) return t.shape.slice()
          if (S(t.shape, e)) return e
          if (t.shape.length !== e.length) return e
          for (var n = [], r = 0; r < t.shape.length; r++)
            null == e[r] && null != t.shape[r] ? n.push(t.shape[r]) : n.push(e[r])
          return n
        })(o, n)),
          (n = 1 - e),
          (n = ur(t, 0, 1, 'float32', r).add(n).floor().div(n))
        return o.mul(n)
      },
    })
  function rl(t, e, n) {
    for (var r = 1 - (t % 2), o = new Float32Array(t), i = 0; i < t; ++i) {
      var a = (2 * Math.PI * i) / (t + r - 1)
      o[i] = e - n * Math.cos(a)
    }
    return pn(o, 'float32')
  }
  var ol,
    il = on({
      hannWindow_: function (t) {
        return rl(t, 0.5, 0.5)
      },
    }),
    al = on({
      hammingWindow_: function (t) {
        return rl(t, 0.54, 0.46)
      },
    }),
    sl = on({
      frame_: function (t, e, n, r, o) {
        void 0 === r && (r = !1), void 0 === o && (o = 0)
        for (var i = 0, a = []; i + e <= t.size; ) a.push(yc(t, i, e)), (i += n)
        if (r)
          for (; i < t.size; ) {
            var s = i + e - t.size,
              s = Cn([yc(t, i, e - s), yn([s], o)])
            a.push(s), (i += n)
          }
        return 0 === a.length ? dn([], [0, e]) : Cn(a).as2D(a.length, e)
      },
    }),
    ul = on({
      stft_: function (t, e, n, r, o) {
        void 0 === o && (o = il), null == r && (r = Math.floor(Math.pow(2, Math.ceil(Math.log(e) / Math.log(2)))))
        for (var i = sl(t, e, n), a = xu(i, o(e)), s = [], u = 0; u < i.shape[0]; u++) s.push(Qc(a.slice([u, 0], [1, e]), r))
        return Cn(s)
      },
    }),
    cl = Object.freeze({ hannWindow: il, hammingWindow: al, frame: sl, stft: ul })
  ;((hl = ol = ol || {})[(hl.NONE = 0)] = 'NONE'),
    (hl[(hl.MEAN = 1)] = 'MEAN'),
    (hl[(hl.SUM = 2)] = 'SUM'),
    (hl[(hl.SUM_BY_NONZERO_WEIGHTS = 3)] = 'SUM_BY_NONZERO_WEIGHTS')
  var Nn = on({
      absoluteDifference_: function (t, e, n, r) {
        void 0 === r && (r = ol.SUM_BY_NONZERO_WEIGHTS)
        var o = qe(t, 'labels', 'absoluteDifference'),
          t = qe(e, 'predictions', 'absoluteDifference'),
          e = null
        null != n && (e = qe(n, 'weights', 'absoluteDifference')), y(o.shape, t.shape, 'Error in absoluteDifference: ')
        t = o.sub(t).abs()
        return ll(t, e, r)
      },
    }),
    ll = on({
      computeWeightedLoss_: function (t, e, n) {
        void 0 === n && (n = ol.SUM_BY_NONZERO_WEIGHTS)
        var r = qe(t, 'losses', 'computeWeightedLoss'),
          o = null,
          i = null == (o = null != e ? qe(e, 'weights', 'computeWeightedLoss') : o) ? r : r.mul(o)
        if (n === ol.NONE) return i
        if (n === ol.SUM) return i.sum()
        if (n === ol.MEAN) {
          if (null == o) return i.mean()
          ;(t = r.size / o.size), (e = i.sum().div(o.sum()))
          return 1 < t ? e.div(hn(t)) : e
        }
        if (n !== ol.SUM_BY_NONZERO_WEIGHTS) throw Error('Unknown reduction: ' + n)
        if (null == o) return i.sum().div(hn(r.size))
        r = o.mul(mn(r.shape)).notEqual(hn(0)).sum().toFloat()
        return i.sum().div(r)
      },
    }),
    kn = on({
      cosineDistance_: function (t, e, n, r, o) {
        void 0 === o && (o = ol.SUM_BY_NONZERO_WEIGHTS)
        var i = qe(t, 'labels', 'cosineDistance'),
          t = qe(e, 'predictions', 'cosineDistance'),
          e = null
        null != r && (e = qe(r, 'weights', 'cosineDistance')), y(i.shape, t.shape, 'Error in cosineDistance: ')
        n = hn(1).sub(i.mul(t).sum(n, !0))
        return ll(n, e, o)
      },
    }),
    Tn = on({
      hingeLoss_: function (t, e, n, r) {
        void 0 === r && (r = ol.SUM_BY_NONZERO_WEIGHTS)
        var o = qe(t, 'labels', 'hingeLoss'),
          t = qe(e, 'predictions', 'hingeLoss'),
          e = null
        null != n && (e = qe(n, 'weights', 'hingeLoss')), y(o.shape, t.shape, 'Error in hingeLoss: ')
        ;(n = hn(1)), (o = hn(2).mul(o).sub(n)), (t = n.sub(o.mul(t)).relu())
        return ll(t, e, r)
      },
    }),
    Dn = on({
      huberLoss_: function (t, e, n, r, o) {
        void 0 === r && (r = 1), void 0 === o && (o = ol.SUM_BY_NONZERO_WEIGHTS)
        var i = qe(t, 'labels', 'huberLoss'),
          t = qe(e, 'predictions', 'huberLoss'),
          e = null
        null != n && (e = qe(n, 'weights', 'huberLoss')), y(i.shape, t.shape, 'Error in huberLoss: ')
        ;(r = hn(r)), (t = t.sub(i).abs()), (i = mu(t, r)), (t = t.sub(i)), (t = hn(0.5).mul(i.square()).add(r.mul(t)))
        return ll(t, e, o)
      },
    }),
    On = on({
      logLoss_: function (t, e, n, r, o) {
        void 0 === r && (r = 1e-7), void 0 === o && (o = ol.SUM_BY_NONZERO_WEIGHTS)
        var i = qe(t, 'labels', 'logLoss'),
          t = qe(e, 'predictions', 'logLoss'),
          e = null
        null != n && (e = qe(n, 'weights', 'logLoss')), y(i.shape, t.shape, 'Error in logLoss: ')
        ;(n = hn(1)),
          (r = hn(r)),
          (r = i
            .mul(t.add(r).log())
            .neg()
            .sub(n.sub(i).mul(n.sub(t).add(r).log())))
        return ll(r, e, o)
      },
    }),
    Fn = on({
      meanSquaredError_: function (t, e, n, r) {
        void 0 === r && (r = ol.SUM_BY_NONZERO_WEIGHTS)
        var o = qe(t, 'labels', 'meanSquaredError'),
          t = qe(e, 'predictions', 'meanSquaredError'),
          e = null
        null != n && (e = qe(n, 'weights', 'meanSquaredError')), y(o.shape, t.shape, 'Error in meanSquaredError: ')
        t = o.squaredDifference(t)
        return ll(t, e, r)
      },
    }),
    Mn = on({
      sigmoidCrossEntropy_: function (t, e, n, r, o) {
        void 0 === r && (r = 0), void 0 === o && (o = ol.SUM_BY_NONZERO_WEIGHTS)
        var i = qe(t, 'multiClassLabels', 'sigmoidCrossEntropy'),
          a = qe(e, 'logits', 'sigmoidCrossEntropy'),
          t = null
        null != n && (t = qe(n, 'weights', 'sigmoidCrossEntropy')),
          y(i.shape, a.shape, 'Error in sigmoidCrossEntropy: '),
          0 < r && ((e = hn(r)), (n = hn(1)), (r = hn(0.5)), (i = i.mul(n.sub(e)).add(r.mul(e))))
        a = (function (t) {
          var e = qe(i, 'labels', 'sigmoidCrossEntropyWithLogits'),
            n = qe(t, 'logits', 'sigmoidCrossEntropyWithLogits')
          y(e.shape, n.shape, 'Error in sigmoidCrossEntropyWithLogits: ')
          ;(t = n.relu()), (e = n.mul(e)), (n = n.abs().neg().exp().log1p())
          return t.sub(e).add(n)
        })(a)
        return ll(a, t, o)
      },
    }),
    hl = on({
      softmaxCrossEntropy_: function (t, e, n, r, o) {
        void 0 === r && (r = 0), void 0 === o && (o = ol.SUM_BY_NONZERO_WEIGHTS)
        var i = qe(t, 'onehotLabels', 'softmaxCrossEntropy'),
          a = qe(e, 'logits', 'softmaxCrossEntropy'),
          t = null
        null != n && (t = qe(n, 'weights', 'softmaxCrossEntropy')),
          y(i.shape, a.shape, 'Error in softmaxCrossEntropy: '),
          0 < r && ((e = hn(r)), (n = hn(1)), (r = hn(i.shape[1])), (i = i.mul(n.sub(e)).add(e.div(r))))
        a = (function (t, e, o) {
          if ((o = -1 === (o = void 0 === o ? -1 : o) ? e.rank - 1 : o) !== e.rank - 1)
            throw Error(
              'Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ' +
                e.rank +
                ' and dim was ' +
                o,
            )
          return Or(function (t, e, n) {
            var r = e.logSumExp([o], !0),
              r = e.toFloat().sub(r)
            return (
              n([t, r]),
              {
                value: r.mul(t).neg().sum([o]),
                gradFunc: function (t, e) {
                  var n = e[0],
                    r = e[1],
                    e = Je(t.shape, [o])
                  return [t.reshape(e).mul(n.toFloat().sub(r.exp())), t.reshape(e).mul(r.exp().sub(n.toFloat()))]
                },
              }
            )
          })(t, e)
        })(i, a)
        return ll(a, t, o)
      },
    }),
    kn = Object.freeze({
      get Reduction() {
        return ol
      },
      absoluteDifference: Nn,
      computeWeightedLoss: ll,
      cosineDistance: kn,
      hingeLoss: Tn,
      huberLoss: Dn,
      logLoss: On,
      meanSquaredError: Fn,
      sigmoidCrossEntropy: Mn,
      softmaxCrossEntropy: hl,
    })
  function pl(n, r) {
    return (
      void 0 === r && (r = !1),
      Pt.tidy(function () {
        if (2 !== n.shape.length) throw new Error('qr2d() requires a 2D Tensor, but got a ' + n.shape.length + 'D Tensor.')
        for (
          var a = n.shape[0],
            s = n.shape[1],
            u = Jn(a),
            c = n.clone(),
            l = dn([[1]], [1, 1]),
            h = l.clone(),
            t = s <= a ? s : a,
            e = 0;
          e < t;
          ++e
        )
          !(function (i) {
            var t = c,
              e = h,
              n = u,
              r = Pt.tidy(function () {
                var t = c.slice([i, i], [a - i, 1]),
                  e = t.norm(),
                  n = c.slice([i, i], [1, 1]),
                  r = dn([[-1]]).where(n.greater(0), dn([[1]])),
                  n = n.sub(r.mul(e)),
                  t = t.div(n)
                h = 1 === t.shape[0] ? l.clone() : l.concat(t.slice([1, 0], [t.shape[0] - 1, t.shape[1]]), 0)
                ;(n = r.matMul(n).div(e).neg()), (e = c.slice([i, 0], [a - i, s])), (n = n.mul(h))
                c =
                  0 === i
                    ? e.sub(n.matMul(h.transpose().matMul(e)))
                    : ((o = e.sub(n.matMul(h.transpose().matMul(e)))), c.slice([0, 0], [i, s]).concat(o, 0))
                var o = u.slice([0, i], [a, u.shape[1] - i])
                return (
                  (u =
                    0 === i
                      ? o.sub(o.matMul(h).matMul(n.transpose()))
                      : ((n = o.sub(o.matMul(h).matMul(n.transpose()))), u.slice([0, 0], [a, i]).concat(n, 1))),
                  [h, c, u]
                )
              })
            ;(h = r[0]), (c = r[1]), (u = r[2]), Ue([t, e, n])
          })(e)
        return !r && s < a && ((u = u.slice([0, 0], [a, s])), (c = c.slice([0, 0], [s, s]))), [u, c]
      })
    )
  }
  ;(Tn = on({
    bandPart_: function (t, e, n) {
      if (e % 1 != 0) throw new Error('bandPart(): numLower must be an integer, got ' + e + '.')
      if (n % 1 != 0) throw new Error('bandPart(): numUpper must be an integer, got ' + n + '.')
      var r = qe(t, 'a', 'bandPart')
      if (r.rank < 2) throw new Error('bandPart(): Rank must be at least 2, got ' + r.rank + '.')
      var o = r.shape,
        i = r.shape.slice(-2),
        a = i[0],
        s = i[1]
      if (!(e <= a))
        throw new Error('bandPart(): numLower (' + e + ') must not be greater than the number of rows (' + a + ').')
      if (!(n <= s))
        throw new Error('bandPart(): numUpper (' + n + ') must not be greater than the number of columns (' + s + ').')
      e < 0 && (e = a), n < 0 && (n = s)
      var t = bn(0, a, 1, 'int32').reshape([-1, 1]),
        i = bn(0, s, 1, 'int32'),
        i = _u(t, i),
        u = eu(i.lessEqual(hn(+e, 'int32')), i.greaterEqual(hn(-n, 'int32'))),
        c = gn([a, s], r.dtype)
      return pr(
        vr(r.reshape([-1, a, s])).map(function (t) {
          return iu(u, t, c)
        }),
      ).reshape(o)
    },
  })),
    (Dn = on({
      gramSchmidt_: function (e) {
        var t
        if (Array.isArray(e)) {
          ;(t = !1),
            A(null != e && 0 < e.length, function () {
              return 'Gram-Schmidt process: input must not be null, undefined, or empty'
            })
          for (var n = e[0].shape[0], r = 1; r < e.length; ++r)
            !(function (t) {
              A(e[t].shape[0] === n, function () {
                return 'Gram-Schmidt: Non-unique lengths found in the input vectors: (' + e[t].shape[0] + ' vs. ' + n + ')'
              })
            })(r)
        } else
          (t = !0),
            (e = In(e, e.shape[0], 0).map(function (t) {
              return hr(t, [0])
            }))
        A(e.length <= e[0].shape[0], function () {
          return 'Gram-Schmidt: Number of vectors (' + e.length + ') exceeds number of dimensions (' + e[0].shape[0] + ').'
        })
        for (var o = [], i = e, r = 0; r < e.length; ++r)
          !(function (r) {
            o.push(
              Pt.tidy(function () {
                var t = i[r]
                if (0 < r) for (var e = 0; e < r; ++e) var n = Oc(o[e].mulStrict(t)).mul(o[e]), t = t.sub(n)
                return t.div(Vc(t, 'euclidean'))
              }),
            )
          })(r)
        return t ? pr(o, 0) : o
      },
    })),
    (On = on({
      qr_: function (t, n) {
        if ((void 0 === n && (n = !1), t.rank < 2))
          throw new Error('qr() requires input tensor to have a rank >= 2, but got rank ' + t.rank)
        if (2 === t.rank) return pl(t, n)
        var e = t.shape.slice(0, t.shape.length - 2).reduce(function (t, e) {
            return t * e
          }),
          e = vr(t.reshape([e, t.shape[t.shape.length - 2], t.shape[t.shape.length - 1]]), 0),
          r = [],
          o = []
        return (
          e.forEach(function (t) {
            var e = pl(t, n),
              t = e[0],
              e = e[1]
            r.push(t), o.push(e)
          }),
          [pr(r, 0).reshape(t.shape), pr(o, 0).reshape(t.shape)]
        )
      },
    })),
    (Fn = Object.freeze({ bandPart: Tn, gramSchmidt: Dn, qr: On }))
  function dl(t, e, n, r, o, i) {
    null == r && (r = 0.5), null == o && (o = Number.NEGATIVE_INFINITY), null == i && (i = 0)
    var a = t.shape[0]
    return (
      (n = Math.min(n, a)),
      A(0 <= r && r <= 1, function () {
        return "iouThreshold must be in [0, 1], but was '" + r + "'"
      }),
      A(2 === t.rank, function () {
        return "boxes must be a 2D tensor, but was of rank '" + t.rank + "'"
      }),
      A(4 === t.shape[1], function () {
        return 'boxes must have 4 columns, but 2nd dimension was ' + t.shape[1]
      }),
      A(1 === e.rank, function () {
        return 'scores must be a 1D tensor'
      }),
      A(e.shape[0] === a, function () {
        return 'scores has incompatible shape with boxes. Expected ' + a + ', but was ' + e.shape[0]
      }),
      A(0 <= i && i <= 1, function () {
        return "softNmsSigma must be in [0, 1], but was '" + i + "'"
      }),
      { maxOutputSize: n, iouThreshold: r, scoreThreshold: o, softNmsSigma: i }
    )
  }
  function fl(t, e) {
    return !(0 < t) || 'linear' === e
  }
  function vl(t, e, n) {
    if (null == n || 'linear' === n) return t
    if ('relu' === n) return t.mul(e.step())
    throw new Error('Gradient for activation ' + n + ' has not been implemented yet.')
  }
  function ml(t, e) {
    var n = e,
      e = Ur(t.shape, e.shape)
    return (n = 0 < e.length ? n.sum(e) : n).reshape(t.shape)
  }
  function gl(t, e, n) {
    if ('linear' === e) return t
    if ('relu' === e) return Lc(t)
    if ('elu' === e) return Mc(t)
    if ('relu6' === e) return Wc(t)
    if ('prelu' === e) return Bc(t, n)
    throw new Error('Unknown fused activation ' + e + '.')
  }
  var Mn = on({
      resizeBilinear_: function (t, e, r) {
        void 0 === r && (r = !1)
        var n = qe(t, 'images', 'resizeBilinear')
        A(3 === n.rank || 4 === n.rank, function () {
          return 'Error in resizeBilinear: x must be rank 3 or 4, but got rank ' + n.rank + '.'
        }),
          A(2 === e.length, function () {
            return 'Error in resizeBilinear: new shape must 2D, but got shape ' + e + '.'
          })
        var o = n,
          i = !1
        3 === n.rank && ((i = !0), (o = n.as4D(1, n.shape[0], n.shape[1], n.shape[2])))
        var a = e[0],
          s = e[1],
          t = Pt.runKernelFunc(
            function (t, e) {
              return e([o]), t.resizeBilinear(o, a, s, r)
            },
            { x: o },
            function (e, n) {
              return {
                x: function () {
                  return Pt.runKernelFunc(function (t) {
                    return t.resizeBilinearBackprop(e, n[0], r)
                  }, {})
                },
              }
            },
            'ResizeBilinear',
            { alignCorners: r, newHeight: a, newWidth: s },
          )
        return i ? t.as3D(t.shape[1], t.shape[2], t.shape[3]) : t
      },
    }),
    hl = on({
      resizeNearestNeighbor_: function (t, e, r) {
        void 0 === r && (r = !1)
        var n = qe(t, 'images', 'resizeNearestNeighbor')
        A(3 === n.rank || 4 === n.rank, function () {
          return 'Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ' + n.rank + '.'
        }),
          A(2 === e.length, function () {
            return 'Error in resizeNearestNeighbor: new shape must 2D, but got shape ' + e + '.'
          }),
          A('float32' === n.dtype || 'int32' === n.dtype, function () {
            return '`images` must have `int32` or `float32` as dtype'
          })
        var o = n,
          i = !1
        3 === n.rank && ((i = !0), (o = n.as4D(1, n.shape[0], n.shape[1], n.shape[2])))
        var a = e[0],
          s = e[1],
          t = Pt.runKernelFunc(
            function (t, e) {
              return e([o]), t.resizeNearestNeighbor(o, a, s, r)
            },
            { batchImages: o },
            function (e, n) {
              return {
                batchImages: function () {
                  return Pt.runKernelFunc(function (t) {
                    return t.resizeNearestNeighborBackprop(e, n[0], r)
                  }, {})
                },
              }
            },
          )
        return i ? t.as3D(t.shape[1], t.shape[2], t.shape[3]) : t
      },
    }),
    Tn = on({
      nonMaxSuppression_: function (t, e, n, r, o) {
        void 0 === r && (r = 0.5), void 0 === o && (o = Number.NEGATIVE_INFINITY)
        var i = qe(t, 'boxes', 'nonMaxSuppression'),
          a = qe(e, 'scores', 'nonMaxSuppression'),
          e = dl(i, a, n, r, o)
        ;(n = e.maxOutputSize), (r = e.iouThreshold), (o = e.scoreThreshold)
        e = { maxOutputSize: n, iouThreshold: r, scoreThreshold: o }
        return Pt.runKernelFunc(
          function (t) {
            return t.nonMaxSuppression(i, a, n, r, o)
          },
          { boxes: i, scores: a },
          null,
          'NonMaxSuppressionV3',
          e,
        )
      },
    }),
    Dn = on({
      nonMaxSuppressionWithScore_: function (t, e, n, r, o, i) {
        void 0 === r && (r = 0.5), void 0 === o && (o = Number.NEGATIVE_INFINITY), void 0 === i && (i = 0)
        var a = qe(t, 'boxes', 'nonMaxSuppression'),
          t = qe(e, 'scores', 'nonMaxSuppression'),
          e = dl(a, t, n, r, o, i),
          i = {
            maxOutputSize: (n = e.maxOutputSize),
            iouThreshold: (r = e.iouThreshold),
            scoreThreshold: (o = e.scoreThreshold),
            softNmsSigma: (i = e.softNmsSigma),
          },
          i = Pt.runKernel('NonMaxSuppressionV5', { boxes: a, scores: t }, i)
        return { selectedIndices: i[0], selectedScores: i[1] }
      },
    }),
    On = on({
      cropAndResize_: function (t, e, n, r, o, i) {
        var a = qe(t, 'image', 'cropAndResize'),
          s = qe(e, 'boxes', 'cropAndResize', 'float32'),
          u = qe(n, 'boxInd', 'cropAndResize', 'int32')
        ;(o = o || 'bilinear'), (i = i || 0)
        var c = s.shape[0]
        return (
          A(4 === a.rank, function () {
            return 'Error in cropAndResize: image must be rank 4,but got rank ' + a.rank + '.'
          }),
          A(2 === s.rank && 4 === s.shape[1], function () {
            return 'Error in cropAndResize: boxes must be have size [' + c + ',4] but had shape ' + s.shape + '.'
          }),
          A(1 === u.rank && u.shape[0] === c, function () {
            return 'Error in cropAndResize: boxInd must be have size [' + c + '] but had shape ' + s.shape + '.'
          }),
          A(2 === r.length, function () {
            return 'Error in cropAndResize: cropSize must be of length 2, but got length ' + r.length + '.'
          }),
          A(1 <= r[0] && 1 <= r[1], function () {
            return 'cropSize must be atleast [1,1], but was ' + r
          }),
          A('bilinear' === o || 'nearest' === o, function () {
            return 'method must be bilinear or nearest, but was ' + o
          }),
          Pt.runKernelFunc(
            function (t, e) {
              return t.cropAndResize(a, s, u, r, o, i)
            },
            { images: a, boxes: s, boxInd: u },
            null,
            'CropAndResize',
            { method: o, extrapolationValue: i, cropSize: r },
          )
        )
      },
    }),
    yl = Object.freeze({
      resizeBilinear: Mn,
      resizeNearestNeighbor: hl,
      nonMaxSuppression: Tn,
      nonMaxSuppressionAsync: function (i, a, s, u, c) {
        return (
          void 0 === u && (u = 0.5),
          void 0 === c && (c = Number.NEGATIVE_INFINITY),
          x(this, void 0, void 0, function () {
            var e, n, r, o
            return w(this, function (t) {
              switch (t.label) {
                case 0:
                  return (
                    (e = qe(i, 'boxes', 'nonMaxSuppressionAsync')),
                    (n = qe(a, 'scores', 'nonMaxSuppressionAsync')),
                    (r = dl(e, n, s, u, c)),
                    (s = r.maxOutputSize),
                    (u = r.iouThreshold),
                    (c = r.scoreThreshold),
                    [4, Promise.all([e.data(), n.data()])]
                  )
                case 1:
                  return (
                    (o = t.sent()),
                    (r = o[0]),
                    (o = o[1]),
                    (o = uo(r, o, s, u, c)),
                    e !== i && e.dispose(),
                    n !== a && n.dispose(),
                    [2, o]
                  )
              }
            })
          })
        )
      },
      nonMaxSuppressionWithScore: Dn,
      nonMaxSuppressionWithScoreAsync: function (i, a, s, u, c, l) {
        return (
          void 0 === u && (u = 0.5),
          void 0 === c && (c = Number.NEGATIVE_INFINITY),
          void 0 === l && (l = 0),
          x(this, void 0, void 0, function () {
            var e, n, r, o
            return w(this, function (t) {
              switch (t.label) {
                case 0:
                  return (
                    (e = qe(i, 'boxes', 'nonMaxSuppressionAsync')),
                    (n = qe(a, 'scores', 'nonMaxSuppressionAsync')),
                    (r = dl(e, n, s, u, c, l)),
                    (s = r.maxOutputSize),
                    (u = r.iouThreshold),
                    (c = r.scoreThreshold),
                    (l = r.softNmsSigma),
                    [4, Promise.all([e.data(), n.data()])]
                  )
                case 1:
                  return (
                    (o = t.sent()),
                    (r = o[0]),
                    (o = o[1]),
                    (o = co(r, o, s, u, c, l)),
                    e !== i && e.dispose(),
                    n !== a && n.dispose(),
                    [2, o]
                  )
              }
            })
          })
        )
      },
      cropAndResize: On,
    }),
    Tn = on({
      fusedMatMul_: function (t) {
        var e = t.a,
          n = t.b,
          r = t.transposeA,
          i = void 0 !== r && r,
          o = t.transposeB,
          a = void 0 !== o && o,
          s = t.bias,
          r = t.activation,
          u = void 0 === r ? 'linear' : r,
          o = t.preluActivationWeights
        if (!1 === fl(Pt.state.gradientDepth, u)) {
          var c = rc(e, n, i, a)
          return null != s && (c = au(c, s)), gl(c, u, o)
        }
        var l = qe(e, 'a', 'fused matMul'),
          h = qe(n, 'b', 'fused matMul'),
          l = (r = At(l, h))[0],
          h = r[1],
          p = i ? l.shape[l.rank - 2] : l.shape[l.rank - 1],
          d = a ? h.shape[h.rank - 1] : h.shape[h.rank - 2],
          t = i ? l.shape[l.rank - 1] : l.shape[l.rank - 2],
          c = a ? h.shape[h.rank - 2] : h.shape[h.rank - 1],
          f = l.shape.slice(0, -2),
          v = h.shape.slice(0, -2),
          e = D(f),
          n = D(v)
        A(2 <= l.rank && 2 <= h.rank && l.rank === h.rank, function () {
          return (
            'Error in fused matMul: inputs must have the same rank of at least 2, got ranks ' + l.rank + ' and ' + h.rank + '.'
          )
        }),
          A(S(f, v), function () {
            return (
              'Error in fused matMul: outer dimensions (' +
              f +
              ') and (' +
              v +
              ') of Tensors with shapes ' +
              l.shape +
              ' and ' +
              h.shape +
              ' must match.'
            )
          }),
          A(p === d, function () {
            return (
              'Error in fused matMul: inner shapes (' +
              p +
              ') and (' +
              d +
              ') of Tensors with shapes ' +
              l.shape +
              ' and ' +
              h.shape +
              ' and transposeA=' +
              i +
              ' and transposeB=' +
              a +
              ' must match.'
            )
          })
        var m,
          g,
          r = l.shape.slice(0, -2).concat([t, c]),
          y = i ? l.as3D(e, p, t) : l.as3D(e, t, p),
          b = a ? h.as3D(n, c, d) : h.as3D(n, d, c)
        null != s && Vr(r, (m = At((m = qe(s, 'bias', 'fused matMul')), l)[0]).shape),
          null != o && (g = qe(o, 'prelu weights', 'fused matMul'))
        c = { a: y, b: b }
        null != s && (c.bias = m), null != o && (c.preluActivationWeights = g)
        o = [y, b]
        return Pt.runKernelFunc(
          function (t, e) {
            t = t.fusedBatchMatMul({
              a: y,
              b: b,
              transposeA: i,
              transposeB: a,
              bias: m,
              activation: u,
              preluActivationWeights: g,
            })
            return e([y, b, t]), t
          },
          c,
          function (t, e) {
            var n = e[0],
              r = e[1],
              e = e[2],
              o = vl(t, e, u),
              e =
                null != s
                  ? {
                      bias: function () {
                        return ml(m, o)
                      },
                    }
                  : {}
            return i || a
              ? !i && a
                ? Object.assign(
                    {
                      a: function () {
                        return o.matMul(r, !1, !1)
                      },
                      b: function () {
                        return o.matMul(n, !0, !1)
                      },
                    },
                    e,
                  )
                : i && !a
                ? Object.assign(
                    {
                      a: function () {
                        return r.matMul(o, !1, !0)
                      },
                      b: function () {
                        return n.matMul(o, !1, !1)
                      },
                    },
                    e,
                  )
                : Object.assign(
                    {
                      a: function () {
                        return r.matMul(o, !0, !0)
                      },
                      b: function () {
                        return o.matMul(n, !0, !0)
                      },
                    },
                    e,
                  )
              : Object.assign(
                  {
                    a: function () {
                      return o.matMul(r, !1, !0)
                    },
                    b: function () {
                      return n.matMul(o, !0, !1)
                    },
                  },
                  e,
                )
          },
          '_FusedMatMul',
          { transposeA: i, transposeB: a, activation: u },
          o,
          [!0],
        ).reshape(r)
      },
    }),
    Dn = on({
      fusedConv2d_: function (t) {
        var e = t.x,
          n = t.filter,
          i = t.strides,
          a = t.pad,
          r = t.dataFormat,
          o = void 0 === r ? 'NHWC' : r,
          r = t.dilations,
          s = void 0 === r ? [1, 1] : r,
          u = t.dimRoundingMode,
          c = t.bias,
          r = t.activation,
          l = void 0 === r ? 'linear' : r,
          r = t.preluActivationWeights,
          l = l || 'linear'
        if (!1 === fl(Pt.state.gradientDepth, l)) {
          t = Ku(e, n, i, a, o, s, u)
          return null != c && (t = au(t, c)), gl(t, l, r)
        }
        var e = qe(e, 'x', 'conv2d'),
          h = qe(n, 'filter', 'conv2d'),
          p = e,
          n = !1
        3 === e.rank && ((n = !0), (p = e.as4D(1, e.shape[0], e.shape[1], e.shape[2]))),
          A(4 === p.rank, function () {
            return 'Error in fused conv2d: input must be rank 4, but got rank ' + p.rank + '.'
          }),
          A(4 === h.rank, function () {
            return 'Error in fused conv2d: filter must be rank 4, but got rank ' + h.rank + '.'
          }),
          null != u &&
            A(N(a), function () {
              return (
                'Error in fused conv2d: pad must be an integer when using, dimRoundingMode ' + u + ' but got pad ' + a + '.'
              )
            }),
          A(p.shape[3] === h.shape[2], function () {
            return 'Error in conv2d: depth of input (' + p.shape[3] + ') must match input depth for filter ' + h.shape[2] + '.'
          }),
          A(to(i, s), function () {
            return 'Error in conv2D: Either strides or dilations must be 1. Got strides ' + i + " and dilations '" + s + "'"
          }),
          A('NHWC' === o, function () {
            return 'Error in conv2d: got dataFormat of ' + o + ' but only NHWC is currently supported.'
          })
        var d,
          f,
          v = qr(p.shape, h.shape, i, s, a, u)
        null != c && ((d = At((d = qe(c, 'bias', 'fused conv2d')), e)[0]), Vr(v.outShape, d.shape)),
          null != r && (f = qe(r, 'prelu weights', 'fused conv2d'))
        e = { x: p, filter: h }
        null != c && (e.bias = d), null != r && (e.preluActivationWeights = f)
        ;(r = [h, p]),
          (r = Pt.runKernelFunc(
            function (t, e) {
              t = t.fusedConv2d({ input: p, filter: h, convInfo: v, bias: d, activation: l, preluActivationWeights: f })
              return e([h, p, t]), t
            },
            e,
            function (t, e) {
              var n = e[0],
                r = e[1],
                e = e[2],
                o = vl(t, e, l)
              A(Zr(s), function () {
                return (
                  "Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" +
                  s +
                  "'"
                )
              })
              e =
                null != c
                  ? {
                      bias: function () {
                        return ml(d, o)
                      },
                    }
                  : {}
              return Object.assign(
                {
                  x: function () {
                    return Yu(r.shape, o, n, i, a)
                  },
                  filter: function () {
                    return $u(r, o, n.shape, i, a)
                  },
                },
                e,
              )
            },
            'FusedConv2D',
            { convInfo: v, activation: l },
            r,
            [!0],
          ))
        return n ? r.as3D(r.shape[1], r.shape[2], r.shape[3]) : r
      },
    }),
    On = on({
      fusedDepthwiseConv2d_: function (t) {
        var e = t.x,
          n = t.filter,
          r = t.strides,
          o = t.pad,
          i = t.dataFormat,
          a = void 0 === i ? 'NHWC' : i,
          i = t.dilations,
          s = void 0 === i ? [1, 1] : i,
          u = t.dimRoundingMode,
          c = t.bias,
          i = t.activation,
          l = void 0 === i ? 'linear' : i,
          t = t.preluActivationWeights
        if (!1 === fl(Pt.state.gradientDepth, l)) {
          a = Ju(e, n, r, o, a, s, u)
          return null != c && (a = au(a, c)), gl(a, l, t)
        }
        var e = qe(e, 'x', 'depthwiseConv2d'),
          h = qe(n, 'filter', 'depthwiseConv2d'),
          p = e,
          n = !1
        3 === e.rank && ((n = !0), (p = e.as4D(1, e.shape[0], e.shape[1], e.shape[2]))),
          A(4 === p.rank, function () {
            return 'Error in fused depthwiseConv2d: input must be rank 4, but got rank ' + p.rank + '.'
          }),
          A(4 === h.rank, function () {
            return 'Error in fused depthwiseConv2d: filter must be rank 4, but got rank ' + h.rank + '.'
          }),
          A(p.shape[3] === h.shape[2], function () {
            return (
              'Error in fused depthwiseConv2d: number of input channels (' +
              p.shape[3] +
              ') must match the inChannels dimension in filter ' +
              h.shape[2] +
              '.'
            )
          }),
          A(to(r, (s = null == s ? [1, 1] : s)), function () {
            return (
              'Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ' +
              r +
              " and dilations '" +
              s +
              "'"
            )
          }),
          null != u &&
            A(N(o), function () {
              return (
                'Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ' +
                u +
                ' but got pad ' +
                o +
                '.'
              )
            })
        var d,
          f,
          v = qr(p.shape, h.shape, r, s, o, u, !0)
        null != c && ((d = At((d = qe(c, 'bias', 'fused conv2d')), e)[0]), Vr(v.outShape, d.shape)),
          null != t && (f = qe(t, 'prelu weights', 'fused depthwiseConv2d'))
        e = { x: p, filter: h }
        null != c && (e.bias = d), null != t && (e.preluActivationWeights = f)
        ;(t = [h, p]),
          (t = Pt.runKernelFunc(
            function (t, e) {
              t = t.fusedDepthwiseConv2D({
                input: p,
                filter: h,
                convInfo: v,
                bias: d,
                activation: l,
                preluActivationWeights: f,
              })
              return e([h, p, t]), t
            },
            e,
            function (t, e) {
              A(Zr(s), function () {
                return (
                  "Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '" +
                  s +
                  "'"
                )
              })
              var n = e[0],
                r = e[1],
                e = e[2],
                o = vl(t, e, l),
                e =
                  null != c
                    ? {
                        bias: function () {
                          return ml(d, o)
                        },
                      }
                    : {}
              return Object.assign(
                {
                  x: function () {
                    return Qu(r.shape, o, n, v)
                  },
                  filter: function () {
                    return Zu(r, o, n.shape, v)
                  },
                },
                e,
              )
            },
            'FusedDepthwiseConv2D',
            { convInfo: v, activation: l },
            t,
            [!0],
          ))
        return n ? t.as3D(t.shape[1], t.shape[2], t.shape[3]) : t
      },
    }),
    On = Object.freeze({ matMul: Tn, conv2d: Dn, depthwiseConv2d: On }),
    Zc = Object.freeze({
      image: yl,
      linalg: Fn,
      losses: kn,
      spectral: tl,
      fused: On,
      signal: cl,
      square: rs,
      squaredDifference: is,
      conv1d: qu,
      conv2d: Ku,
      conv3d: Xu,
      depthwiseConv2d: Ju,
      separableConv2d: tc,
      conv2dTranspose: ec,
      conv3dTranspose: nc,
      op: on,
      batchNormalization2d: Ks,
      batchNormalization3d: Xs,
      batchNormalization4d: $s,
      batchNormalization: Ys,
      batchNorm: Js,
      batchNorm2d: Qs,
      batchNorm3d: Zs,
      batchNorm4d: tu,
      booleanMaskAsync: function (d, f, v) {
        return x(this, void 0, void 0, function () {
          var e, n, r, o, i, a, s, u, c, l, h, p
          return w(this, function (t) {
            switch (t.label) {
              case 0:
                for (
                  e = qe(d, 'tensor', 'boolMask'),
                    n = qe(f, 'mask', 'boolMask', 'bool'),
                    r = null == v ? 0 : v,
                    o = n.rank,
                    i = e.shape,
                    A(0 < o, function () {
                      return 'mask cannot be scalar'
                    }),
                    y(i.slice(r, r + o), n.shape, "mask's shape must match the first K dimensions of tensor's shape,"),
                    a = 1,
                    s = r;
                  s < r + o;
                  s++
                )
                  a *= i[s]
                return (p = i.slice(0, r).concat([a], i.slice(r + o))), (u = e.reshape(p)), (c = n.reshape([-1])), [4, qs(c)]
              case 1:
                return (
                  (l = t.sent()),
                  (h = l.squeeze([1])),
                  (p = Gu(u, h, r)),
                  d !== e && e.dispose(),
                  f !== n && n.dispose(),
                  h.dispose(),
                  u.dispose(),
                  c.dispose(),
                  l.dispose(),
                  [2, p]
                )
            }
          })
        })
      },
      complex: an,
      real: sn,
      imag: un,
      concat: Cn,
      concat1d: En,
      concat2d: Sn,
      concat3d: _n,
      concat4d: Rn,
      split: In,
      matMul: rc,
      dot: oc,
      outerProduct: ic,
      reverse: ac,
      reverse1d: sc,
      reverse2d: uc,
      reverse3d: cc,
      reverse4d: lc,
      maxPool: dc,
      avgPool: fc,
      pool: vc,
      maxPool3d: mc,
      avgPool3d: gc,
      slice: yc,
      slice1d: bc,
      slice2d: xc,
      slice3d: wc,
      slice4d: Cc,
      abs: as,
      acos: ss,
      acosh: us,
      asin: cs,
      asinh: ls,
      atan: hs,
      atanh: ps,
      ceil: ds,
      clipByValue: fs,
      cos: vs,
      cosh: ms,
      erf: gs,
      exp: ys,
      expm1: bs,
      floor: xs,
      log: ws,
      log1p: Cs,
      logSigmoid: Es,
      neg: Ss,
      reciprocal: _s,
      round: Rs,
      rsqrt: Is,
      sigmoid: As,
      sign: Ns,
      isNaN: ks,
      isInf: Ts,
      isFinite: Ds,
      sin: Os,
      sinh: Fs,
      softplus: Ms,
      sqrt: Ps,
      step: Bs,
      tan: Ls,
      tanh: Ws,
      all: Sc,
      any: _c,
      argMax: Rc,
      argMin: Ic,
      logSumExp: Ac,
      max: Nc,
      mean: kc,
      min: Tc,
      moments: Dc,
      sum: Oc,
      prod: Fc,
      equal: Iu,
      equalStrict: Au,
      greater: Nu,
      greaterEqual: ku,
      greaterEqualStrict: Tu,
      greaterStrict: Du,
      less: Ou,
      lessEqual: Fu,
      lessEqualStrict: Mu,
      lessStrict: Pu,
      notEqual: Bu,
      notEqualStrict: Lu,
      add: au,
      addN: su,
      addStrict: uu,
      atan2: cu,
      div: lu,
      divNoNan: hu,
      divStrict: pu,
      floorDiv: du,
      maximum: fu,
      maximumStrict: vu,
      minimum: mu,
      minimumStrict: gu,
      mod: yu,
      modStrict: bu,
      mul: xu,
      mulStrict: wu,
      pow: Cu,
      powStrict: Eu,
      squaredDifferenceStrict: Su,
      sub: _u,
      subStrict: Ru,
      elu: Mc,
      leakyRelu: Pc,
      prelu: Bc,
      relu: Lc,
      relu6: Wc,
      selu: zc,
      logicalAnd: eu,
      logicalNot: nu,
      logicalOr: ru,
      logicalXor: ou,
      where: iu,
      whereAsync: qs,
      buffer: Vn,
      print: function (t, e) {
        void 0 === e && (e = !1), console.log(t.toString(e))
      },
      batchToSpaceND: Hn,
      broadcastTo: jn,
      cast: qn,
      clone: Kn,
      cumsum: Xn,
      depthToSpace: $n,
      expandDims: Yn,
      eye: Jn,
      multinomial: Qn,
      oneHot: Zn,
      pad: tr,
      pad1d: er,
      pad2d: nr,
      pad3d: rr,
      pad4d: or,
      rand: ir,
      randomNormal: ar,
      randomGamma: sr,
      randomUniform: ur,
      reshape: cr,
      spaceToBatchND: lr,
      squeeze: hr,
      stack: pr,
      tile: dr,
      truncatedNormal: fr,
      unstack: vr,
      setdiff1dAsync: function (h, p) {
        return x(this, void 0, void 0, function () {
          var e, n, r, o, i, a, s, u, c, l
          return w(this, function (t) {
            switch (t.label) {
              case 0:
                return (
                  (e = qe(h, 'x', 'setdiff1d')),
                  (n = qe(p, 'y', 'setdiff1d')),
                  A(e.dtype === n.dtype, function () {
                    return 'x and y should have the same dtype, but got x (' + e.dtype + ') and y (' + n.dtype + ').'
                  }),
                  A(1 === e.rank, function () {
                    return 'x should be 1D tensor, but got x (' + e.shape + ').'
                  }),
                  A(1 === n.rank, function () {
                    return 'y should be 1D tensor, but got y (' + n.shape + ').'
                  }),
                  [4, e.data()]
                )
              case 1:
                return (r = t.sent()), [4, n.data()]
              case 2:
                for (o = t.sent(), i = new Set(o), c = a = 0; c < r.length; c++) i.has(r[c]) || a++
                for (s = new ft([a], e.dtype), u = new ft([a], 'int32'), l = c = 0; c < r.length; c++)
                  i.has(r[c]) || ((s.values[l] = r[c]), (u.values[l] = c), l++)
                return [2, [s.toTensor(), u.toTensor()]]
            }
          })
        })
      },
      fill: yn,
      linspace: function (e, n, r) {
        if (r <= 0) throw new Error('The number of values should be positive.')
        return Pt.runKernelFunc(function (t) {
          return t.linspace(e, n, r)
        }, {})
      },
      ones: mn,
      range: bn,
      scalar: hn,
      tensor: cn,
      tensor1d: pn,
      tensor2d: dn,
      tensor3d: fn,
      tensor4d: vn,
      tensor5d: function (t, e, n) {
        if ((b(t), null != e && 5 !== e.length)) throw new Error('tensor5d() requires shape to have five numbers')
        var r = He(t, n)
        if (5 !== r.length && 1 !== r.length)
          throw new Error('tensor5d() requires values to be number[][][][][] or flat/TypedArray')
        if (1 === r.length && null == e)
          throw new Error('tensor5d() requires shape to be provided when `values` are a flat array')
        return ln(t, e, r, n)
      },
      tensor6d: function (t, e, n) {
        if ((b(t), null != e && 6 !== e.length)) throw new Error('tensor6d() requires shape to have six numbers')
        var r = He(t, n)
        if (6 !== r.length && 1 !== r.length)
          throw new Error('tensor6d() requires values to be number[][][][][][] or flat/TypedArray')
        if (1 === r.length && null == e)
          throw new Error('tensor6d() requires shape to be provided when `values` are a flat array')
        return ln(t, (e = e || r), r, n)
      },
      variable: function (t, e, n, r) {
        return void 0 === e && (e = !0), Pt.makeVariable(t, e, n, r)
      },
      zeros: gn,
      onesLike: xn,
      zerosLike: wn,
      transpose: Gc,
      softmax: Fr,
      logSoftmax: Mr,
      localResponseNormalization: Uc,
      norm: Vc,
      gather: Gu,
      unsortedSegmentSum: Uu,
      basicLSTMCell: Hc,
      multiRNNCell: jc,
      movingAverage: qc,
      stridedSlice: Kc,
      topk: Xc,
      scatterND: $c,
      fft: Yc,
      ifft: Jc,
      rfft: Qc,
      irfft: Zc,
      sparseToDense: el,
      gatherND: nl,
      diag: o,
      dropout: Dt,
      hannWindow: il,
      hammingWindow: al,
      frame: sl,
      stft: ul,
      inTopKAsync: function (v, m, g) {
        return (
          void 0 === g && (g = 1),
          x(this, void 0, void 0, function () {
            var e, n, r, o, i, a, s, u, c, l, h, p, d, f
            return w(this, function (t) {
              switch (t.label) {
                case 0:
                  return (
                    (e = qe(v, 'predictions', 'inTopK')),
                    (n = qe(m, 'targets', 'inTopK')),
                    A(1 < e.rank, function () {
                      return 'inTopK() expects the predictions to be of rank 2 or higher, but got ' + e.rank
                    }),
                    A(e.rank - 1 === n.rank, function () {
                      return (
                        'predictions rank should be 1 larger than targets rank, but got predictions rank ' +
                        e.rank +
                        ' and targets rank ' +
                        n.rank
                      )
                    }),
                    y(
                      e.shape.slice(0, e.shape.length - 1),
                      n.shape,
                      "predictions's shape should be align with the targets' shape, except the last dimension.",
                    ),
                    (r = e.shape[e.shape.length - 1]),
                    A(0 < g && g <= r, function () {
                      return "'k' passed to inTopK() must be > 0 && <= the predictions last dimension (" + r + '), but got ' + g
                    }),
                    [4, e.data()]
                  )
                case 1:
                  return (o = t.sent()), [4, n.data()]
                case 2:
                  for (i = t.sent(), a = [o.length / r, r], u = a[1], c = M('bool', (s = a[0])), l = 0; l < s; l++) {
                    for (h = l * u, p = o.subarray(h, h + u), d = [], f = 0; f < p.length; f++)
                      d.push({ value: p[f], index: f })
                    for (
                      d.sort(function (t, e) {
                        return e.value - t.value
                      }),
                        c[l] = 0,
                        f = 0;
                      f < g;
                      f++
                    )
                      if (d[f].index === i[l]) {
                        c[l] = 1
                        break
                      }
                  }
                  return v !== e && e.dispose(), m !== n && n.dispose(), [2, cn(c, n.shape, 'bool')]
              }
            })
          })
        )
      },
    })
  function bl(t, e) {
    ;(t = !Array.isArray(t) ? [t] : t).forEach(function (t) {
      null != t &&
        A('complex64' !== t.dtype, function () {
          return e + ' does not support complex64 tensors.'
        })
    })
  }
  function xl(t, e, n, r) {
    if ('linear' === n) return t.linear(e)
    if ('relu' === n) return t.relu(e)
    if ('elu' === n) return t.elu(e)
    if ('relu6' === n) return t.relu6(e)
    if ('prelu' === n) return t.prelu(e, r)
    throw new Error('Activation ' + n + ' has not been implemented for the CPU backend.')
  }
  var wl,
    Cl =
      (n(El, (wl = Br)),
      (El.prototype.write = function (t, e, n) {
        this.firstUse &&
          ((this.firstUse = !1),
          f.get('IS_NODE') &&
            Ve(
              "\n============================\nHi there 👋\udc4b. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================",
            ))
        var r = {}
        return this.data.set(r, { values: t, dtype: n }), r
      }),
      (El.prototype.move = function (t, e, n, r) {
        this.data.set(t, { values: e, dtype: r })
      }),
      (El.prototype.numDataIds = function () {
        return this.data.numDataIds()
      }),
      (El.prototype.read = function (e) {
        return x(this, void 0, void 0, function () {
          return w(this, function (t) {
            return [2, this.readSync(e)]
          })
        })
      }),
      (El.prototype.readSync = function (t) {
        var e = this.data.get(t),
          n = e.dtype,
          e = e.complexTensors
        return 'complex64' === n ? io(this.readSync(e.real.dataId), this.readSync(e.imag.dataId)) : this.data.get(t).values
      }),
      (El.prototype.bufferSync = function (t) {
        var e = this.readSync(t.dataId),
          n = e
        if ('string' === t.dtype)
          try {
            n = e.map(function (t) {
              return rt(t)
            })
          } catch (t) {
            throw new Error('Failed to decode encoded string bytes into utf-8')
          }
        return Vn(t.shape, t.dtype, n)
      }),
      (El.prototype.makeOutput = function (t, e, n) {
        t = this.write(t, e, n)
        return Pt.makeTensorFromDataId(t, e, n, this)
      }),
      (El.prototype.disposeData = function (t) {
        var e
        this.data.has(t) &&
          (null != (e = this.data.get(t).complexTensors) && (e.real.dispose(), e.imag.dispose()), this.data.delete(t))
      }),
      (El.prototype.time = function (n) {
        return x(this, void 0, void 0, function () {
          var e
          return w(this, function (t) {
            return (e = tt()), n(), [2, { kernelMs: tt() - e }]
          })
        })
      }),
      (El.prototype.memory = function () {
        return {
          unreliable: !0,
          reasons: [
            'The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less.',
          ],
        }
      }),
      (El.prototype.complex = function (t, e) {
        var n = this.makeOutput(null, t.shape, 'complex64')
        return (this.data.get(n.dataId).complexTensors = { real: Pt.keep(t.clone()), imag: Pt.keep(e.clone()) }), n
      }),
      (El.prototype.real = function (t) {
        return this.data.get(t.dataId).complexTensors.real.clone()
      }),
      (El.prototype.imag = function (t) {
        return this.data.get(t.dataId).complexTensors.imag.clone()
      }),
      (El.prototype.slice = function (t, n, e) {
        if ((bl(t, 'slice'), Tr(t.shape, n, e))) {
          var r = Dr(n, t.strides),
            o = D(e)
          return cn(this.readSync(t.dataId).subarray(r, r + o), e, t.dtype)
        }
        for (var i = Vn(e, t.dtype), a = this.bufferSync(t), s = 0; s < i.size; ++s) {
          var u = i.indexToLoc(s).map(function (t, e) {
            return t + n[e]
          })
          i.values[s] = a.get.apply(a, u)
        }
        return i.toTensor()
      }),
      (El.prototype.stridedSlice = function (t, e, n, r) {
        bl(t, 'stridedSlice')
        n = Ar(e, n, r)
        if (
          n.some(function (t) {
            return 0 === t
          })
        )
          return cn([], n)
        for (var o = Vn(n, t.dtype), i = this.bufferSync(t), a = 0; a < o.size; a++) {
          for (var s = o.indexToLoc(a), u = new Array(s.length), c = 0; c < u.length; c++) u[c] = s[c] * r[c] + e[c]
          o.set.apply(o, [i.get.apply(i, u)].concat(s))
        }
        return o.toTensor()
      }),
      (El.prototype.diag = function (t) {
        for (var e = this.readSync(t.dataId), n = Vn([t.size, t.size], t.dtype), r = n.values, o = 0; o < e.length; o++)
          r[o * t.size + o] = e[o]
        return n.toTensor()
      }),
      (El.prototype.unstack = function (t, e) {
        for (var n = t.shape[e], r = new Array(t.rank - 1), o = 0, i = 0; i < t.rank; i++) i !== e && (r[o++] = t.shape[i])
        var a = new Array(t.rank).fill(0),
          s = t.shape.slice()
        s[e] = 1
        for (var u = new Array(n), i = 0; i < u.length; i++) u[(a[e] = i)] = this.slice(t, a, s).reshape(r)
        return u
      }),
      (El.prototype.reverse = function (n, r) {
        bl(n, 'reverse')
        for (var o = Vn(n.shape, n.dtype), i = this.bufferSync(n), t = 0; t < o.size; t++)
          !(function (t) {
            var t = o.indexToLoc(t),
              e = t.slice()
            r.forEach(function (t) {
              return (e[t] = n.shape[t] - 1 - e[t])
            }),
              o.set.apply(o, [i.get.apply(i, e)].concat(t))
          })(t)
        return o.toTensor()
      }),
      (El.prototype.concat = function (t, n) {
        var a = this
        if ('complex64' === t[0].dtype) {
          var e = t.map(function (t) {
              return sn(t)
            }),
            r = t.map(function (t) {
              return un(t)
            })
          return an(this.concat(e, n), this.concat(r, n))
        }
        var o,
          s,
          r = t.map(function (t) {
            var e = D(t.shape.slice(n))
            return t.as2D(-1, e)
          }),
          u = rn(
            r.map(function (t) {
              return t.shape
            }),
            1,
          ),
          c = Vn(u, t[0].dtype).values
        1 === r[0].shape[0]
          ? ((o = 0),
            r.forEach(function (t) {
              c.set(a.readSync(t.dataId), o), (o += t.size)
            }))
          : ((s = 0),
            r.forEach(function (t) {
              for (var e = a.readSync(t.dataId), n = 0, r = 0; r < t.shape[0]; ++r)
                for (var o = r * u[1] + s, i = 0; i < t.shape[1]; ++i) c[o + i] = e[n++]
              s += t.shape[1]
            }))
        r = rn(
          t.map(function (t) {
            return t.shape
          }),
          n,
        )
        return cn(c, r, t[0].dtype)
      }),
      (El.prototype.neg = function (t) {
        return bl(t, 'neg'), this.multiply(hn(-1), t)
      }),
      (El.prototype.add = function (t, e) {
        return 'complex64' === t.dtype || 'complex64' === e.dtype
          ? this.broadcastedBinaryComplexOp(t.cast('complex64'), e.cast('complex64'), function (t, e, n, r) {
              return { real: t + n, imag: e + r }
            })
          : this.broadcastedBinaryOp(t, e, Rt(t.dtype, e.dtype), function (t, e) {
              return t + e
            })
      }),
      (El.prototype.addN = function (t) {
        var e = this
        bl(t, 'addN')
        for (
          var n = t.map(function (t) {
              return e.readSync(t.dataId)
            }),
            r = Vn(t[0].shape, t[0].dtype),
            o = r.values,
            i = 0;
          i < t.length;
          i++
        )
          for (var a = n[i], s = 0; s < o.length; s++) o[s] += a[s]
        return r.toTensor()
      }),
      (El.prototype.softmax = function (t, e) {
        var n = O([e], t.shape),
          r = this.max(t, n),
          e = Je(r.shape, n),
          r = this.subtract(t, r.reshape(e)),
          r = this.exp(r),
          e = this.sum(r, n).reshape(e)
        return this.realDivide(r, e)
      }),
      (El.prototype.subtract = function (t, e) {
        return 'complex64' === t.dtype || 'complex64' === e.dtype
          ? this.broadcastedBinaryComplexOp(t.cast('complex64'), e.cast('complex64'), function (t, e, n, r) {
              return { real: t - n, imag: e - r }
            })
          : this.broadcastedBinaryOp(t, e, Rt(t.dtype, e.dtype), function (t, e) {
              return t - e
            })
      }),
      (El.prototype.pow = function (t, e) {
        return (
          bl([t, e], 'pow'),
          this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {
            return Math.pow(t, e)
          })
        )
      }),
      (El.prototype.batchMatMul = function (t, e, n, r) {
        bl([t, e], 'matMul')
        for (
          var o = n ? t.shape[1] : t.shape[2],
            i = n ? t.shape[2] : t.shape[1],
            a = r ? e.shape[1] : e.shape[2],
            s = t.shape[0],
            u = this.readSync(t.dataId),
            c = this.readSync(e.dataId),
            n = n ? [t.strides[0], 1, t.strides[1]] : [t.strides[0], t.strides[1], 1],
            l = n[0],
            h = n[1],
            p = n[2],
            e = r ? [1, e.strides[1], e.strides[0]] : [e.strides[1], 1, e.strides[0]],
            d = e[0],
            f = e[1],
            v = e[2],
            m = i * a,
            t = Vn([s, i, a], t.dtype),
            g = t.values,
            y = this.blockSize,
            b = 0;
          b < s;
          b++
        )
          for (var x = 0; x < i; x += y)
            for (var w = 0; w < a; w += y)
              for (var C = 0; C < o; C += y)
                for (var E = Math.min(x + y, i), S = Math.min(w + y, a), _ = Math.min(C + y, o), R = x; R < E; R++)
                  for (var I = w; I < S; I++) {
                    for (var A = 0, N = C; N < _; N++) A += u[b * l + R * h + N * p] * c[N * d + I * f + b * v]
                    g[b * m + (R * a + I)] += A
                  }
        return t.toTensor()
      }),
      (El.prototype.fusedBatchMatMul = function (t) {
        var e = t.a,
          n = t.b,
          r = t.transposeA,
          o = t.transposeB,
          i = t.bias,
          a = t.activation,
          t = t.preluActivationWeights,
          o = this.batchMatMul(e, n, r, o)
        return i && (o = this.add(o, i)), (o = a ? xl(this, o, a, t) : o)
      }),
      (El.prototype.multiply = function (t, e) {
        return 'complex64' === t.dtype || 'complex64' === e.dtype
          ? this.broadcastedBinaryComplexOp(t.cast('complex64'), e.cast('complex64'), function (t, e, n, r) {
              return { real: t * n - e * r, imag: t * r + e * n }
            })
          : this.broadcastedBinaryOp(t, e, Rt(t.dtype, e.dtype), function (t, e) {
              return t * e
            })
      }),
      (El.prototype.realDivide = function (t, e) {
        return (
          bl([t, e], 'realDivide'),
          this.broadcastedBinaryOp(t, e, 'float32', function (t, e) {
            return t / e
          })
        )
      }),
      (El.prototype.floorDiv = function (t, e) {
        return (
          bl([t, e], 'floorDiv'),
          this.broadcastedBinaryOp(t, e, 'int32', function (t, e) {
            return Math.floor(t / e)
          })
        )
      }),
      (El.prototype.sum = function (t, e) {
        bl(t, 'sum'), Qe('sum', e, t.rank)
        for (
          var n = Ye(t.shape, e),
            e = n[0],
            n = n[1],
            e = gn(e, Rt(t.dtype, 'int32')),
            r = D(n),
            o = this.readSync(e.dataId),
            i = this.readSync(t.dataId),
            a = 0;
          a < o.length;
          ++a
        ) {
          for (var s = a * r, u = 0, c = 0; c < r; ++c) u += i[s + c]
          o[a] = u
        }
        return e
      }),
      (El.prototype.prod = function (t, e) {
        bl(t, 'sum')
        for (
          var n = Ye(t.shape, e),
            e = n[0],
            n = n[1],
            e = gn(e, Rt(t.dtype, 'int32')),
            r = D(n),
            o = this.readSync(e.dataId),
            i = this.readSync(t.dataId),
            a = 0;
          a < o.length;
          ++a
        ) {
          for (var s = a * r, u = 1, c = 0; c < r; ++c) u *= i[s + c]
          o[a] = u
        }
        return e
      }),
      (El.prototype.unsortedSegmentSum = function (t, e, n) {
        bl(t, 'unsortedSegmentSum')
        for (var r = [], o = t.rank - e.rank, i = 0; i < o; ++i) e = e.expandDims(i + 1)
        for (i = 0; i < n; ++i) {
          var a = hn(i, 'int32'),
            a = Iu(a, e).asType('float32').mul(t).sum(0)
          r.push(a)
        }
        return pr(r)
      }),
      (El.prototype.argMin = function (t, e) {
        bl(t, 'argMin')
        var n = [e]
        Qe('argMin', n, t.rank)
        for (
          var e = Ye(t.shape, n),
            n = e[0],
            e = e[1],
            n = gn(n, 'int32'),
            r = D(e),
            o = this.readSync(n.dataId),
            i = this.readSync(t.dataId),
            a = 0;
          a < o.length;
          ++a
        ) {
          for (var s = a * r, u = i[s], c = 0, l = 0; l < r; ++l) {
            var h = i[s + l]
            h < u && ((u = h), (c = l))
          }
          o[a] = c
        }
        return n
      }),
      (El.prototype.argMax = function (t, e) {
        bl(t, 'argMax')
        var n = [e]
        Qe('argMax', n, t.rank)
        for (
          var e = Ye(t.shape, n),
            n = e[0],
            e = e[1],
            n = gn(n, 'int32'),
            r = D(e),
            o = this.readSync(n.dataId),
            i = this.readSync(t.dataId),
            a = 0;
          a < o.length;
          ++a
        ) {
          for (var s = a * r, u = i[s], c = 0, l = 0; l < r; ++l) {
            var h = i[s + l]
            u < h && ((u = h), (c = l))
          }
          o[a] = c
        }
        return n
      }),
      (El.prototype.cumsum = function (t, e, n, r) {
        if ((bl(t, 'cumsum'), e !== t.rank - 1))
          throw new Error('backend.cumsum in CPU expects an inner-most axis=' + (t.rank - 1) + ' but got axis=' + e)
        for (
          var e = Rt(t.dtype, 'int32'),
            e = gn(t.shape, e),
            o = this.readSync(e.dataId),
            i = this.readSync(t.dataId),
            a = t.shape[t.rank - 1],
            s = r
              ? function (t, e) {
                  return t + a - e - 1
                }
              : function (t, e) {
                  return t + e
                },
            u = 0;
          u < i.length;
          u += a
        )
          for (var c = 0; c < a; c++) {
            var l,
              h = s(u, c)
            0 === c ? (o[h] = n ? 0 : i[h]) : ((l = s(u, c - 1)), (o[h] = n ? i[l] + o[l] : i[h] + o[l]))
          }
        return e
      }),
      (El.prototype.equal = function (t, e) {
        return (
          bl([t, e], 'equal'),
          this.broadcastedBinaryOp(t, e, 'bool', function (t, e) {
            return t === e ? 1 : 0
          })
        )
      }),
      (El.prototype.notEqual = function (t, e) {
        return (
          bl([t, e], 'notEqual'),
          this.broadcastedBinaryOp(t, e, 'bool', function (t, e) {
            return t !== e ? 1 : 0
          })
        )
      }),
      (El.prototype.less = function (t, e) {
        return (
          bl([t, e], 'less'),
          this.broadcastedBinaryOp(t, e, 'bool', function (t, e) {
            return t < e ? 1 : 0
          })
        )
      }),
      (El.prototype.lessEqual = function (t, e) {
        return (
          bl([t, e], 'lessEqual'),
          this.broadcastedBinaryOp(t, e, 'bool', function (t, e) {
            return t <= e ? 1 : 0
          })
        )
      }),
      (El.prototype.greater = function (t, e) {
        return (
          bl([t, e], 'greater'),
          this.broadcastedBinaryOp(t, e, 'bool', function (t, e) {
            return e < t ? 1 : 0
          })
        )
      }),
      (El.prototype.greaterEqual = function (t, e) {
        return (
          bl([t, e], 'greaterEqual'),
          this.broadcastedBinaryOp(t, e, 'bool', function (t, e) {
            return e <= t ? 1 : 0
          })
        )
      }),
      (El.prototype.logicalNot = function (t) {
        bl(t, 'logicalNot')
        for (var e = this.readSync(t.dataId), n = new Uint8Array(e.length), r = 0; r < e.length; ++r) n[r] = e[r] ? 0 : 1
        return this.makeOutput(n, t.shape, 'bool')
      }),
      (El.prototype.logicalAnd = function (t, e) {
        return (
          bl([t, e], 'logicalAnd'),
          this.broadcastedBinaryOp(t, e, 'bool', function (t, e) {
            return t && e
          })
        )
      }),
      (El.prototype.logicalOr = function (t, e) {
        return (
          bl([t, e], 'logicalOr'),
          this.broadcastedBinaryOp(t, e, 'bool', function (t, e) {
            return t || e
          })
        )
      }),
      (El.prototype.select = function (t, e, n) {
        bl([t, e, n], 'select')
        for (
          var r = this.readSync(t.dataId),
            o = this.readSync(e.dataId),
            i = this.readSync(n.dataId),
            n = gn(e.shape, Rt(e.dtype, n.dtype)),
            a = this.readSync(n.dataId),
            s = 0,
            u = 0 === t.rank || 1 < t.rank || 1 === e.rank ? 1 : D(e.shape.slice(1)),
            c = 0;
          c < r.length;
          c++
        )
          for (var l = 0; l < u; l++) 1 === r[c] ? (a[s++] = o[c]) : (a[s++] = i[c])
        return n
      }),
      (El.prototype.where = function (t) {
        bl([t], 'where')
        var e = this.readSync(t.dataId)
        return mo(t.shape, e)
      }),
      (El.prototype.topk = function (t, e, n) {
        return bl(t, 'topk'), vo(this.readSync(t.dataId), t.shape, t.dtype, e)
      }),
      (El.prototype.min = function (t, e) {
        bl(t, 'min'), Qe('min', e, t.rank)
        for (
          var n = Ye(t.shape, e),
            e = n[0],
            n = n[1],
            e = gn(e, t.dtype),
            r = D(n),
            o = this.readSync(e.dataId),
            i = this.readSync(t.dataId),
            a = 0;
          a < o.length;
          ++a
        ) {
          for (var s = a * r, u = i[s], c = 0; c < r; ++c) {
            var l = i[s + c]
            l < u && (u = l)
          }
          o[a] = u
        }
        return e
      }),
      (El.prototype.minimum = function (t, e) {
        return (
          bl([t, e], 'minimum'),
          this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {
            return Math.min(t, e)
          })
        )
      }),
      (El.prototype.mod = function (t, e) {
        return (
          bl([t, e], 'mod'),
          this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {
            var n = t % e
            return (t < 0 && e < 0) || (0 <= t && 0 <= e) ? n : (n + e) % e
          })
        )
      }),
      (El.prototype.max = function (t, e) {
        bl(t, 'max'), Qe('max', e, t.rank)
        for (
          var n = Ye(t.shape, e),
            e = n[0],
            n = n[1],
            e = gn(e, t.dtype),
            r = D(n),
            o = this.readSync(e.dataId),
            i = this.readSync(t.dataId),
            a = 0;
          a < o.length;
          ++a
        ) {
          for (var s = a * r, u = i[s], c = 0; c < r; ++c) {
            var l = i[s + c]
            u < l && (u = l)
          }
          o[a] = u
        }
        return e
      }),
      (El.prototype.maximum = function (t, e) {
        return (
          bl([t, e], 'maximum'),
          this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {
            return Math.max(t, e)
          })
        )
      }),
      (El.prototype.all = function (t, e) {
        bl(t, 'all'), Qe('all', e, t.rank)
        for (
          var n = Ye(t.shape, e),
            e = n[0],
            n = n[1],
            e = gn(e, t.dtype),
            r = D(n),
            o = this.readSync(e.dataId),
            i = this.readSync(t.dataId),
            a = 0;
          a < o.length;
          ++a
        ) {
          for (var s = a * r, u = i[s], c = 0; c < r; ++c) var l = i[s + c], u = u && l
          o[a] = u
        }
        return e
      }),
      (El.prototype.any = function (t, e) {
        bl(t, 'any'), Qe('any', e, t.rank)
        for (
          var n = Ye(t.shape, e),
            e = n[0],
            n = n[1],
            e = gn(e, t.dtype),
            r = D(n),
            o = this.readSync(e.dataId),
            i = this.readSync(t.dataId),
            a = 0;
          a < o.length;
          ++a
        ) {
          for (var s = a * r, u = i[s], c = 0; c < r; ++c) var l = i[s + c], u = u || l
          o[a] = u
        }
        return e
      }),
      (El.prototype.squaredDifference = function (t, e) {
        return (
          bl([t, e], 'squaredDifference'),
          this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {
            e = t - e
            return e * e
          })
        )
      }),
      (El.prototype.ceil = function (t) {
        bl(t, 'ceil')
        for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) n[r] = Math.ceil(e[r])
        return this.makeOutput(n, t.shape, 'float32')
      }),
      (El.prototype.floor = function (t) {
        bl(t, 'floor')
        for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) n[r] = Math.floor(e[r])
        return this.makeOutput(n, t.shape, 'float32')
      }),
      (El.prototype.sign = function (t) {
        bl(t, 'x')
        for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r)
          e[r] < 0 ? (n[r] = -1) : 0 < e[r] ? (n[r] = 1) : (n[r] = 0)
        return this.makeOutput(n, t.shape, 'float32')
      }),
      (El.prototype.isNaN = function (t) {
        bl(t, 'x')
        for (var e = this.readSync(t.dataId), n = new Uint8Array(e.length), r = 0; r < e.length; ++r)
          Number.isNaN(e[r]) && (n[r] = 1)
        return this.makeOutput(n, t.shape, 'bool')
      }),
      (El.prototype.isInf = function (t) {
        bl(t, 'x')
        for (var e = this.readSync(t.dataId), n = new Uint8Array(e.length), r = 0; r < e.length; ++r)
          Math.abs(e[r]) === 1 / 0 && (n[r] = 1)
        return this.makeOutput(n, t.shape, 'bool')
      }),
      (El.prototype.isFinite = function (t) {
        bl(t, 'x')
        for (var e = this.readSync(t.dataId), n = new Uint8Array(e.length), r = 0; r < e.length; ++r)
          Number.isFinite(e[r]) && (n[r] = 1)
        return this.makeOutput(n, t.shape, 'bool')
      }),
      (El.prototype.round = function (t) {
        bl(t, 'round')
        for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) {
          var o = Math.floor(e[r])
          e[r] - o < 0.5
            ? (n[r] = Math.floor(e[r]))
            : 0.5 < e[r] - o
            ? (n[r] = Math.ceil(e[r]))
            : (n[r] = o % 2 == 0 ? o : o + 1)
        }
        return this.makeOutput(n, t.shape, 'float32')
      }),
      (El.prototype.exp = function (t) {
        bl(t, 'exp')
        for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) n[r] = Math.exp(e[r])
        return this.makeOutput(n, t.shape, 'float32')
      }),
      (El.prototype.expm1 = function (t) {
        bl(t, 'expm1')
        for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) n[r] = Math.expm1(e[r])
        return this.makeOutput(n, t.shape, 'float32')
      }),
      (El.prototype.log = function (t) {
        bl(t, 'log')
        for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) {
          var o = e[r]
          n[r] = Math.log(o)
        }
        return this.makeOutput(n, t.shape, 'float32')
      }),
      (El.prototype.log1p = function (t) {
        bl(t, 'log1p')
        for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) {
          var o = e[r]
          n[r] = Math.log1p(o)
        }
        return this.makeOutput(n, t.shape, 'float32')
      }),
      (El.prototype.sqrt = function (t) {
        bl(t, 'sqrt')
        for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) {
          var o = e[r]
          n[r] = Math.sqrt(o)
        }
        return this.makeOutput(n, t.shape, 'float32')
      }),
      (El.prototype.rsqrt = function (t) {
        bl(t, 'rsqrt')
        for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) {
          var o = e[r]
          n[r] = 1 / Math.sqrt(o)
        }
        return this.makeOutput(n, t.shape, 'float32')
      }),
      (El.prototype.reciprocal = function (t) {
        bl(t, 'reciprocal')
        for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) n[r] = 1 / e[r]
        return this.makeOutput(n, t.shape, 'float32')
      }),
      (El.prototype.linear = function (t) {
        return t
      }),
      (El.prototype.relu = function (t) {
        bl(t, 'relu')
        for (var e = gn(t.shape, t.dtype), n = this.readSync(e.dataId), r = this.readSync(t.dataId), o = 0; o < r.length; ++o)
          n[o] = Math.max(0, r[o])
        return e
      }),
      (El.prototype.relu6 = function (t) {
        bl(t, 'relu')
        for (var e = gn(t.shape, t.dtype), n = this.readSync(e.dataId), r = this.readSync(t.dataId), o = 0; o < r.length; ++o)
          n[o] = Math.min(Math.max(0, r[o]), 6)
        return e
      }),
      (El.prototype.prelu = function (t, e) {
        return (
          bl([t, e], 'prelu'),
          this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {
            return t < 0 ? e * t : t
          })
        )
      }),
      (El.prototype.elu = function (t) {
        bl(t, 'elu')
        for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) {
          var o = n[r]
          e[r] = 0 <= o ? o : Math.exp(o) - 1
        }
        return this.makeOutput(e, t.shape, 'float32')
      }),
      (El.prototype.eluDer = function (t, e) {
        bl([t, e], 'eluDer')
        for (
          var n = new Float32Array(e.size), r = this.readSync(e.dataId), o = this.readSync(t.dataId), i = 0;
          i < r.length;
          ++i
        ) {
          var a = r[i]
          n[i] = 1 <= a ? o[i] : o[i] * (a + 1)
        }
        return this.makeOutput(n, e.shape, 'float32')
      }),
      (El.prototype.selu = function (t) {
        bl(t, 'selu')
        for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) {
          var o = n[r]
          e[r] = 0 <= o ? 1.0507009873554805 * o : 1.7580993408473768 * (Math.exp(o) - 1)
        }
        return this.makeOutput(e, t.shape, 'float32')
      }),
      (El.prototype.clip = function (t, e, n) {
        bl(t, 'clip')
        for (var r = new Float32Array(t.size), o = this.readSync(t.dataId), i = 0; i < o.length; ++i) {
          var a = o[i]
          r[i] = n < a ? n : a < e ? e : a
        }
        return this.makeOutput(r, t.shape, 'float32')
      }),
      (El.prototype.abs = function (t) {
        for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.abs(n[r])
        return this.makeOutput(e, t.shape, 'float32')
      }),
      (El.prototype.complexAbs = function (t) {
        for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < t.size; ++r) {
          var o = n[2 * r],
            i = n[2 * r + 1]
          e[r] = Math.hypot(o, i)
        }
        return this.makeOutput(e, t.shape, 'float32')
      }),
      (El.prototype.int = function (t) {
        bl(t, 'int')
        for (var e = new Int32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = n[r]
        return this.makeOutput(e, t.shape, 'int32')
      }),
      (El.prototype.sigmoid = function (t) {
        bl(t, 'sigmoid')
        for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r)
          e[r] = 1 / (1 + Math.exp(-n[r]))
        return this.makeOutput(e, t.shape, 'float32')
      }),
      (El.prototype.softplus = function (t) {
        bl(t, 'softplus')
        for (
          var e = Math.log(1.1920928955078125e-7) + 2, n = new Float32Array(t.size), r = this.readSync(t.dataId), o = 0;
          o < r.length;
          ++o
        ) {
          var i = r[o] > -e,
            a = r[o] < e,
            s = Math.exp(r[o]),
            u = a ? s : i ? r[o] : Math.log(1 + s)
          n[o] = u
        }
        return this.makeOutput(n, t.shape, 'float32')
      }),
      (El.prototype.sin = function (t) {
        bl(t, 'sin')
        for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.sin(n[r])
        return this.makeOutput(e, t.shape, 'float32')
      }),
      (El.prototype.cos = function (t) {
        bl(t, 'cos')
        for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.cos(n[r])
        return this.makeOutput(e, t.shape, 'float32')
      }),
      (El.prototype.tan = function (t) {
        bl(t, 'tan')
        for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.tan(n[r])
        return this.makeOutput(e, t.shape, 'float32')
      }),
      (El.prototype.asin = function (t) {
        bl(t, 'asin')
        for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.asin(n[r])
        return this.makeOutput(e, t.shape, 'float32')
      }),
      (El.prototype.acos = function (t) {
        bl(t, 'acos')
        for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.acos(n[r])
        return this.makeOutput(e, t.shape, 'float32')
      }),
      (El.prototype.atan = function (t) {
        bl(t, 'atan')
        for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.atan(n[r])
        return this.makeOutput(e, t.shape, 'float32')
      }),
      (El.prototype.atan2 = function (t, e) {
        return (
          bl([t, e], 'atan2'),
          this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {
            return Math.atan2(t, e)
          })
        )
      }),
      (El.prototype.sinh = function (t) {
        bl(t, 'sinh')
        for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.sinh(n[r])
        return this.makeOutput(e, t.shape, 'float32')
      }),
      (El.prototype.cosh = function (t) {
        bl(t, 'cosh')
        for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.cosh(n[r])
        return this.makeOutput(e, t.shape, 'float32')
      }),
      (El.prototype.tanh = function (t) {
        bl(t, 'tanh')
        for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = _(n[r])
        return this.makeOutput(e, t.shape, 'float32')
      }),
      (El.prototype.asinh = function (t) {
        bl(t, 'asinh')
        for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.asinh(n[r])
        return this.makeOutput(e, t.shape, 'float32')
      }),
      (El.prototype.acosh = function (t) {
        bl(t, 'acosh')
        for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.acosh(n[r])
        return this.makeOutput(e, t.shape, 'float32')
      }),
      (El.prototype.atanh = function (t) {
        bl(t, 'atanh')
        for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.atanh(n[r])
        return this.makeOutput(e, t.shape, 'float32')
      }),
      (El.prototype.erf = function (t) {
        bl(t, 'erf')
        for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) {
          var o = Math.sign(n[r]),
            i = Math.abs(n[r]),
            a = 1 / (1 + 0.3275911 * i)
          e[r] =
            o *
            (1 -
              ((((1.061405429 * a - 1.453152027) * a + 1.421413741) * a - 0.284496736) * a + 0.254829592) *
                a *
                Math.exp(-i * i))
        }
        return this.makeOutput(e, t.shape, 'float32')
      }),
      (El.prototype.step = function (t, e) {
        void 0 === e && (e = 0), bl(t, 'step')
        for (var n = new Float32Array(t.size), r = this.readSync(t.dataId), o = 0; o < r.length; ++o) {
          var i = r[o]
          isNaN(i) ? (n[o] = NaN) : (n[o] = 0 < i ? 1 : e)
        }
        return this.makeOutput(n, t.shape, 'float32')
      }),
      (El.prototype.fusedConv2d = function (t) {
        var e = t.input,
          n = t.filter,
          r = t.convInfo,
          o = t.bias,
          i = t.activation,
          t = t.preluActivationWeights,
          r = this.conv2d(e, n, r)
        return o && (r = this.add(r, o)), (r = i ? xl(this, r, i, t) : r)
      }),
      (El.prototype.conv2d = function (t, e, n) {
        bl([t, e], 'conv2d')
        for (
          var r = n.filterHeight,
            o = n.filterWidth,
            i = n.dilationHeight,
            a = n.dilationWidth,
            s = n.padInfo.left,
            u = n.padInfo.top,
            c = 'channelsLast' === n.dataFormat,
            l = Vn(n.outShape, t.dtype),
            h = t.strides[0],
            p = c ? t.strides[1] : t.strides[2],
            d = c ? t.strides[2] : 1,
            f = c ? 1 : t.strides[1],
            v = l.strides[0],
            m = c ? l.strides[1] : l.strides[2],
            g = c ? l.strides[2] : 1,
            y = c ? 1 : l.strides[1],
            b = this.readSync(t.dataId),
            x = this.readSync(e.dataId),
            w = l.values,
            C = 0;
          C < n.batchSize;
          ++C
        )
          for (var E = C * h, S = C * v, _ = 0; _ < n.outHeight; ++_)
            for (var R = S + _ * m, I = _ * n.strideHeight - u, A = 0; A < r; A++) {
              var N = I + A * i
              if (!(N < 0 || N >= n.inHeight))
                for (var k = A * e.strides[0], T = E + N * p, D = 0; D < n.outWidth; ++D)
                  for (var O = R + D * g, F = D * n.strideWidth - s, M = 0; M < o; M++) {
                    var P = F + M * a
                    if (!(P < 0 || P >= n.inWidth))
                      for (var B = T + P * d, L = k + M * e.strides[1], W = 0; W < n.inChannels; ++W) {
                        for (var z = b[B + W * f], G = 0; G < n.outChannels; ++G) w[O + G * y] += z * x[L + G]
                        L += n.outChannels
                      }
                  }
            }
        return l.toTensor()
      }),
      (El.prototype.conv3d = function (t, e, n) {
        for (
          var r = n.filterDepth,
            o = n.filterHeight,
            i = n.filterWidth,
            a = n.dilationDepth,
            s = n.dilationHeight,
            u = n.dilationWidth,
            c = n.padInfo.front,
            l = n.padInfo.left,
            h = n.padInfo.top,
            p = Vn(n.outShape, t.dtype),
            d = this.readSync(t.dataId),
            f = this.readSync(e.dataId),
            v = p.values,
            m = 0;
          m < n.batchSize;
          ++m
        )
          for (var g = m * t.strides[0], y = m * p.strides[0], b = 0; b < n.outDepth; ++b)
            for (var x = y + b * p.strides[1], w = b * n.strideDepth - c, C = 0; C < r; C++) {
              var E = w + C * a
              if (!(E < 0 || E >= n.inDepth))
                for (var S = C * e.strides[0], _ = g + E * t.strides[1], R = 0; R < n.outHeight; ++R)
                  for (var I = x + R * p.strides[2], A = R * n.strideHeight - h, N = 0; N < o; N++) {
                    var k = A + N * s
                    if (!(k < 0 || k >= n.inHeight))
                      for (var T = S + N * e.strides[1], D = _ + k * t.strides[2], O = 0; O < n.outWidth; ++O)
                        for (var F = I + O * n.outChannels, M = O * n.strideWidth - l, P = 0; P < i; P++) {
                          var B = M + P * u
                          if (!(B < 0 || B >= n.inWidth))
                            for (var L = T + P * e.strides[2], W = D + B * n.inChannels, z = L, G = 0; G < n.inChannels; ++G) {
                              for (var U = d[W + G], V = 0; V < n.outChannels; ++V) v[F + V] += U * f[z + V]
                              z += n.outChannels
                            }
                        }
                  }
            }
        return p.toTensor()
      }),
      (El.prototype.conv2dDerInput = function (t, e, n) {
        bl([t, e], 'conv2dDerInput')
        for (
          var r = Vn(n.inShape, 'float32'),
            o = r.values,
            i = this.readSync(t.dataId),
            a = this.readSync(e.dataId),
            e = e.strides,
            s = e[0],
            u = e[1],
            c = e[2],
            l = n.batchSize,
            h = n.filterHeight,
            p = n.filterWidth,
            d = n.inChannels,
            f = n.inHeight,
            v = n.inWidth,
            m = n.outChannels,
            g = n.outHeight,
            y = n.outWidth,
            b = n.strideHeight,
            x = n.strideWidth,
            e = n.dataFormat,
            w = h - 1 - n.padInfo.top,
            C = p - 1 - n.padInfo.left,
            e = 'channelsLast' === e,
            E = r.strides[0],
            S = e ? r.strides[1] : r.strides[2],
            _ = e ? r.strides[2] : 1,
            R = e ? 1 : r.strides[1],
            I = t.strides[0],
            A = e ? t.strides[1] : t.strides[2],
            N = e ? t.strides[2] : 1,
            k = e ? 1 : t.strides[1],
            T = 0;
          T < l;
          ++T
        )
          for (var D = 0; D < d; ++D)
            for (var O = 0; O < f; ++O)
              for (var F = O - w, M = Math.max(0, Math.ceil(F / b)), P = Math.min(g, (h + F) / b), B = 0; B < v; ++B) {
                for (var L = B - C, W = Math.max(0, Math.ceil(L / x)), z = Math.min(y, (p + L) / x), G = 0, U = M; U < P; ++U)
                  for (var V = U * b - F, H = W; H < z; ++H)
                    for (
                      var j = I * T + A * U + N * H, q = s * (h - 1 - V) + u * (p - 1 - (H * x - L)) + c * D, K = 0;
                      K < m;
                      ++K
                    )
                      G += i[j + k * K] * a[q + K]
                o[E * T + S * O + _ * B + R * D] = G
              }
        return r.toTensor()
      }),
      (El.prototype.conv3dDerInput = function (t, e, n) {
        for (
          var r = Vn(n.inShape, 'float32'),
            o = r.values,
            i = r.strides,
            a = i[0],
            s = i[1],
            u = i[2],
            c = i[3],
            l = this.readSync(t.dataId),
            t = t.strides,
            h = t[0],
            p = t[1],
            d = t[2],
            f = t[3],
            v = this.readSync(e.dataId),
            e = e.strides,
            m = e[0],
            g = e[1],
            y = e[2],
            b = e[3],
            x = n.batchSize,
            w = n.filterDepth,
            C = n.filterHeight,
            E = n.filterWidth,
            S = n.inChannels,
            _ = n.inDepth,
            R = n.inHeight,
            I = n.inWidth,
            A = n.outChannels,
            N = n.outDepth,
            k = n.outHeight,
            T = n.outWidth,
            D = n.strideDepth,
            O = n.strideHeight,
            F = n.strideWidth,
            M = w - 1 - n.padInfo.front,
            P = C - 1 - n.padInfo.top,
            B = E - 1 - n.padInfo.left,
            L = 0;
          L < x;
          ++L
        )
          for (var W = 0; W < S; ++W)
            for (var z = 0; z < _; ++z)
              for (var G = z - M, U = Math.max(0, Math.ceil(G / D)), V = Math.min(N, (w + G) / D), H = 0; H < R; ++H)
                for (var j = H - P, q = Math.max(0, Math.ceil(j / O)), K = Math.min(k, (C + j) / O), X = 0; X < I; ++X) {
                  for (var $ = X - B, Y = Math.max(0, Math.ceil($ / F)), J = Math.min(T, (E + $) / F), Q = 0, Z = U; Z < V; ++Z)
                    for (var tt = Z * D - G, et = q; et < K; ++et)
                      for (var nt = et * O - j, rt = Y; rt < J; ++rt)
                        for (
                          var ot = h * L + p * Z + d * et + f * rt,
                            it = m * (w - 1 - tt) + g * (C - 1 - nt) + y * (E - 1 - (rt * F - $)) + b * W,
                            at = 0;
                          at < A;
                          ++at
                        )
                          Q += l[ot + at] * v[it + at]
                  o[a * L + s * z + u * H + c * X + W] = Q
                }
        return r.toTensor()
      }),
      (El.prototype.conv2dDerFilter = function (t, e, n) {
        bl([t, e], 'conv2dDerFilter')
        for (
          var r = n.strideHeight,
            o = n.strideWidth,
            i = n.filterHeight,
            a = n.filterWidth,
            s = 'channelsLast' === n.dataFormat,
            u = Vn(n.filterShape, 'float32'),
            c = n.padInfo.left,
            l = n.padInfo.top,
            h = this.bufferSync(t),
            p = this.bufferSync(e),
            d = 0;
          d < i;
          ++d
        )
          for (
            var f = Math.max(0, Math.ceil((l - d) / r)), v = Math.min(n.outHeight, (n.inHeight + l - d) / r), m = 0;
            m < a;
            ++m
          )
            for (
              var g = Math.max(0, Math.ceil((c - m) / o)), y = Math.min(n.outWidth, (n.inWidth + c - m) / o), b = 0;
              b < n.inChannels;
              ++b
            )
              for (var x = 0; x < n.outChannels; ++x) {
                for (var w = 0, C = 0; C < n.batchSize; ++C)
                  for (var E = f; E < v; ++E)
                    for (var S = d + E * r - l, _ = g; _ < y; ++_) {
                      var R = m + _ * o - c
                      w += s ? h.get(C, S, R, b) * p.get(C, E, _, x) : h.get(C, b, S, R) * p.get(C, x, E, _)
                    }
                u.set(w, d, m, b, x)
              }
        return u.toTensor()
      }),
      (El.prototype.conv3dDerFilter = function (t, e, n) {
        for (
          var r = n.strideDepth,
            o = n.strideHeight,
            i = n.strideWidth,
            a = n.filterDepth,
            s = n.filterHeight,
            u = n.filterWidth,
            c = Vn(n.filterShape, 'float32'),
            l = c.values,
            h = c.strides,
            p = h[0],
            d = h[1],
            f = h[2],
            v = h[3],
            m = this.readSync(e.dataId),
            e = e.strides,
            g = e[0],
            y = e[1],
            b = e[2],
            x = e[3],
            w = this.readSync(t.dataId),
            t = t.strides,
            C = t[0],
            E = t[1],
            S = t[2],
            _ = t[3],
            R = n.padInfo.front,
            I = n.padInfo.left,
            A = n.padInfo.top,
            N = 0;
          N < a;
          ++N
        )
          for (
            var k = Math.max(0, Math.ceil((R - N) / r)), T = Math.min(n.outDepth, (n.inDepth + R - N) / r), D = N * p, O = 0;
            O < s;
            ++O
          )
            for (
              var F = Math.max(0, Math.ceil((A - O) / o)),
                M = Math.min(n.outHeight, (n.inHeight + A - O) / o),
                P = O * d + D,
                B = 0;
              B < u;
              ++B
            )
              for (
                var L = Math.max(0, Math.ceil((I - B) / i)),
                  W = Math.min(n.outWidth, (n.inWidth + I - B) / i),
                  z = B * f + P,
                  G = 0;
                G < n.inChannels;
                ++G
              )
                for (var U = G * v + z, V = 0; V < n.outChannels; ++V) {
                  for (var H = 0, j = 0; j < n.batchSize; ++j)
                    for (var q = j * C, K = j * g, X = k; X < T; ++X)
                      for (var $ = (N + X * r - R) * E + q, Y = X * y + K, J = F; J < M; ++J)
                        for (var Q = (O + J * o - A) * S + $, Z = J * b + Y, tt = L; tt < W; ++tt) {
                          var et = tt * x + Z
                          H += w[(B + tt * i - I) * _ + Q + G] * m[et + V]
                        }
                  l[U + V] = H
                }
        return c.toTensor()
      }),
      (El.prototype.fusedDepthwiseConv2D = function (t) {
        var e = t.input,
          n = t.filter,
          r = t.convInfo,
          o = t.bias,
          i = t.activation,
          t = t.preluActivationWeights,
          r = this.depthwiseConv2D(e, n, r)
        return o && (r = this.add(r, o)), (r = i ? xl(this, r, i, t) : r)
      }),
      (El.prototype.depthwiseConv2D = function (t, e, n) {
        bl([t, e], 'depthwiseConv2D')
        for (
          var r = n.filterHeight,
            o = n.filterWidth,
            i = n.dilationHeight,
            a = n.dilationWidth,
            s = n.padInfo.left,
            u = n.padInfo.top,
            c = n.outChannels / n.inChannels,
            l = Vn(n.outShape, t.dtype),
            h = this.readSync(t.dataId),
            p = this.readSync(e.dataId),
            d = l.values,
            f = 0;
          f < n.batchSize;
          ++f
        )
          for (var v = f * t.strides[0], m = f * l.strides[0], g = 0; g < n.outHeight; ++g)
            for (var y = m + g * l.strides[1], b = g * n.strideHeight - s, x = 0; x < r; ++x) {
              var w = b + x * i
              if (!(w < 0 || w >= n.inHeight))
                for (var C = x * e.strides[0], E = v + w * t.strides[1], S = 0; S < n.outWidth; ++S)
                  for (var _ = y + S * l.strides[2], R = S * n.strideWidth - u, I = 0; I < o; ++I) {
                    var A = R + I * a
                    if (!(A < 0 || A >= n.inWidth))
                      for (var N = C + I * e.strides[1], k = E + A * n.inChannels, T = _, D = N, O = 0; O < n.inChannels; ++O) {
                        for (var F = h[k + O], M = 0; M < c; ++M) d[T + M] += F * p[D + M]
                        ;(T += c), (D += c)
                      }
                  }
            }
        return l.toTensor()
      }),
      (El.prototype.depthwiseConv2DDerInput = function (t, e, n) {
        bl([t, e], 'depthwiseConv2DDerInput')
        for (
          var r = Vn(n.inShape, 'float32'),
            o = r.values,
            i = r.strides,
            a = i[0],
            s = i[1],
            u = i[2],
            c = this.readSync(t.dataId),
            t = t.strides,
            l = t[0],
            h = t[1],
            p = t[2],
            d = this.readSync(e.dataId),
            e = e.strides,
            f = e[0],
            v = e[1],
            m = e[2],
            g = n.batchSize,
            y = n.filterHeight,
            b = n.filterWidth,
            x = n.inChannels,
            w = n.inHeight,
            C = n.inWidth,
            e = n.outChannels,
            E = n.outHeight,
            S = n.outWidth,
            _ = n.strideHeight,
            R = n.strideWidth,
            I = y - 1 - n.padInfo.top,
            A = b - 1 - n.padInfo.left,
            N = e / x,
            k = 0;
          k < g;
          ++k
        )
          for (var T = 0; T < x; ++T)
            for (var D = 0; D < w; ++D)
              for (var O = D - I, F = Math.max(0, Math.ceil(O / _)), M = Math.min(E, (y + O) / _), P = 0; P < C; ++P) {
                for (var B = P - A, L = Math.max(0, Math.ceil(B / R)), W = Math.min(S, (b + B) / R), z = 0, G = F; G < M; ++G)
                  for (var U = G * _ - O, V = L; V < W; ++V)
                    for (
                      var H = l * k + h * G + p * V, j = f * (y - 1 - U) + v * (b - 1 - (V * R - B)) + m * T, q = 0;
                      q < N;
                      ++q
                    )
                      z += c[H + (T * N + q)] * d[j + q]
                o[a * k + s * D + u * P + T] = z
              }
        return r.toTensor()
      }),
      (El.prototype.depthwiseConv2DDerFilter = function (t, e, n) {
        bl([t, e], 'depthwiseConv2DDerFilter')
        for (
          var r = n.strideHeight,
            o = n.strideWidth,
            i = n.filterHeight,
            a = n.filterWidth,
            s = Vn(n.filterShape, 'float32'),
            u = n.padInfo.left,
            c = n.padInfo.top,
            l = n.outChannels / n.inChannels,
            h = this.bufferSync(t),
            p = this.bufferSync(e),
            d = 0;
          d < i;
          ++d
        )
          for (
            var f = Math.max(0, Math.ceil((c - d) / r)), v = Math.min(n.outHeight, (n.inHeight + c - d) / r), m = 0;
            m < a;
            ++m
          )
            for (
              var g = Math.max(0, Math.ceil((u - m) / o)), y = Math.min(n.outWidth, (n.inWidth + u - m) / o), b = 0;
              b < n.outChannels;
              ++b
            ) {
              for (var x = Math.trunc(b / l), w = b % l, C = 0, E = 0; E < n.batchSize; ++E)
                for (var S = f; S < v; ++S)
                  for (var _ = d + S * r - c, R = g; R < y; ++R) {
                    var I = m + R * o - u
                    C += h.get(E, _, I, x) * p.get(E, S, R, b)
                  }
              s.set(C, d, m, x, w)
            }
        return s.toTensor()
      }),
      (El.prototype.tile = function (t, e) {
        return bl(t, 'tile'), fo(this.bufferSync(t), e)
      }),
      (El.prototype.pad = function (n, t, e) {
        bl(n, 'pad')
        var r = t.map(function (t, e) {
            return t[0] + n.shape[e] + t[1]
          }),
          o = t.map(function (t) {
            return t[0]
          }),
          i = this.bufferSync(n),
          a = Vn(r, n.dtype)
        0 !== e && a.values.fill(e)
        for (var s = 0; s < n.size; s++) {
          var u = i.indexToLoc(s),
            c = u.map(function (t, e) {
              return t + o[e]
            })
          a.set.apply(a, [i.get.apply(i, u)].concat(c))
        }
        return a.toTensor()
      }),
      (El.prototype.transpose = function (t, e) {
        bl(t, 'transpose')
        for (var n = new Array(t.rank), r = 0; r < n.length; r++) n[r] = t.shape[e[r]]
        for (var o = this.readSync(t.dataId), i = Vn(n, t.dtype), a = this.bufferSync(t), r = 0; r < t.size; ++r) {
          for (var s = a.indexToLoc(r), u = new Array(s.length), c = 0; c < u.length; c++) u[c] = s[e[c]]
          var l = i.locToIndex(u)
          i.values[l] = o[r]
        }
        return i.toTensor()
      }),
      (El.prototype.gather = function (t, e, n) {
        bl([t, e], 'gather')
        var r = t.shape.slice(),
          o = this.readSync(e.dataId)
        r[n] = o.length
        for (var i = Vn(r, t.dtype), a = this.bufferSync(t), s = 0; s < i.size; ++s) {
          var u = i.indexToLoc(s),
            c = u.slice()
          c[n] = o[u[n]]
          c = a.locToIndex(c)
          i.values[s] = a.values[c]
        }
        return i.toTensor()
      }),
      (El.prototype.batchToSpaceND = function (t, e, n) {
        bl([t], 'batchToSpaceND')
        var r = e.reduce(function (t, e) {
            return t * e
          }),
          o = mr(t.shape, e, r),
          i = gr(o.length, e.length),
          a = yr(t.shape, e, r),
          r = br(n, e.length),
          e = xr(a, n, e.length)
        return t.reshape(o).transpose(i).reshape(a).slice(r, e)
      }),
      (El.prototype.spaceToBatchND = function (t, e, n) {
        bl([t], 'spaceToBatchND')
        var r = e.reduce(function (t, e) {
            return t * e
          }),
          o = [[0, 0]]
        o.push.apply(o, n)
        for (var i = 1 + e.length; i < t.shape.length; ++i) o.push([0, 0])
        var a = t.pad(o),
          s = mr(a.shape, e, r, !1),
          n = gr(s.length, e.length, !1),
          r = yr(a.shape, e, r, !1)
        return a.reshape(s).transpose(n).reshape(r)
      }),
      (El.prototype.pool = function (t, e, n) {
        bl(t, 'pool')
        for (
          var r = e.strideHeight,
            o = e.strideWidth,
            i = e.dilationHeight,
            a = e.dilationWidth,
            s = e.effectiveFilterHeight,
            u = e.effectiveFilterWidth,
            c = e.padInfo.top,
            l = e.padInfo.left,
            h = 'max' === n ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
            p = this.readSync(t.dataId),
            d = Vn(e.outShape, t.dtype),
            f = d.values,
            v = e.outShape[1] * e.outShape[2] * e.outShape[3],
            m = e.outShape[2] * e.outShape[3],
            g = e.outShape[3],
            y = 0;
          y < e.batchSize;
          ++y
        )
          for (var b = y * v, x = y * t.strides[0], w = 0; w < e.inChannels; ++w)
            for (var C = 0; C < e.outHeight; ++C)
              for (
                var E = C * r - c, S = Math.max(0, E), _ = Math.min(e.inHeight, s + E), R = b + C * m, I = 0;
                I < e.outWidth;
                ++I
              ) {
                for (
                  var A = I * o - l, N = Math.max(0, A), k = Math.min(e.inWidth, u + A), T = h, D = 0, O = 0, F = S;
                  F < _;
                  F += i
                ) {
                  for (var M = x + F * t.strides[1], P = N; P < k; P += a) {
                    var B = p[M + P * t.strides[2] + w]
                    'max' === n && T < B ? (T = B) : 'avg' === n && ((D += B), O++)
                  }
                  if (isNaN(T)) break
                }
                f[R + I * g + w] = 'avg' === n ? D / O : T
              }
        return d.toTensor()
      }),
      (El.prototype.maxPool = function (t, e) {
        return this.pool(t, e, 'max')
      }),
      (El.prototype.maxPoolPositions = function (t, e) {
        for (
          var n = Vn(e.outShape, 'int32'),
            r = e.strideHeight,
            o = e.strideWidth,
            i = e.dilationHeight,
            a = e.dilationWidth,
            s = e.effectiveFilterHeight,
            u = e.effectiveFilterWidth,
            c = e.padInfo.top,
            l = e.padInfo.left,
            h = this.bufferSync(t),
            p = 0;
          p < e.batchSize;
          ++p
        )
          for (var d = 0; d < e.inChannels; ++d)
            for (var f = 0; f < e.outHeight; ++f) {
              for (var v = f * r - c, m = v; m < 0; ) m += i
              for (var g = Math.min(e.inHeight, s + v), y = 0; y < e.outWidth; ++y) {
                for (var b = y * o - l, x = b; x < 0; ) x += a
                for (var w = Math.min(e.inWidth, u + b), C = Number.NEGATIVE_INFINITY, E = -1, S = m; S < g; S += i)
                  for (var _ = S - v, R = x; R < w; R += a) {
                    var I = R - b,
                      A = h.get(p, S, R, d)
                    C < A && ((C = A), (E = _ * u + I))
                  }
                n.set(E, p, f, y, d)
              }
            }
        return n.toTensor()
      }),
      (El.prototype.maxPoolBackprop = function (t, e, n, r) {
        bl([e, n], 'maxPoolBackprop')
        for (
          var n = this.maxPoolPositions(e, r),
            o = r.strideHeight,
            i = r.strideWidth,
            a = r.dilationHeight,
            s = r.dilationWidth,
            u = r.effectiveFilterHeight,
            c = r.effectiveFilterWidth,
            l = c - 1 - r.padInfo.left,
            h = u - 1 - r.padInfo.top,
            p = Vn(e.shape, 'float32'),
            d = this.bufferSync(n),
            f = this.bufferSync(t),
            v = 0;
          v < r.batchSize;
          ++v
        )
          for (var m = 0; m < r.inChannels; ++m)
            for (var g = 0; g < r.inHeight; ++g)
              for (var y = 0; y < r.inWidth; ++y) {
                for (var b = g - h, x = y - l, w = 0, C = 0; C < u; C += a) {
                  var E = (b + C) / o
                  if (!(E < 0 || E >= r.outHeight || Math.floor(E) !== E))
                    for (var S = 0; S < c; S += s) {
                      var _,
                        R = (x + S) / i
                      R < 0 ||
                        R >= r.outWidth ||
                        Math.floor(R) !== R ||
                        (0 != (_ = u * c - 1 - d.get(v, E, R, m) === C * c + S ? 1 : 0) && (w += f.get(v, E, R, m) * _))
                    }
                }
                p.set(w, v, g, y, m)
              }
        return p.toTensor()
      }),
      (El.prototype.avgPoolBackprop = function (t, e, n) {
        bl([t, e], 'avgPoolBackprop')
        for (
          var r = n.strideHeight,
            o = n.strideWidth,
            i = n.filterHeight,
            a = n.filterWidth,
            s = n.dilationHeight,
            u = n.dilationWidth,
            c = n.effectiveFilterHeight,
            l = n.effectiveFilterWidth,
            h = l - 1 - n.padInfo.left,
            p = c - 1 - n.padInfo.top,
            d = Vn(e.shape, 'float32'),
            f = 1 / (i * a),
            v = this.bufferSync(t),
            m = 0;
          m < n.batchSize;
          ++m
        )
          for (var g = 0; g < n.inChannels; ++g)
            for (var y = 0; y < n.inHeight; ++y)
              for (var b = 0; b < n.inWidth; ++b) {
                for (var x = y - p, w = b - h, C = 0, E = 0; E < c; E += s) {
                  var S = (x + E) / r
                  if (!(S < 0 || S >= n.outHeight || Math.floor(S) !== S))
                    for (var _ = 0; _ < l; _ += u) {
                      var R = (w + _) / o
                      R < 0 || R >= n.outWidth || Math.floor(R) !== R || (C += v.get(m, S, R, g))
                    }
                }
                d.set(C * f, m, y, b, g)
              }
        return d.toTensor()
      }),
      (El.prototype.pool3d = function (t, e, n) {
        bl(t, 'pool3d')
        for (
          var r = e.strideDepth,
            o = e.strideHeight,
            i = e.strideWidth,
            a = e.dilationDepth,
            s = e.dilationHeight,
            u = e.dilationWidth,
            c = e.effectiveFilterDepth,
            l = e.effectiveFilterHeight,
            h = e.effectiveFilterWidth,
            p = e.padInfo.front,
            d = e.padInfo.top,
            f = e.padInfo.left,
            v = 'max' === n ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
            m = this.readSync(t.dataId),
            g = Vn(e.outShape, t.dtype),
            y = g.values,
            b = e.outShape[1] * e.outShape[2] * e.outShape[3] * e.outShape[4],
            x = e.outShape[2] * e.outShape[3] * e.outShape[4],
            w = e.outShape[3] * e.outShape[4],
            C = e.outShape[4],
            E = 0;
          E < e.batchSize;
          ++E
        )
          for (var S = E * b, _ = E * t.strides[0], R = 0; R < e.inChannels; ++R)
            for (var I = 0; I < e.outDepth; ++I) {
              for (var A = I * r - p, N = A; N < 0; ) N += a
              for (var k = Math.min(e.inDepth, c + A), T = S + I * x, D = 0; D < e.outHeight; ++D) {
                for (var O = D * o - d, F = O; F < 0; ) F += s
                for (var M = Math.min(e.inHeight, l + O), P = T + D * w, B = 0; B < e.outWidth; ++B) {
                  for (var L = B * i - f, W = L; W < 0; ) W += u
                  for (var z = Math.min(e.inWidth, h + L), L = P + B * C, G = v, U = 0, V = 0, H = N; H < k; H += a) {
                    for (var j = _ + H * t.strides[1], q = F; q < M; q += s) {
                      for (var K = j + q * t.strides[2], X = W; X < z; X += u) {
                        var $ = m[K + X * t.strides[3] + R]
                        if (('max' === n && G < $ ? (G = $) : 'avg' === n && ((U += $), V++), isNaN(G))) break
                      }
                      if (isNaN(G)) break
                    }
                    if (isNaN(G)) break
                  }
                  y[L + R] = 'avg' === n ? U / V : G
                }
              }
            }
        return g.toTensor()
      }),
      (El.prototype.avgPool3d = function (t, e) {
        return bl(t, 'avgPool3d'), this.pool3d(t, e, 'avg').toFloat()
      }),
      (El.prototype.avgPool3dBackprop = function (t, e, n) {
        bl([t, e], 'avgPool3dBackprop')
        for (
          var r = n.strideDepth,
            o = n.strideHeight,
            i = n.strideWidth,
            a = n.filterDepth,
            s = n.filterHeight,
            u = n.filterWidth,
            c = n.dilationDepth,
            l = n.dilationHeight,
            h = n.dilationWidth,
            p = n.effectiveFilterDepth,
            d = n.effectiveFilterHeight,
            f = n.effectiveFilterWidth,
            v = p - 1 - n.padInfo.front,
            m = f - 1 - n.padInfo.left,
            g = d - 1 - n.padInfo.top,
            y = Vn(e.shape, 'float32'),
            b = 1 / (a * s * u),
            x = this.bufferSync(t),
            w = 0;
          w < n.batchSize;
          ++w
        )
          for (var C = 0; C < n.inChannels; ++C)
            for (var E = 0; E < n.inDepth; ++E)
              for (var S = 0; S < n.inHeight; ++S)
                for (var _ = 0; _ < n.inWidth; ++_) {
                  for (var R = E - v, I = S - g, A = _ - m, N = 0, k = 0; k < p; k += c) {
                    var T = (R + k) / r
                    if (!(T < 0 || T >= n.outDepth || Math.floor(T) !== T))
                      for (var D = 0; D < d; D += l) {
                        var O = (I + D) / o
                        if (!(O < 0 || O >= n.outHeight || Math.floor(O) !== O))
                          for (var F = 0; F < f; F += h) {
                            var M = (A + F) / i
                            M < 0 || M >= n.outWidth || Math.floor(M) !== M || (N += x.get(w, T, O, M, C))
                          }
                      }
                  }
                  y.set(N * b, w, E, S, _, C)
                }
        return y.toTensor()
      }),
      (El.prototype.maxPool3d = function (t, e) {
        return bl(t, 'maxPool3d'), this.pool3d(t, e, 'max').toFloat()
      }),
      (El.prototype.maxPool3dPositions = function (t, e) {
        for (
          var n = Vn(e.outShape, 'int32'),
            r = e.strideDepth,
            o = e.strideHeight,
            i = e.strideWidth,
            a = e.dilationDepth,
            s = e.dilationHeight,
            u = e.dilationWidth,
            c = e.effectiveFilterDepth,
            l = e.effectiveFilterHeight,
            h = e.effectiveFilterWidth,
            p = e.padInfo.front,
            d = e.padInfo.top,
            f = e.padInfo.left,
            v = this.bufferSync(t),
            m = 0;
          m < e.batchSize;
          ++m
        )
          for (var g = 0; g < e.inChannels; ++g)
            for (var y = 0; y < e.outDepth; ++y) {
              for (var b = y * r - p, x = b; x < 0; ) x += a
              for (var w = Math.min(e.inDepth, c + b), C = 0; C < e.outHeight; ++C) {
                for (var E = C * o - d, S = E; S < 0; ) S += s
                for (var _ = Math.min(e.inHeight, l + E), R = 0; R < e.outWidth; ++R) {
                  for (var I = R * i - f, A = I; A < 0; ) A += u
                  for (var N = Math.min(e.inWidth, h + I), k = Number.NEGATIVE_INFINITY, T = -1, D = x; D < w; D += a)
                    for (var O = D - b, F = S; F < _; F += s)
                      for (var M = F - E, P = A; P < N; P += u) {
                        var B = P - I,
                          L = v.get(m, D, F, P, g)
                        k <= L && ((k = L), (T = O * l * h + M * l + B))
                      }
                  n.set(T, m, y, C, R, g)
                }
              }
            }
        return n.toTensor()
      }),
      (El.prototype.maxPool3dBackprop = function (t, e, n, r) {
        bl([e, n], 'maxPool3dBackprop')
        for (
          var n = this.maxPool3dPositions(e, r),
            o = r.strideDepth,
            i = r.strideHeight,
            a = r.strideWidth,
            s = r.dilationDepth,
            u = r.dilationHeight,
            c = r.dilationWidth,
            l = r.effectiveFilterDepth,
            h = r.effectiveFilterHeight,
            p = r.effectiveFilterWidth,
            d = l - 1 - r.padInfo.front,
            f = p - 1 - r.padInfo.left,
            v = h - 1 - r.padInfo.top,
            m = Vn(e.shape, 'float32'),
            g = this.bufferSync(n),
            y = this.bufferSync(t),
            b = 0;
          b < r.batchSize;
          ++b
        )
          for (var x = 0; x < r.inChannels; ++x)
            for (var w = 0; w < r.inDepth; ++w)
              for (var C = 0; C < r.inHeight; ++C)
                for (var E = 0; E < r.inWidth; ++E) {
                  for (var S = w - d, _ = C - v, R = E - f, I = 0, A = 0; A < l; A += s) {
                    var N = (S + A) / o
                    if (!(N < 0 || N >= r.outDepth || Math.floor(N) !== N))
                      for (var k = 0; k < h; k += u) {
                        var T = (_ + k) / i
                        if (!(T < 0 || T >= r.outHeight || Math.floor(T) !== T))
                          for (var D = 0; D < p; D += c) {
                            var O,
                              F = (R + D) / a
                            F < 0 ||
                              F >= r.outWidth ||
                              Math.floor(F) !== F ||
                              (0 != (O = l * h * p - 1 - g.get(b, N, T, F, x) === A * h * p + k * p + D ? 1 : 0) &&
                                (I += y.get(b, N, T, F, x) * O))
                          }
                      }
                  }
                  m.set(I, b, w, C, E, x)
                }
        return m.toTensor()
      }),
      (El.prototype.cast = function (t, e) {
        return no(t, e, this)
      }),
      (El.prototype.reshape = ro),
      (El.prototype.avgPool = function (t, e) {
        return bl(t, 'avgPool'), this.pool(t, e, 'avg').toFloat()
      }),
      (El.prototype.resizeBilinear = function (t, e, n, r) {
        bl(t, 'resizeBilinear')
        for (
          var o = t.shape,
            i = o[0],
            a = o[1],
            s = o[2],
            u = o[3],
            c = this.readSync(t.dataId),
            l = new Float32Array(D([i, e, n, u])),
            o = [r && 1 < e ? a - 1 : a, r && 1 < n ? s - 1 : s],
            r = [r && 1 < e ? e - 1 : e, r && 1 < n ? n - 1 : n],
            h = 0,
            p = o[0] / r[0],
            d = o[1] / r[1],
            f = 0;
          f < i;
          f++
        )
          for (var v = 0; v < e; v++)
            for (
              var m = p * v,
                g = Math.floor(m),
                y = m - g,
                m = Math.min(a - 1, Math.ceil(m)),
                b = f * t.strides[0] + g * t.strides[1],
                x = f * t.strides[0] + m * t.strides[1],
                w = 0;
              w < n;
              w++
            )
              for (
                var C = d * w,
                  E = Math.floor(C),
                  S = C - E,
                  C = Math.min(s - 1, Math.ceil(C)),
                  _ = b + E * t.strides[2],
                  R = x + E * t.strides[2],
                  I = b + C * t.strides[2],
                  A = x + C * t.strides[2],
                  N = 0;
                N < u;
                N++
              ) {
                var k = c[_ + N],
                  T = c[R + N],
                  k = k + (c[I + N] - k) * S,
                  k = k + (T + (c[A + N] - T) * S - k) * y
                l[h++] = k
              }
        return cn(l, [i, e, n, u])
      }),
      (El.prototype.resizeBilinearBackprop = function (t, e, n) {
        bl([t, e], 'resizeBilinearBackprop')
        for (
          var r = e.shape,
            o = r[0],
            i = r[1],
            a = r[2],
            s = r[3],
            r = t.shape,
            u = r[1],
            c = r[2],
            l = new Float32Array(o * i * a * s),
            r = [n && 1 < u ? i - 1 : i, n && 1 < c ? a - 1 : a],
            n = [n && 1 < u ? u - 1 : u, n && 1 < c ? c - 1 : c],
            h = r[0] / n[0],
            p = r[1] / n[1],
            d = this.readSync(t.dataId),
            f = 0,
            v = 0;
          v < o;
          v++
        )
          for (var m = v * e.strides[0], g = 0; g < u; g++)
            for (
              var y = g * h,
                b = Math.floor(y),
                x = Math.min(Math.ceil(y), i - 1),
                w = m + b * e.strides[1],
                C = m + x * e.strides[1],
                E = y - b,
                S = 1 - E,
                _ = 0;
              _ < c;
              _++
            )
              for (
                var R = _ * p,
                  I = Math.floor(R),
                  A = Math.min(Math.ceil(R), a - 1),
                  N = R - I,
                  R = 1 - N,
                  k = w + I * e.strides[2],
                  T = w + A * e.strides[2],
                  D = C + I * e.strides[2],
                  O = C + A * e.strides[2],
                  F = S * R,
                  M = S * N,
                  P = E * R,
                  B = E * N,
                  L = 0;
                L < s;
                L++
              ) {
                var W = d[f++]
                ;(l[k + L] += W * F), (l[T + L] += W * M), (l[D + L] += W * P), (l[O + L] += W * B)
              }
        return vn(l, [o, a, i, s], e.dtype)
      }),
      (El.prototype.resizeNearestNeighbor = function (t, e, n, r) {
        bl(t, 'resizeNearestNeighbor')
        for (
          var o = t.shape,
            i = o[0],
            a = o[1],
            s = o[2],
            u = o[3],
            c = this.readSync(t.dataId),
            l = new Float32Array(i * e * n * u),
            h = [r && 1 < e ? a - 1 : a, r && 1 < n ? s - 1 : s],
            o = [r && 1 < e ? e - 1 : e, r && 1 < n ? n - 1 : n],
            p = h[0] / o[0],
            d = h[1] / o[1],
            f = 0,
            v = 0;
          v < i;
          v++
        )
          for (var m = v * t.strides[0], g = 0; g < e; g++)
            for (var y = p * g, b = m + Math.min(a - 1, r ? Math.round(y) : Math.floor(y)) * t.strides[1], x = 0; x < n; x++)
              for (
                var w = d * x, C = b + Math.min(s - 1, r ? Math.round(w) : Math.floor(w)) * t.strides[2], E = 0;
                E < u;
                E++
              ) {
                var S = c[C + E]
                l[f++] = S
              }
        return cn(l, [i, e, n, u], t.dtype)
      }),
      (El.prototype.resizeNearestNeighborBackprop = function (t, e, n) {
        bl([t, e], 'resizeNearestNeighborBackprop')
        for (
          var r = e.shape,
            o = r[0],
            i = r[1],
            a = r[2],
            s = r[3],
            u = t.shape,
            c = u[1],
            l = u[2],
            h = new Float32Array(o * i * a * s),
            p = this.readSync(t.dataId),
            r = [n && 1 < c ? i - 1 : i, n && 1 < l ? a - 1 : a],
            u = [n && 1 < c ? c - 1 : c, n && 1 < l ? l - 1 : l],
            d = r[0] / u[0],
            f = r[1] / u[1],
            v = 1 / d,
            m = 1 / f,
            g = 2 * Math.ceil(v) + 2,
            y = 2 * Math.ceil(m) + 2,
            b = 0;
          b < o;
          b++
        )
          for (var x = b * e.strides[0], w = 0; w < i; w++)
            for (var C = x + w * e.strides[1], E = Math.floor(w * v), S = Math.floor(E - g / 2), _ = 0; _ < a; _++)
              for (var R = C + _ * e.strides[2], I = Math.floor(_ * m), A = Math.floor(I - y / 2), N = 0; N < s; N++) {
                for (var k = 0, T = 0; T < g; T++) {
                  var D = T + S
                  if (!(D < 0 || c <= D)) {
                    var O = x + D * t.strides[1],
                      D = D * d
                    if (w === Math.min(i - 1, n ? Math.round(D) : Math.floor(D)))
                      for (var F = 0; F < y; F++) {
                        var M,
                          P = F + A
                        P < 0 ||
                          l <= P ||
                          ((M = O + P * t.strides[2]),
                          (P = P * f),
                          _ === Math.min(a - 1, n ? Math.round(P) : Math.floor(P)) && (k += p[M + N]))
                      }
                  }
                }
                h[R + N] = k
              }
        return vn(h, e.shape, e.dtype)
      }),
      (El.prototype.batchNormalization = function (t, e, n, r, o, i) {
        bl([t, e, n, o, i], 'batchNorm')
        for (
          var a = this.readSync(t.dataId),
            s = this.readSync(e.dataId),
            u = this.readSync(n.dataId),
            c = o ? this.readSync(o.dataId) : new Float32Array([1]),
            l = i ? this.readSync(i.dataId) : new Float32Array([0]),
            h = new Float32Array(a.length),
            p = l.length,
            d = c.length,
            f = u.length,
            v = s.length,
            m = 0,
            g = 0,
            y = 0,
            b = 0,
            x = 0;
          x < a.length;
          ++x
        )
          (h[x] = l[m++] + ((a[x] - s[g++]) * c[y++]) / Math.sqrt(u[b++] + r)),
            p <= m && (m = 0),
            v <= g && (g = 0),
            d <= y && (y = 0),
            f <= b && (b = 0)
        return vn(h, t.shape)
      }),
      (El.prototype.localResponseNormalization4D = function (t, a, e, n, r) {
        bl(t, 'localResponseNormalization4D')
        var s = t.shape[3],
          u = s - 1,
          c = this.readSync(t.dataId),
          o = t.size,
          i = new Float32Array(o)
        for (var l = 0; l < o; l++) {
          var h = (function (t) {
              for (var e = t % s, n = t - e + Math.max(0, e - a), r = t - e + Math.min(e + a, u), o = 0; n <= r; n++) {
                var i = c[n]
                o += i * i
              }
              return o
            })(l),
            h = c[l] * Math.pow(e + n * h, -r)
          i[l] = h
        }
        return vn(i, t.shape)
      }),
      (El.prototype.LRNGrad = function (t, e, n, r, o, i, a) {
        bl(t, 'LRNGrad')
        for (
          var s = t.shape[3],
            u = this.readSync(t.dataId),
            c = this.readSync(e.dataId),
            l = this.readSync(n.dataId),
            h = new Float32Array(t.size),
            p = t.size,
            d = 0;
          d < p;
          d++
        ) {
          for (var f = d % s, v = d - f + Math.max(0, f - r), m = d - f + Math.min(s, f + r + 1), g = 0, y = v; y < m; y++)
            g += Math.pow(c[y], 2)
          for (g = i * g + o, y = v; y < m; y++) {
            var b = (-2 * i * a * c[y] * l[d]) / g
            d === y && (b += Math.pow(g, -a)), (b *= u[d]), (h[y] += b)
          }
        }
        return vn(h, t.shape)
      }),
      (El.prototype.multinomial = function (t, e, n, r) {
        bl(t, 'multinomial')
        for (
          var e = e ? t : Fr(t),
            o = e.shape[0],
            i = e.shape[1],
            t = gn([o, n], 'int32'),
            a = this.readSync(t.dataId),
            s = this.readSync(e.dataId),
            u = 0;
          u < o;
          ++u
        ) {
          var c = u * i,
            l = new Float32Array(i - 1)
          l[0] = s[c]
          for (var h = 1; h < l.length; ++h) l[h] = l[h - 1] + s[c + h]
          for (var p = Pn(r.toString()), d = u * n, f = 0; f < n; ++f) {
            var v = p()
            a[d + f] = l.length
            for (var m = 0; m < l.length; m++)
              if (v < l[m]) {
                a[d + f] = m
                break
              }
          }
        }
        return t
      }),
      (El.prototype.oneHot = function (t, e, n, r) {
        bl(t, 'oneHot')
        var o = new Float32Array(t.size * e)
        o.fill(r)
        for (var i = this.readSync(t.dataId), a = 0; a < t.size; ++a) 0 <= i[a] && i[a] < e && (o[a * e + i[a]] = n)
        return dn(o, [t.size, e], 'int32')
      }),
      (El.prototype.nonMaxSuppression = function (t, e, n, r, o) {
        return bl(t, 'nonMaxSuppression'), uo(this.readSync(t.dataId), this.readSync(e.dataId), n, r, o)
      }),
      (El.prototype.fft = function (t) {
        return this.fftBatch(t, !1)
      }),
      (El.prototype.ifft = function (t) {
        return this.fftBatch(t, !0)
      }),
      (El.prototype.fftBatch = function (t, e) {
        for (
          var n = t.shape[0],
            r = t.shape[1],
            o = Vn(t.shape, 'float32'),
            i = Vn(t.shape, 'float32'),
            a = sn(t).as2D(n, r),
            s = un(t).as2D(n, r),
            u = 0;
          u < n;
          u++
        )
          for (
            var c = a.slice([u, 0], [1, r]),
              l = s.slice([u, 0], [1, r]),
              l = an(c, l),
              h = this.readSync(this.fftImpl(l, e).dataId),
              p = 0;
            p < r;
            p++
          ) {
            var d = ao(h, p)
            ;(o.values[u * r + p] = d.real), (i.values[u * r + p] = d.imag)
          }
        return an(o.toTensor(), i.toTensor()).as2D(n, r)
      }),
      (El.prototype.fftImpl = function (t, e) {
        var n = t.as1D(),
          r = n.size
        if (this.isExponentOf2(r)) {
          var o = this.fftRadix2(n, r, e).as2D(t.shape[0], t.shape[1])
          return (o = e ? an(sn(o).div(hn(r)), un(o).div(hn(r))) : o)
        }
        ;(o = this.readSync(t.dataId)),
          (e = (function (t) {
            for (var e = new Float32Array(t.length / 2), n = new Float32Array(t.length / 2), r = 0; r < t.length; r += 2)
              (e[r / 2] = t[r]), (n[r / 2] = t[r + 1])
            return { real: e, imag: n }
          })(this.fourierTransformByMatmul(o, r, e)))
        return an(e.real, e.imag).as2D(t.shape[0], t.shape[1])
      }),
      (El.prototype.isExponentOf2 = function (t) {
        return 0 == (t & (t - 1))
      }),
      (El.prototype.fftRadix2 = function (t, e, n) {
        if (1 === e) return t
        var r = this.readSync(t.dataId),
          o = e / 2,
          t = (function (t) {
            for (var e = Math.ceil(t.length / 4), n = new Float32Array(e), r = new Float32Array(e), o = 0; o < t.length; o += 4)
              (n[Math.floor(o / 4)] = t[o]), (r[Math.floor(o / 4)] = t[o + 1])
            return { real: n, imag: r }
          })(r),
          t = an(t.real, t.imag).as1D(),
          r = (function (t) {
            for (
              var e = Math.floor(t.length / 4), n = new Float32Array(e), r = new Float32Array(e), o = 2;
              o < t.length;
              o += 4
            )
              (n[Math.floor(o / 4)] = t[o]), (r[Math.floor(o / 4)] = t[o + 1])
            return { real: n, imag: r }
          })(r),
          r = an(r.real, r.imag).as1D(),
          t = this.fftRadix2(t, o, n),
          r = this.fftRadix2(r, o, n),
          n = (function (t, e) {
            for (var n = new Float32Array(t / 2), r = new Float32Array(t / 2), o = 0; o < Math.ceil(t / 2); o++) {
              var i = (e ? 2 : -2) * Math.PI * (o / t)
              ;(n[o] = Math.cos(i)), (r[o] = Math.sin(i))
            }
            return { real: n, imag: r }
          })(e, n),
          n = an(n.real, n.imag).mul(r),
          r = t.add(n),
          t = t.sub(n),
          n = sn(r).concat(sn(t)),
          t = un(r).concat(un(t))
        return an(n, t).as1D()
      }),
      (El.prototype.fourierTransformByMatmul = function (t, e, n) {
        for (var r, o, i, a, s = new Float32Array(2 * e), u = 0; u < e; u++) {
          for (var c = 0, l = 0, h = 0; h < e; h++) {
            var p = ((p = u * h), (d = e), (d = (n ? 2 : -2) * Math.PI * (p / d)), { real: Math.cos(d), imag: Math.sin(d) }),
              d = ao(t, h)
            ;(c += d.real * p.real - d.imag * p.imag), (l += d.real * p.imag + d.imag * p.real)
          }
          n && ((c /= e), (l /= e)), (o = c), (i = l), ((r = s)[2 * (a = u)] = o), (r[2 * a + 1] = i)
        }
        return s
      }),
      (El.prototype.depthToSpace = function (t, e, n) {
        A('NHWC' === n, function () {
          return 'Only NHWC dataFormat supported on CPU for depthToSpace. Got ' + n
        }),
          A(1 < e, function () {
            return 'blockSize should be > 1 for depthToSpace, but was: ' + e
          })
        for (
          var r = t.shape[0],
            o = t.shape[1],
            i = t.shape[2],
            a = t.shape[3],
            s = o * e,
            u = i * e,
            c = a / (e * e),
            l = this.readSync(t.dataId),
            h = new Float32Array(r * s * u * c),
            p = 0,
            d = 0;
          d < r;
          ++d
        )
          for (var f = 0; f < s; ++f)
            for (var v = Math.floor(f / e), m = f % e, g = 0; g < u; ++g)
              for (var y = Math.floor(g / e), b = (m * e + (g % e)) * c, x = 0; x < c; ++x) {
                var w = x + b + a * (y + i * (v + o * d))
                h[p++] = l[w]
              }
        return vn(h, [r, s, u, c])
      }),
      (El.prototype.broadcastedBinaryOp = function (i, a, t, s) {
        var e = Vr(i.shape, a.shape),
          u = Vn(e, t),
          c = this.readSync(i.dataId),
          l = this.readSync(a.dataId),
          h = Gr(i.shape, e),
          p = Gr(a.shape, e),
          d = u.values
        if (h.length + p.length === 0) for (var n = 0; n < d.length; ++n) d[n] = s(c[n % c.length], l[n % l.length])
        else
          for (var f = this.bufferSync(i), v = this.bufferSync(a), n = 0; n < d.length; ++n)
            !(function (t) {
              var e = u.indexToLoc(t),
                n = e.slice(-i.rank)
              h.forEach(function (t) {
                return (n[t] = 0)
              })
              var r = f.locToIndex(n),
                o = e.slice(-a.rank)
              p.forEach(function (t) {
                return (o[t] = 0)
              })
              e = v.locToIndex(o)
              d[t] = s(c[r], l[e])
            })(n)
        return u.toTensor()
      }),
      (El.prototype.broadcastedBinaryComplexOp = function (i, a, s) {
        var t = Vr(i.shape, a.shape),
          u = Vn(t, 'float32'),
          e = Vn(t, 'float32'),
          c = this.readSync(i.dataId),
          l = this.readSync(a.dataId),
          h = Gr(i.shape, t),
          p = Gr(a.shape, t),
          d = u.values,
          f = e.values
        if (h.length + p.length === 0)
          for (var n = 0; n < d.length; n++) {
            var r = n % c.length,
              o = n % l.length,
              o = s(c[2 * r], c[2 * r + 1], l[2 * o], l[2 * o + 1])
            ;(d[n] = o.real), (f[n] = o.imag)
          }
        else
          for (
            var v = this.bufferSync(this.data.get(i.dataId).complexTensors.real),
              m = this.bufferSync(this.data.get(a.dataId).complexTensors.real),
              n = 0;
            n < d.length;
            n++
          )
            !(function (t) {
              var e = u.indexToLoc(t),
                n = e.slice(-i.rank)
              h.forEach(function (t) {
                return (n[t] = 0)
              })
              var r = v.locToIndex(n),
                o = e.slice(-a.rank)
              p.forEach(function (t) {
                return (o[t] = 0)
              })
              ;(e = m.locToIndex(o)), (e = s(c[2 * r], c[2 * r + 1], l[2 * e], l[2 * e + 1]))
              ;(d[t] = e.real), (f[t] = e.imag)
            })(n)
        return this.complex(u.toTensor(), e.toTensor())
      }),
      (El.prototype.split = po),
      (El.prototype.dispose = function () {}),
      (El.prototype.floatPrecision = function () {
        return 32
      }),
      (El.prototype.epsilon = function () {
        return 1e-7
      }),
      (El.prototype.cropAndResize = function (t, e, n, r, o, i) {
        for (
          var a = t.shape,
            s = a[0],
            u = a[1],
            c = a[2],
            l = a[3],
            h = e.shape[0],
            p = r[0],
            d = r[1],
            f = Vn([h, p, d, l], 'float32'),
            v = this.readSync(e.dataId),
            m = this.readSync(n.dataId),
            g = this.readSync(t.dataId),
            y = t.strides,
            b = f.strides,
            x = 0;
          x < h;
          x++
        ) {
          var w = 4 * x,
            C = v[w],
            E = v[1 + w],
            S = v[2 + w],
            _ = v[3 + w],
            R = m[x]
          if (!(s <= R))
            for (
              var I = 1 < p ? ((S - C) * (u - 1)) / (p - 1) : 0, A = 1 < d ? ((_ - E) * (c - 1)) / (d - 1) : 0, N = 0;
              N < p;
              N++
            ) {
              var k,
                T = 1 < p ? C * (u - 1) + N * I : 0.5 * (C + S) * (u - 1)
              if (T < 0 || u - 1 < T)
                for (var D = 0; D < d; D++)
                  for (var O = 0; O < l; O++) {
                    var F = O + D * b[2] + N * b[1] + x * b[0]
                    f.values[F] = i
                  }
              else if ('bilinear' === o)
                for (var M = Math.floor(T), P = Math.ceil(T), B = T - M, D = 0; D < d; D++)
                  if ((k = 1 < d ? E * (c - 1) + D * A : 0.5 * (E + _) * (c - 1)) < 0 || c - 1 < k)
                    for (O = 0; O < l; O++) (F = O + D * b[2] + N * b[1] + x * b[0]), (f.values[F] = i)
                  else
                    for (var L = Math.floor(k), W = Math.ceil(k), z = k - L, O = 0; O < l; O++) {
                      var G = g[(F = O + L * y[2] + M * y[1] + R * y[0])],
                        U = g[(F = O + W * y[2] + M * y[1] + R * y[0])],
                        V = g[(F = O + L * y[2] + P * y[1] + R * y[0])],
                        G = G + (U - G) * z,
                        V = V + (g[(F = O + W * y[2] + P * y[1] + R * y[0])] - V) * z,
                        F = O + D * b[2] + N * b[1] + x * b[0]
                      f.values[F] = G + (V - G) * B
                    }
              else
                for (D = 0; D < d; ++D)
                  if ((k = 1 < d ? E * (c - 1) + D * A : 0.5 * (E + _) * (c - 1)) < 0 || c - 1 < k)
                    for (O = 0; O < l; O++) (F = O + D * b[2] + N * b[1] + x * b[0]), (f.values[F] = i)
                  else {
                    var H = Math.round(k),
                      j = Math.round(T)
                    for (O = 0; O < l; O++) {
                      var q = O + H * y[2] + j * y[1] + R * y[0],
                        K = O + D * b[2] + N * b[1] + x * b[0]
                      f.values[K] = g[q]
                    }
                  }
            }
        }
        return f.toTensor()
      }),
      (El.prototype.sparseToDense = function (t, e, n, r) {
        var o = _r(0, t, n),
          i = o.sliceRank,
          a = o.numUpdates,
          s = o.sliceSize,
          u = o.strides,
          o = o.outputSize
        return this.scatter(t, e, n, o, s, a, i, u, r, !1)
      }),
      (El.prototype.gatherND = function (t, e) {
        var n = e.shape,
          r = n[n.length - 1],
          o = wr(t, e),
          n = o[0],
          i = o[1],
          a = o[2],
          s = o[3]
        if (0 === i) return cn([], n, t.dtype)
        for (var u = new ft([i, a], t.dtype), c = this.readSync(e.dataId), l = this.readSync(t.dataId), h = 0; h < i; h++) {
          for (var p = [], d = 0, f = 0; f < r; f++) {
            var v = c[h * r + f]
            ;(d += v * s[f]), p.push(v)
          }
          if (d < 0 || d >= t.size / a) throw new Error('Invalid indices: ' + p + ' does not index into ' + t.shape)
          for (var m = 0; m < a; m++) u.values[h * a + m] = l[d * a + m]
        }
        return u.toTensor().reshape(n)
      }),
      (El.prototype.scatterND = function (t, e, n) {
        var r = _r(0, t, n),
          o = r.sliceRank,
          i = r.numUpdates,
          a = r.sliceSize,
          s = r.strides,
          u = r.outputSize,
          r = hn(0)
        return this.scatter(t, e, n, u, a, i, o, s, r, !0)
      }),
      (El.prototype.fill = function (t, e, n) {
        var r = P((n = n || q(e)), D(t))
        return r.fill(e), Pt.makeTensor(r, t, n, this)
      }),
      (El.prototype.onesLike = function (t) {
        if ('string' === t.dtype) throw new Error('onesLike is not supported for string tensors')
        return this.fill(t.shape, 1, t.dtype)
      }),
      (El.prototype.zerosLike = function (t) {
        var e = P(t.dtype, D(t.shape))
        return this.makeOutput(e, t.shape, t.dtype)
      }),
      (El.prototype.linspace = oo),
      (El.prototype.scatter = function (t, e, n, r, o, i, a, s, u, c) {
        var l = [r / o, o],
          h = this.readSync(t.dataId),
          p = this.readSync(e.dataId)
        if (0 === r) return cn([], n, e.dtype)
        var d = new ft(l, e.dtype)
        d.values.fill(this.readSync(u.dataId)[0])
        for (var f = 0; f < i; f++) {
          for (var v = [], m = 0, g = 0; g < a; g++) {
            var y = h[f * a + g]
            v.push(y), (m += y * s[g])
          }
          if (m < 0 || r / o <= m) throw new Error('Invalid indices: ' + v + ' does not index into ' + n)
          for (var b = 0; b < o; b++)
            c ? (d.values[m * o + b] += p[f * o + b]) : (d.values[m * o + b] = 0 === e.rank ? p[0] : p[f * o + b])
        }
        return d.toTensor().reshape(n)
      }),
      El)
  function El() {
    var t = wl.call(this) || this
    return (t.blockSize = 48), (t.firstUse = !0), (t.data = new Pr(t, Pt)), t
  }
  Pt.registerBackend(
    'cpu',
    function () {
      return new Cl()
    },
    1,
  )
  for (
    var Sl = 0,
      _l = [
        {
          kernelName: 'NonMaxSuppressionV5',
          backendName: 'cpu',
          kernelFunc: function (t) {
            var e = t.inputs,
              n = t.backend,
              r = t.attrs,
              o = e.boxes,
              i = e.scores,
              a = r.maxOutputSize,
              t = r.iouThreshold,
              e = r.scoreThreshold,
              r = r.softNmsSigma,
              n = n
            bl(o, 'NonMaxSuppressionWithScore')
            r = co(n.data.get(o.dataId).values, n.data.get(i.dataId).values, a, t, e, r)
            return [r.selectedIndices, r.selectedScores]
          },
        },
        {
          kernelName: 'Square',
          backendName: 'cpu',
          kernelFunc: function (t) {
            var e = t.inputs,
              t = t.backend,
              e = e.x,
              t = t
            bl(e, 'square')
            for (var n = t.data.get(e.dataId).values, r = new Float32Array(n.length), o = 0; o < n.length; ++o) {
              var i = n[o]
              r[o] = i * i
            }
            return { dataId: t.write(r, e.shape, e.dtype), shape: e.shape, dtype: e.dtype }
          },
        },
        {
          kernelName: os,
          backendName: 'cpu',
          kernelFunc: function (t) {
            var e = t.inputs,
              n = t.backend,
              r = e.a,
              o = e.b,
              t = n
            bl([r, o], os)
            ;(e = t.data.get(r.dataId).values),
              (n = t.data.get(o.dataId).values),
              (e = (function (t, e, i, a, n, s) {
                var r = Vr(t, e),
                  u = r.length,
                  c = $(r),
                  l = M(n, D(r)),
                  h = t.length,
                  p = e.length,
                  d = $(t),
                  f = $(e),
                  v = Gr(t, r),
                  m = Gr(e, r)
                if (v.length + m.length === 0) for (var o = 0; o < l.length; ++o) l[o] = s(i[o % i.length], a[o % a.length])
                else
                  for (o = 0; o < l.length; ++o)
                    !(function (t) {
                      var e = it(t, u, c),
                        n = e.slice(-h)
                      v.forEach(function (t) {
                        return (n[t] = 0)
                      })
                      var r = ot(n, h, d),
                        o = e.slice(-p)
                      m.forEach(function (t) {
                        return (o[t] = 0)
                      })
                      e = ot(o, p, f)
                      l[t] = s(i[r], a[e])
                    })(o)
                return [l, r]
              })(r.shape, o.shape, e, n, r.dtype, function (t, e) {
                e = t - e
                return e * e
              })),
              (n = e[0]),
              (e = e[1])
            return { dataId: t.write(n, e, r.dtype), shape: e, dtype: r.dtype }
          },
        },
      ];
    Sl < _l.length;
    Sl++
  )
    h(_l[Sl])
  for (
    var Rl,
      Il = function (t) {
        this.variableNames = ['A']
        var e = Co(),
          n = t[0],
          r = t[1]
        ;(this.outputShape = t),
          (this.userCode =
            '\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(' +
            r +
            '.0, ' +
            n +
            '.0);\n\n        vec4 values = ' +
            e.texture2D +
            '(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    ')
      },
      Al = function (t) {
        ;(this.variableNames = ['A']), (this.packedInputs = !1), (this.packedOutput = !0)
        var e = Co(),
          n = t[0],
          r = t[1]
        ;(this.outputShape = t),
          (this.userCode =
            '\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(' +
            r +
            '.0, ' +
            n +
            '.0);\n            vec4 values = ' +
            e.texture2D +
            '(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ' +
            e.output +
            ' = result;\n      }\n    ')
      },
      Nl = 0,
      kl = [
        {
          kernelName: 'FromPixels',
          backendName: 'webgl',
          kernelFunc: function (t) {
            var e = t.inputs,
              n = t.backend,
              r = t.attrs,
              o = e.pixels,
              i = r.numChannels,
              a = 'undefined' != typeof HTMLVideoElement && o instanceof HTMLVideoElement,
              s = 'undefined' != typeof HTMLImageElement && o instanceof HTMLImageElement,
              t = a ? [o.videoWidth, o.videoHeight] : [o.width, o.height],
              e = t[0],
              r = t[1],
              t = [r, e],
              i = [r, e, i]
            ;(s || a) &&
              (((Rl = null == Rl ? document.createElement('canvas').getContext('2d') : Rl).canvas.width = e),
              (Rl.canvas.height = r),
              Rl.drawImage(o, 0, 0, e, r),
              (o = Rl.canvas))
            t = n.makeTensorInfo(t, 'int32')
            ;(n.texData.get(t.dataId).usage = zt.PIXELS), n.gpgpu.uploadPixelDataToTexture(n.getTexture(t.dataId), o)
            ;(i = new (f.getBool('WEBGL_PACK') ? Al : Il)(i)), (i = n.runWebGLProgram(i, [t], 'int32'))
            return n.disposeData(t.dataId), i
          },
        },
        {
          kernelName: 'NonMaxSuppressionV5',
          backendName: 'webgl',
          kernelFunc: function (t) {
            var e = t.inputs,
              n = t.backend,
              r = t.attrs
            Ve('tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead')
            var o = e.boxes,
              i = e.scores,
              a = r.maxOutputSize,
              t = r.iouThreshold,
              e = r.scoreThreshold,
              r = r.softNmsSigma,
              n = n,
              r = co(n.readSync(o.dataId), n.readSync(i.dataId), a, t, e, r)
            return [r.selectedIndices, r.selectedScores]
          },
        },
        {
          kernelName: 'Square',
          backendName: 'webgl',
          kernelFunc: function (t) {
            var e = t.inputs,
              n = t.backend,
              t = e.x,
              e = n,
              n = new Oa(t.shape, 'return x * x;')
            return e.runWebGLProgram(n, [t], t.dtype)
          },
        },
        {
          kernelName: os,
          backendName: 'webgl',
          kernelFunc: function (t) {
            var e = t.inputs,
              n = t.backend,
              r = e.a,
              t = e.b,
              e = n,
              n = new (f.getBool('WEBGL_PACK_BINARY_OPERATIONS') ? Wo : Lo)('return (a - b) * (a - b);', r.shape, t.shape)
            return e.compileAndRun(n, [r, t])
          },
        },
      ];
    Nl < kl.length;
    Nl++
  )
    h(kl[Nl])
  for (
    var Tl,
      Dl,
      Ol = 0,
      Fl = [
        {
          kernelName: 'Square',
          gradFunc: function (t, e) {
            var n = e[0]
            return {
              x: function () {
                return t.mul(n.toFloat().mul(2))
              },
            }
          },
        },
        {
          kernelName: os,
          gradFunc: function (t, e) {
            var n = e[0],
              r = e[1],
              o = hn(2)
            return {
              a: function () {
                return xu(t, xu(o, _u(n, r)))
              },
              b: function () {
                return xu(t, xu(o, _u(r, n)))
              },
            }
          },
        },
      ];
    Ol < Fl.length;
    Ol++
  )
    (Dl = void 0),
      (Dl = (Tl = Fl[Ol]).kernelName),
      c.has(Dl) && console.warn("Overriding the gradient for '" + Dl + "'"),
      c.set(Dl, Tl)
  ;(Ml.prototype.fetch = function (t, e) {
    return fetch(t, e)
  }),
    (Ml.prototype.now = function () {
      return performance.now()
    }),
    (Ml.prototype.encode = function (t, e) {
      if ('utf-8' !== e && 'utf8' !== e) throw new Error("Browser's encoder only supports utf-8, but got " + e)
      return null == this.textEncoder && (this.textEncoder = new TextEncoder()), this.textEncoder.encode(t)
    }),
    (Ml.prototype.decode = function (t, e) {
      return new TextDecoder(e).decode(t)
    }),
    (el = Ml)
  function Ml() {}
  f.get('IS_BROWSER') && f.setPlatform('browser', new el())
  var Pl,
    nl =
      ((Bl.prototype.fetch = function (t, e) {
        return null != f.global.fetch ? f.global.fetch(t, e) : (Pl = null == Pl ? require('node-fetch') : Pl)(t, e)
      }),
      (Bl.prototype.now = function () {
        var t = process.hrtime()
        return 1e3 * t[0] + t[1] / 1e6
      }),
      (Bl.prototype.encode = function (t, e) {
        if ('utf-8' !== e && 'utf8' !== e) throw new Error('Node built-in encoder only supports utf-8, but got ' + e)
        return this.textEncoder.encode(t)
      }),
      (Bl.prototype.decode = function (t, e) {
        return 0 === t.length ? '' : new this.util.TextDecoder(e).decode(t)
      }),
      Bl)
  function Bl() {
    ;(this.util = require('util')), (this.textEncoder = new this.util.TextEncoder())
  }
  f.get('IS_NODE') && f.setPlatform('node', new nl())
  var Ll = { float32: 4, int32: 4, uint16: 2, uint8: 1, bool: 1 },
    Wl = 4
  function zl(f, t) {
    for (var v = {}, m = 0, e = 0, n = t; e < n.length; e++)
      !(function (t) {
        var e = t.name,
          n = t.dtype,
          r = t.shape,
          o = D(r),
          i = void 0
        if ('quantization' in t) {
          var a = t.quantization
          if ('uint8' !== a.dtype && 'uint16' !== a.dtype)
            throw new Error(
              'Weight ' +
                t.name +
                ' has unknown quantization dtype ' +
                a.dtype +
                ". Supported quantization dtypes are: 'uint8' and 'uint16'.",
            )
          var s = Ll[a.dtype],
            u = f.slice(m, m + o * s),
            c = new ('uint8' === a.dtype ? Uint8Array : Uint16Array)(u)
          if ('float32' === n)
            i = Float32Array.from(c, function (t) {
              return t * a.scale + a.min
            })
          else {
            if ('int32' !== n) throw new Error("Unsupported dtype in weight '" + e + "': " + n)
            i = Int32Array.from(c, function (t) {
              return Math.round(t * a.scale + a.min)
            })
          }
          m += o * s
        } else if ('string' === n)
          for (var l = D(t.shape), i = [], h = 0; h < l; h++) {
            var p = new Uint32Array(f.slice(m, m + Wl))[0]
            m += Wl
            var d = new Uint8Array(f.slice(m, m + p))
            i.push(d), (m += p)
          }
        else {
          ;(t = Ll[n]), (u = f.slice(m, m + o * t))
          if ('float32' === n) i = new Float32Array(u)
          else if ('int32' === n) i = new Int32Array(u)
          else {
            if ('bool' !== n) throw new Error("Unsupported dtype in weight '" + e + "': " + n)
            i = new Uint8Array(u)
          }
          m += o * t
        }
        v[e] = cn(i, r, n)
      })(n[e])
    return v
  }
  var Gl =
    'undefined' != typeof Buffer && ('undefined' == typeof Blob || 'undefined' == typeof atob || 'undefined' == typeof btoa)
  function Ul(t) {
    return Gl ? Buffer.byteLength(t) : new Blob([t]).size
  }
  function Vl(t) {
    var e = 0
    t.forEach(function (t) {
      e += t.byteLength
    })
    var n = new Uint8Array(e),
      r = 0
    return (
      t.forEach(function (t) {
        n.set(new Uint8Array(t), r), (r += t.byteLength)
      }),
      n.buffer
    )
  }
  function Hl(t) {
    for (t = t.trim(); t.endsWith('/'); ) t = t.slice(0, t.length - 1)
    var e = t.split('/')
    return e[e.length - 1]
  }
  function jl(t) {
    if (t.modelTopology instanceof ArrayBuffer) throw new Error('Expected JSON model topology, received ArrayBuffer.')
    return {
      dateSaved: new Date(),
      modelTopologyType: 'JSON',
      modelTopologyBytes: null == t.modelTopology ? 0 : Ul(JSON.stringify(t.modelTopology)),
      weightSpecsBytes: null == t.weightSpecs ? 0 : Ul(JSON.stringify(t.weightSpecs)),
      weightDataBytes: null == t.weightData ? 0 : t.weightData.byteLength,
    }
  }
  var ql =
      ((Yl.getInstance = function () {
        return (Yl.instance = null == Yl.instance ? new Yl() : Yl.instance)
      }),
      (Yl.registerSaveRouter = function (t) {
        Yl.getInstance().saveRouters.push(t)
      }),
      (Yl.registerLoadRouter = function (t) {
        Yl.getInstance().loadRouters.push(t)
      }),
      (Yl.getSaveHandlers = function (t) {
        return Yl.getHandlers(t, 'save')
      }),
      (Yl.getLoadHandlers = function (t, e) {
        return Yl.getHandlers(t, 'load', e)
      }),
      (Yl.getHandlers = function (e, t, n) {
        var r = []
        return (
          ('load' === t ? Yl.getInstance().loadRouters : Yl.getInstance().saveRouters).forEach(function (t) {
            t = t(e, n)
            null !== t && r.push(t)
          }),
          r
        )
      }),
      Yl),
    Kl = '://',
    Xl =
      (($l.getInstance = function () {
        return ($l.instance = null == $l.instance ? new $l() : $l.instance)
      }),
      ($l.registerManager = function (t, e) {
        A(null != t, function () {
          return 'scheme must not be undefined or null.'
        }),
          A(0 < (t = t.endsWith(Kl) ? t.slice(0, t.indexOf(Kl)) : t).length, function () {
            return 'scheme must not be an empty string.'
          })
        var n = $l.getInstance()
        A(null == n.managers[t], function () {
          return "A model store manager is already registered for scheme '" + t + "'."
        }),
          (n.managers[t] = e)
      }),
      ($l.getManager = function (t) {
        var e = this.getInstance().managers[t]
        if (null == e) throw new Error("Cannot find model manager for scheme '" + t + "'")
        return e
      }),
      ($l.getSchemes = function () {
        return Object.keys(this.getInstance().managers)
      }),
      $l)
  function $l() {
    this.managers = {}
  }
  function Yl() {
    ;(this.saveRouters = []), (this.loadRouters = [])
  }
  function Jl(t) {
    if (-1 === t.indexOf(Kl))
      throw new Error('The url string provided does not contain a scheme. Supported schemes are: ' + Xl.getSchemes().join(','))
    return { scheme: t.split(Kl)[0], path: t.split(Kl)[1] }
  }
  function Ql(c, l, h) {
    return (
      void 0 === h && (h = !1),
      x(this, void 0, void 0, function () {
        var e, n, r, o, i, a, s, u
        return w(this, function (t) {
          switch (t.label) {
            case 0:
              return (
                A(c !== l, function () {
                  return "Old path and new path are the same: '" + c + "'"
                }),
                A(0 < (e = ql.getLoadHandlers(c)).length, function () {
                  return 'Copying failed because no load handler is found for source URL ' + c + '.'
                }),
                A(e.length < 2, function () {
                  return 'Copying failed because more than one (' + e.length + ') load handlers for source URL ' + c + '.'
                }),
                (n = e[0]),
                A(0 < (a = ql.getSaveHandlers(l)).length, function () {
                  return 'Copying failed because no save handler is found for destination URL ' + l + '.'
                }),
                A(a.length < 2, function () {
                  return 'Copying failed because more than one (' + e.length + ') save handlers for destination URL ' + l + '.'
                }),
                (r = a[0]),
                (o = Jl(c).scheme),
                (i = Jl(c).path),
                (a = o === Jl(c).scheme),
                [4, n.load()]
              )
            case 1:
              return (s = t.sent()), h && a ? [4, Xl.getManager(o).removeModel(i)] : [3, 3]
            case 2:
              t.sent(), (t.label = 3)
            case 3:
              return [4, r.save(s)]
            case 4:
              return (u = t.sent()), !h || a ? [3, 6] : [4, Xl.getManager(o).removeModel(i)]
            case 5:
              t.sent(), (t.label = 6)
            case 6:
              return [2, u.modelArtifactsInfo]
          }
        })
      })
    )
  }
  var Zl = 'models_store',
    th = 'model_info_store'
  function eh() {
    if (!f.getBool('IS_BROWSER'))
      throw new Error('Failed to obtain IndexedDB factory because the current environmentis not a web browser.')
    var t = window || self,
      t = t.indexedDB || t.mozIndexedDB || t.webkitIndexedDB || t.msIndexedDB || t.shimIndexedDB
    if (null == t) throw new Error('The current browser does not appear to support IndexedDB.')
    return t
  }
  function nh(t) {
    t = t.result
    t.createObjectStore(Zl, { keyPath: 'modelPath' }), t.createObjectStore(th, { keyPath: 'modelPath' })
  }
  var rh =
      ((oh.prototype.save = function (e) {
        return x(this, void 0, void 0, function () {
          return w(this, function (t) {
            if (e.modelTopology instanceof ArrayBuffer)
              throw new Error('BrowserLocalStorage.save() does not support saving model topology in binary formats yet.')
            return [2, this.databaseAction(this.modelPath, e)]
          })
        })
      }),
      (oh.prototype.load = function () {
        return x(this, void 0, void 0, function () {
          return w(this, function (t) {
            return [2, this.databaseAction(this.modelPath)]
          })
        })
      }),
      (oh.prototype.databaseAction = function (t, h) {
        var p = this
        return new Promise(function (u, c) {
          var l = p.indexedDB.open('tensorflowjs', 1)
          ;(l.onupgradeneeded = function () {
            return nh(l)
          }),
            (l.onsuccess = function () {
              var t,
                e,
                r,
                o,
                i,
                a,
                n,
                s = l.result
              null == h
                ? ((t = s.transaction(Zl, 'readonly')),
                  ((e = t.objectStore(Zl).get(p.modelPath)).onsuccess = function () {
                    if (null == e.result)
                      return s.close(), c(new Error("Cannot find model with path '" + p.modelPath + "' in IndexedDB."))
                    u(e.result.modelArtifacts)
                  }),
                  (e.onerror = function (t) {
                    return s.close(), c(e.error)
                  }),
                  (t.oncomplete = function () {
                    return s.close()
                  }))
                : ((o = jl(h)),
                  (i = s.transaction(th, 'readwrite')),
                  (a = i.objectStore(th)),
                  ((n = a.put({ modelPath: p.modelPath, modelArtifactsInfo: o })).onsuccess = function () {
                    var n = (r = s.transaction(Zl, 'readwrite'))
                      .objectStore(Zl)
                      .put({ modelPath: p.modelPath, modelArtifacts: h, modelArtifactsInfo: o })
                    ;(n.onsuccess = function () {
                      return u({ modelArtifactsInfo: o })
                    }),
                      (n.onerror = function (t) {
                        var e = (a = i.objectStore(th)).delete(p.modelPath)
                        ;(e.onsuccess = function () {
                          return s.close(), c(n.error)
                        }),
                          (e.onerror = function (t) {
                            return s.close(), c(n.error)
                          })
                      })
                  }),
                  (n.onerror = function (t) {
                    return s.close(), c(n.error)
                  }),
                  (i.oncomplete = function () {
                    null == r
                      ? s.close()
                      : (r.oncomplete = function () {
                          return s.close()
                        })
                  }))
            }),
            (l.onerror = function (t) {
              return c(l.error)
            })
        })
      }),
      (oh.URL_SCHEME = 'indexeddb://'),
      oh),
    o = function (t) {
      return f.getBool('IS_BROWSER') && !Array.isArray(t) && t.startsWith(rh.URL_SCHEME)
        ? ((t = t.slice(rh.URL_SCHEME.length)), new rh(t))
        : null
    }
  function oh(t) {
    if (((this.indexedDB = eh()), null == t || !t))
      throw new Error('For IndexedDB, modelPath must not be null, undefined or empty.')
    this.modelPath = t
  }
  ql.registerSaveRouter(o), ql.registerLoadRouter(o)
  var ih =
    ((ah.prototype.listModels = function () {
      return x(this, void 0, void 0, function () {
        var e = this
        return w(this, function (t) {
          return [
            2,
            new Promise(function (i, n) {
              var r = e.indexedDB.open('tensorflowjs', 1)
              ;(r.onupgradeneeded = function () {
                return nh(r)
              }),
                (r.onsuccess = function () {
                  var e = r.result,
                    t = e.transaction(th, 'readonly'),
                    o = t.objectStore(th).getAll()
                  ;(o.onsuccess = function () {
                    for (var t = {}, e = 0, n = o.result; e < n.length; e++) {
                      var r = n[e]
                      t[r.modelPath] = r.modelArtifactsInfo
                    }
                    i(t)
                  }),
                    (o.onerror = function (t) {
                      return e.close(), n(o.error)
                    }),
                    (t.oncomplete = function () {
                      return e.close()
                    })
                }),
                (r.onerror = function (t) {
                  return n(r.error)
                })
            }),
          ]
        })
      })
    }),
    (ah.prototype.removeModel = function (u) {
      return x(this, void 0, void 0, function () {
        var n = this
        return w(this, function (t) {
          var e
          return (
            (u = (e = u).startsWith(rh.URL_SCHEME) ? e.slice(rh.URL_SCHEME.length) : e),
            [
              2,
              new Promise(function (a, s) {
                var e = n.indexedDB.open('tensorflowjs', 1)
                ;(e.onupgradeneeded = function () {
                  return nh(e)
                }),
                  (e.onsuccess = function () {
                    var n,
                      r = e.result,
                      t = r.transaction(th, 'readwrite'),
                      o = t.objectStore(th),
                      i = o.get(u)
                    ;(i.onsuccess = function () {
                      if (null == i.result)
                        return r.close(), s(new Error("Cannot find model with path '" + u + "' in IndexedDB."))
                      function e() {
                        var t = (n = r.transaction(Zl, 'readwrite')).objectStore(Zl).delete(u)
                        ;(t.onsuccess = function () {
                          return a(i.result.modelArtifactsInfo)
                        }),
                          (t.onerror = function (t) {
                            return s(i.error)
                          })
                      }
                      var t = o.delete(u)
                      ;(t.onsuccess = e),
                        (t.onerror = function (t) {
                          return e(), r.close(), s(i.error)
                        })
                    }),
                      (i.onerror = function (t) {
                        return r.close(), s(i.error)
                      }),
                      (t.oncomplete = function () {
                        null == n
                          ? r.close()
                          : (n.oncomplete = function () {
                              return r.close()
                            })
                      })
                  }),
                  (e.onerror = function (t) {
                    return s(e.error)
                  })
              }),
            ]
          )
        })
      })
    }),
    ah)
  function ah() {
    this.indexedDB = eh()
  }
  if (f.getBool('IS_BROWSER'))
    try {
      Xl.registerManager(rh.URL_SCHEME, new ih())
    } catch (r) {}
  var sh = '/',
    uh = 'tensorflowjs_models',
    ch = 'info',
    lh = 'model_topology',
    hh = 'weight_specs',
    ph = 'weight_data',
    dh = 'model_metadata'
  function fh(t) {
    return {
      info: [uh, t, ch].join(sh),
      topology: [uh, t, lh].join(sh),
      weightSpecs: [uh, t, hh].join(sh),
      weightData: [uh, t, ph].join(sh),
      modelMetadata: [uh, t, dh].join(sh),
    }
  }
  var vh =
      ((mh.prototype.save = function (o) {
        return x(this, void 0, void 0, function () {
          var e, n, r
          return w(this, function (t) {
            if (o.modelTopology instanceof ArrayBuffer)
              throw new Error('BrowserLocalStorage.save() does not support saving model topology in binary formats yet.')
            ;(e = JSON.stringify(o.modelTopology)), (n = JSON.stringify(o.weightSpecs)), (r = jl(o))
            try {
              return (
                this.LS.setItem(this.keys.info, JSON.stringify(r)),
                this.LS.setItem(this.keys.topology, e),
                this.LS.setItem(this.keys.weightSpecs, n),
                this.LS.setItem(
                  this.keys.weightData,
                  (function (t) {
                    if (Gl) return Buffer.from(t).toString('base64')
                    for (var e = new Uint8Array(t), n = '', r = 0, o = e.length; r < o; r++) n += String.fromCharCode(e[r])
                    return btoa(n)
                  })(o.weightData),
                ),
                this.LS.setItem(
                  this.keys.modelMetadata,
                  JSON.stringify({
                    format: o.format,
                    generatedBy: o.generatedBy,
                    convertedBy: o.convertedBy,
                    userDefinedMetadata: o.userDefinedMetadata,
                  }),
                ),
                [2, { modelArtifactsInfo: r }]
              )
            } catch (t) {
              throw (
                (this.LS.removeItem(this.keys.info),
                this.LS.removeItem(this.keys.topology),
                this.LS.removeItem(this.keys.weightSpecs),
                this.LS.removeItem(this.keys.weightData),
                this.LS.removeItem(this.keys.modelMetadata),
                new Error(
                  "Failed to save model '" +
                    this.modelPath +
                    "' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=" +
                    r.modelTopologyBytes +
                    ', weightSpecsBytes=' +
                    r.weightSpecsBytes +
                    ', weightDataBytes=' +
                    r.weightDataBytes +
                    '.',
                ))
              )
            }
            return [2]
          })
        })
      }),
      (mh.prototype.load = function () {
        return x(this, void 0, void 0, function () {
          var e, n, r
          return w(this, function (t) {
            if (null == (n = JSON.parse(this.LS.getItem(this.keys.info))))
              throw new Error("In local storage, there is no model with name '" + this.modelPath + "'")
            if ('JSON' !== n.modelTopologyType)
              throw new Error('BrowserLocalStorage does not support loading non-JSON model topology yet.')
            if (((e = {}), null == (n = JSON.parse(this.LS.getItem(this.keys.topology)))))
              throw new Error("In local storage, the topology of model '" + this.modelPath + "' is missing.")
            if (((e.modelTopology = n), null == (n = JSON.parse(this.LS.getItem(this.keys.weightSpecs)))))
              throw new Error("In local storage, the weight specs of model '" + this.modelPath + "' are missing.")
            if (
              ((e.weightSpecs = n),
              null != (n = this.LS.getItem(this.keys.modelMetadata)) &&
                ((r = JSON.parse(n)),
                (e.format = r.format),
                (e.generatedBy = r.generatedBy),
                (e.convertedBy = r.convertedBy),
                (e.userDefinedMetadata = r.userDefinedMetadata)),
              null == (r = this.LS.getItem(this.keys.weightData)))
            )
              throw new Error("In local storage, the binary weight values of model '" + this.modelPath + "' are missing.")
            return (
              (e.weightData = (function (t) {
                if (Gl) {
                  var e = Buffer.from(t, 'base64')
                  return e.buffer.slice(e.byteOffset, e.byteOffset + e.byteLength)
                }
                for (var n = atob(t), r = new Uint8Array(n.length), o = 0; o < n.length; ++o) r.set([n.charCodeAt(o)], o)
                return r.buffer
              })(r)),
              [2, e]
            )
          })
        })
      }),
      (mh.URL_SCHEME = 'localstorage://'),
      mh),
    Dt = function (t) {
      return f.getBool('IS_BROWSER') && !Array.isArray(t) && t.startsWith(vh.URL_SCHEME)
        ? ((t = t.slice(vh.URL_SCHEME.length)), new vh(t))
        : null
    }
  function mh(t) {
    if (!f.getBool('IS_BROWSER') || 'undefined' == typeof window || void 0 === window.localStorage)
      throw new Error('The current environment does not support local storage.')
    if (((this.LS = window.localStorage), null == t || !t))
      throw new Error('For local storage, modelPath must not be null, undefined or empty.')
    ;(this.modelPath = t), (this.keys = fh(this.modelPath))
  }
  ql.registerSaveRouter(Dt), ql.registerLoadRouter(Dt)
  var gh =
    ((yh.prototype.listModels = function () {
      return x(this, void 0, void 0, function () {
        var e, n, r, o, i, a
        return w(this, function (t) {
          for (e = {}, n = uh + sh, r = sh + ch, o = 0; o < this.LS.length; ++o)
            (i = this.LS.key(o)).startsWith(n) &&
              i.endsWith(r) &&
              ((a = (function (t) {
                var e = t.split(sh)
                if (e.length < 3) throw new Error('Invalid key format: ' + t)
                return e.slice(1, e.length - 1).join(sh)
              })(i)),
              (e[a] = JSON.parse(this.LS.getItem(i))))
          return [2, e]
        })
      })
    }),
    (yh.prototype.removeModel = function (o) {
      return x(this, void 0, void 0, function () {
        var n, r
        return w(this, function (t) {
          var e
          if (
            ((o = (e = o).startsWith(vh.URL_SCHEME) ? e.slice(vh.URL_SCHEME.length) : e),
            (n = fh(o)),
            null == this.LS.getItem(n.info))
          )
            throw new Error("Cannot find model at path '" + o + "'")
          return (
            (r = JSON.parse(this.LS.getItem(n.info))),
            this.LS.removeItem(n.info),
            this.LS.removeItem(n.topology),
            this.LS.removeItem(n.weightSpecs),
            this.LS.removeItem(n.weightData),
            [2, r]
          )
        })
      })
    }),
    yh)
  function yh() {
    A(f.getBool('IS_BROWSER'), function () {
      return 'Current environment is not a web browser'
    }),
      A('undefined' == typeof window || void 0 !== window.localStorage, function () {
        return 'Current browser does not appear to support localStorage'
      }),
      (this.LS = window.localStorage)
  }
  if (f.getBool('IS_BROWSER'))
    try {
      Xl.registerManager(vh.URL_SCHEME, new gh())
    } catch (r) {}
  var bh = 'model',
    xh = '.json',
    wh = '.weights.bin'
  function Ch(t) {
    return new Promise(function (t) {
      return setTimeout(t)
    }).then(t)
  }
  var Eh =
      ((Rh.prototype.save = function (i) {
        return x(this, void 0, void 0, function () {
          var e, n, r, o
          return w(this, function (t) {
            switch (t.label) {
              case 0:
                if ('undefined' == typeof document)
                  throw new Error('Browser downloads are not supported in this environment since `document` is not present')
                if (
                  ((e = window.URL.createObjectURL(new Blob([i.weightData], { type: 'application/octet-stream' }))),
                  !(i.modelTopology instanceof ArrayBuffer))
                )
                  return [3, 1]
                throw new Error('BrowserDownloads.save() does not support saving model topology in binary formats yet.')
              case 1:
                return (
                  (n = [{ paths: ['./' + this.weightDataFileName], weights: i.weightSpecs }]),
                  (n = {
                    modelTopology: i.modelTopology,
                    format: i.format,
                    generatedBy: i.generatedBy,
                    convertedBy: i.convertedBy,
                    weightsManifest: n,
                  }),
                  (n = window.URL.createObjectURL(new Blob([JSON.stringify(n)], { type: 'application/json' }))),
                  ((r = null == this.jsonAnchor ? document.createElement('a') : this.jsonAnchor).download =
                    this.modelTopologyFileName),
                  (r.href = n),
                  [
                    4,
                    Ch(function () {
                      return r.dispatchEvent(new MouseEvent('click'))
                    }),
                  ]
                )
              case 2:
                return (
                  t.sent(),
                  null == i.weightData
                    ? [3, 4]
                    : (((o = null == this.weightDataAnchor ? document.createElement('a') : this.weightDataAnchor).download =
                        this.weightDataFileName),
                      (o.href = e),
                      [
                        4,
                        Ch(function () {
                          return o.dispatchEvent(new MouseEvent('click'))
                        }),
                      ])
                )
              case 3:
                t.sent(), (t.label = 4)
              case 4:
                return [2, { modelArtifactsInfo: jl(i) }]
            }
          })
        })
      }),
      (Rh.URL_SCHEME = 'downloads://'),
      Rh),
    Sh =
      ((_h.prototype.load = function () {
        return x(this, void 0, void 0, function () {
          var l,
            h,
            p = this
          return w(this, function (t) {
            return (
              (l = this.files[0]),
              (h = this.files.slice(1)),
              [
                2,
                new Promise(function (u, c) {
                  var t = new FileReader()
                  ;(t.onload = function (t) {
                    var r = JSON.parse(t.target.result),
                      o = r.modelTopology
                    if (null != o) {
                      0 === h.length && u({ modelTopology: o })
                      var e,
                        n = r.weightsManifest
                      if (null != n) {
                        try {
                          e = p.checkManifestAndWeightFiles(n, h)
                        } catch (t) {
                          return void c(t)
                        }
                        var i = [],
                          a = [],
                          s = []
                        n.forEach(function (t) {
                          t.paths.forEach(function (t) {
                            a.push(t), s.push(null)
                          }),
                            i.push.apply(i, t.weights)
                        }),
                          n.forEach(function (t) {
                            t.paths.forEach(function (n) {
                              var t = new FileReader()
                              ;(t.onload = function (t) {
                                var e = t.target.result,
                                  t = a.indexOf(n)
                                ;(s[t] = e),
                                  -1 === s.indexOf(null) &&
                                    u({
                                      modelTopology: o,
                                      weightSpecs: i,
                                      weightData: Vl(s),
                                      format: r.format,
                                      generatedBy: r.generatedBy,
                                      convertedBy: r.convertedBy,
                                      userDefinedMetadata: r.userDefinedMetadata,
                                    })
                              }),
                                (t.onerror = function (t) {
                                  return c("Failed to weights data from file of path '" + n + "'.")
                                }),
                                t.readAsArrayBuffer(e[n])
                            })
                          })
                      } else c(new Error('weightManifest field is missing from file ' + l.name))
                    } else c(new Error('modelTopology field is missing from file ' + l.name))
                  }),
                    (t.onerror = function (t) {
                      return c(
                        "Failed to read model topology and weights manifest JSON from file '" +
                          l.name +
                          "'. BrowserFiles supports loading Keras-style tf.Model artifacts only.",
                      )
                    }),
                    t.readAsText(l)
                }),
              ]
            )
          })
        })
      }),
      (_h.prototype.checkManifestAndWeightFiles = function (t, n) {
        for (
          var r = [],
            o = n.map(function (t) {
              return Hl(t.name)
            }),
            i = {},
            e = 0,
            a = t;
          e < a.length;
          e++
        )
          a[e].paths.forEach(function (t) {
            var e = Hl(t)
            if (-1 !== r.indexOf(e)) throw new Error("Duplicate file basename found in weights manifest: '" + e + "'")
            if ((r.push(e), -1 === o.indexOf(e))) throw new Error("Weight file with basename '" + e + "' is not provided.")
            i[t] = n[o.indexOf(e)]
          })
        if (r.length !== n.length)
          throw new Error(
            'Mismatch in the number of files in weights manifest (' +
              r.length +
              ') and the number of weight files provided (' +
              n.length +
              ').',
          )
        return i
      }),
      _h)
  function _h(t) {
    if (null == t || t.length < 1) throw new Error('When calling browserFiles, at least 1 file is required, but received ' + t)
    this.files = t
  }
  function Rh(t) {
    if (!f.getBool('IS_BROWSER'))
      throw new Error('browserDownloads() cannot proceed because the current environment is not a browser.')
    ;(null != (t = t.startsWith(Rh.URL_SCHEME) ? t.slice(Rh.URL_SCHEME.length) : t) && 0 !== t.length) || (t = bh),
      (this.modelTopologyFileName = t + xh),
      (this.weightDataFileName = t + wh)
  }
  function Ih(n, r, o, i) {
    var t, e, a
    A(null != (a = n) && Array.isArray(a) && 0 < a.length, function () {
      return 'promises must be a none empty array'
    }),
      (t = o = null == o ? 0 : o),
      (e = i = null == i ? 1 : i),
      A(0 <= t && t <= 1, function () {
        return 'Progress fraction must be in range [0, 1], but got startFraction ' + t
      }),
      A(0 <= e && e <= 1, function () {
        return 'Progress fraction must be in range [0, 1], but got endFraction ' + e
      }),
      A(t <= e, function () {
        return 'startFraction must be no more than endFraction, but got startFraction ' + t + ' and endFraction ' + e
      })
    var s = 0
    return Promise.all(
      n.map(function (t) {
        return (
          t.then(function (t) {
            var e = o + (++s / n.length) * (i - o)
            return r(e), t
          }),
          t
        )
      }),
    )
  }
  function Ah(l, h) {
    return x(this, void 0, void 0, function () {
      var e, n, r, o, i, a, s, u, c
      return w(this, function (t) {
        switch (t.label) {
          case 0:
            return (
              (e = null == (h = null == h ? {} : h).fetchFunc ? f.platform.fetch : h.fetchFunc),
              (n = l.map(function (t) {
                return e(t, h.requestInit, { isBinary: !0 })
              })),
              (r = 0),
              (o = 0.5),
              null != h.onProgress ? [3, 2] : [4, Promise.all(n)]
            )
          case 1:
            return (i = t.sent()), [3, 4]
          case 2:
            return [4, Ih(n, h.onProgress, r, o)]
          case 3:
            ;(i = t.sent()), (t.label = 4)
          case 4:
            return (
              (a = i.map(function (t) {
                return t.arrayBuffer()
              })),
              (s = 0.5),
              (u = 1),
              null != h.onProgress ? [3, 6] : [4, Promise.all(a)]
            )
          case 5:
            return (c = t.sent()), [3, 8]
          case 6:
            return [4, Ih(a, h.onProgress, s, u)]
          case 7:
            ;(c = t.sent()), (t.label = 8)
          case 8:
            return [2, c]
        }
      })
    })
  }
  function Nh(o) {
    var t = this
    return function (d, r, f) {
      return (
        void 0 === r && (r = ''),
        x(t, void 0, void 0, function () {
          var a, c, s, u, e, n, l, h, p
          return w(this, function (t) {
            switch (t.label) {
              case 0:
                if (
                  ((a = d.map(function () {
                    return !1
                  })),
                  (c = {}),
                  (s =
                    null != f
                      ? f.map(function () {
                          return !1
                        })
                      : []),
                  (u = []),
                  d.forEach(function (t, o) {
                    var i = 0
                    t.weights.forEach(function (n) {
                      function r() {
                        ;(a[o] = !0), null == c[o] && (c[o] = []), c[o].push({ manifestEntry: n, groupOffset: i, sizeBytes: e })
                      }
                      var t = ('quantization' in n ? n.quantization : n).dtype,
                        e = Ll[t] * D(n.shape)
                      null != f
                        ? f.forEach(function (t, e) {
                            t === n.name && (r(), (s[e] = !0))
                          })
                        : r(),
                        u.push(n.name),
                        (i += e)
                    })
                  }),
                  !s.every(function (t) {
                    return t
                  }))
                )
                  throw (
                    ((e = f.filter(function (t, e) {
                      return !s[e]
                    })),
                    new Error(
                      'Could not find weights in manifest with names: ' +
                        e.join(', ') +
                        '. \nManifest JSON has weights with names: ' +
                        u.join(', ') +
                        '.',
                    ))
                  )
                return (
                  (e = a.reduce(function (t, e, n) {
                    return e && t.push(n), t
                  }, [])),
                  (n = []),
                  e.forEach(function (t) {
                    d[t].paths.forEach(function (t) {
                      t = r + (r.endsWith('/') ? '' : '/') + t
                      n.push(t)
                    })
                  }),
                  [4, o(n)]
                )
              case 1:
                return (
                  (l = t.sent()),
                  (h = {}),
                  (p = 0),
                  e.forEach(function (t) {
                    for (var e = d[t].paths.length, n = 0, r = 0; r < e; r++) n += l[p + r].byteLength
                    for (var o = new ArrayBuffer(n), i = new Uint8Array(o), a = 0, s = 0; s < e; s++) {
                      var u = new Uint8Array(l[p + s])
                      i.set(u, a), (a += u.byteLength)
                    }
                    c[t].forEach(function (t) {
                      var e,
                        n = zl(o.slice(t.groupOffset, t.groupOffset + t.sizeBytes), [t.manifestEntry])
                      for (e in n) h[e] = n[e]
                    }),
                      (p += e)
                  }),
                  [2, h]
                )
            }
          })
        })
      )
    }
  }
  ql.registerSaveRouter(function (t) {
    return f.getBool('IS_BROWSER') && !Array.isArray(t) && t.startsWith(Eh.URL_SCHEME)
      ? ((t = t.slice(Eh.URL_SCHEME.length)), new Eh((t = void 0 === t ? 'model' : t)))
      : null
  })
  var kh =
    ((Th.prototype.save = function (r) {
      return x(this, void 0, void 0, function () {
        var e, n
        return w(this, function (t) {
          switch (t.label) {
            case 0:
              if (r.modelTopology instanceof ArrayBuffer)
                throw new Error('BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.')
              return (
                ((n = Object.assign({ method: this.DEFAULT_METHOD }, this.requestInit)).body = new FormData()),
                (e = [{ paths: ['./model.weights.bin'], weights: r.weightSpecs }]),
                (e = {
                  modelTopology: r.modelTopology,
                  format: r.format,
                  generatedBy: r.generatedBy,
                  convertedBy: r.convertedBy,
                  userDefinedMetadata: r.userDefinedMetadata,
                  weightsManifest: e,
                }),
                n.body.append('model.json', new Blob([JSON.stringify(e)], { type: 'application/json' }), 'model.json'),
                null != r.weightData &&
                  n.body.append(
                    'model.weights.bin',
                    new Blob([r.weightData], { type: 'application/octet-stream' }),
                    'model.weights.bin',
                  ),
                [4, this.fetch(this.path, n)]
              )
            case 1:
              if ((n = t.sent()).ok) return [2, { modelArtifactsInfo: jl(r), responses: [n] }]
              throw new Error('BrowserHTTPRequest.save() failed due to HTTP response status ' + n.status + '.')
          }
        })
      })
    }),
    (Th.prototype.load = function () {
      return x(this, void 0, void 0, function () {
        var e, n, r, o, i, a, s, u, c, l
        return w(this, function (t) {
          switch (t.label) {
            case 0:
              return [4, this.fetch(this.path, this.requestInit)]
            case 1:
              if (!(e = t.sent()).ok)
                throw new Error(
                  'Request to ' +
                    this.path +
                    ' failed with status code ' +
                    e.status +
                    '. Please verify this URL points to the model JSON of the model to load.',
                )
              t.label = 2
            case 2:
              return t.trys.push([2, 4, , 5]), [4, e.json()]
            case 3:
              return (n = t.sent()), [3, 5]
            case 4:
              throw (
                (t.sent(),
                (o = 'Failed to parse model JSON of response from ' + this.path + '.'),
                this.path.endsWith('.pb')
                  ? (o +=
                      " Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.")
                  : (o += ' Please make sure the server is serving valid JSON for this request.'),
                new Error(o))
              )
            case 5:
              if (
                ((r = n.modelTopology),
                (o = n.weightsManifest),
                (i = n.generatedBy),
                (a = n.convertedBy),
                (s = n.format),
                (u = n.userDefinedMetadata),
                null == r && null == o)
              )
                throw new Error(
                  'The JSON from HTTP path ' + this.path + ' contains neither model topology or manifest for weights.',
                )
              return null == o ? [3, 7] : [4, this.loadWeights(o)]
            case 6:
              ;(l = t.sent()), (c = l[0]), (l = l[1]), (t.label = 7)
            case 7:
              return [
                2,
                {
                  modelTopology: r,
                  weightSpecs: c,
                  weightData: l,
                  userDefinedMetadata: u,
                  generatedBy: i,
                  convertedBy: a,
                  format: s,
                },
              ]
          }
        })
      })
    }),
    (Th.prototype.loadWeights = function (d) {
      return x(this, void 0, void 0, function () {
        var o, i, a, s, u, c, l, h, p
        return w(this, function (t) {
          switch (t.label) {
            case 0:
              for (
                p = Array.isArray(this.path) ? this.path[1] : this.path,
                  n = (e = p).lastIndexOf('/'),
                  r = e.lastIndexOf('?'),
                  o = [e.substring(0, n) + '/', n < r ? e.substring(r) : ''],
                  p = o[0],
                  i = o[1],
                  a = this.weightPathPrefix || p,
                  s = [],
                  u = 0,
                  c = d;
                u < c.length;
                u++
              )
                (l = c[u]), s.push.apply(s, l.weights)
              return (
                (h = []),
                d.forEach(function (t) {
                  t.paths.forEach(function (t) {
                    h.push(a + t + i)
                  })
                }),
                [4, Ah(h, { requestInit: this.requestInit, fetchFunc: this.fetch, onProgress: this.onProgress })]
              )
            case 1:
              return (p = t.sent()), [2, [s, Vl(p)]]
          }
          var e, n, r
        })
      })
    }),
    (Th.URL_SCHEME_REGEX = /^https?:\/\//),
    Th)
  function Th(t, e) {
    if (
      ((this.DEFAULT_METHOD = 'POST'),
      null == e && (e = {}),
      (this.weightPathPrefix = e.weightPathPrefix),
      (this.onProgress = e.onProgress),
      null != e.fetchFunc
        ? (A('function' == typeof e.fetchFunc, function () {
            return 'Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)'
          }),
          (this.fetch = e.fetchFunc))
        : (this.fetch = f.platform.fetch),
      A(null != t && 0 < t.length, function () {
        return 'URL path for http must not be null, undefined or empty.'
      }),
      Array.isArray(t) &&
        A(2 === t.length, function () {
          return 'URL paths for http must have a length of 2, (actual length is ' + t.length + ').'
        }),
      (this.path = t),
      null != e.requestInit && null != e.requestInit.body)
    )
      throw new Error('requestInit is expected to have no pre-existing body, but has one.')
    this.requestInit = e.requestInit || {}
  }
  function Dh(t) {
    return null != t.match(kh.URL_SCHEME_REGEX)
  }
  al = function (t, e) {
    return 'undefined' != typeof fetch && (Array.isArray(t) ? t.every(Dh) : Dh(t)) ? Oh(t, { onProgress: e }) : null
  }
  function Oh(t, e) {
    return new kh(t, e)
  }
  ql.registerSaveRouter(al), ql.registerLoadRouter(al)
  var Fh =
      ((Bh.prototype.load = function () {
        return x(this, void 0, void 0, function () {
          return w(this, function (t) {
            return [2, this.modelArtifacts]
          })
        })
      }),
      Bh),
    Mh =
      ((Ph.prototype.save = function (e) {
        return x(this, void 0, void 0, function () {
          return w(this, function (t) {
            return [2, this.saveHandler(e)]
          })
        })
      }),
      Ph)
  function Ph(t) {
    this.saveHandler = t
  }
  function Bh(t) {
    this.modelArtifacts = t
  }
  var Lh,
    Wh = Object.freeze({
      browserFiles: function (t) {
        return new Sh(t)
      },
      browserHTTPRequest: Oh,
      concatenateArrayBuffers: Vl,
      decodeWeights: zl,
      encodeWeights: function (s, u) {
        return x(this, void 0, void 0, function () {
          var n,
            r,
            o,
            e,
            i,
            a = this
          return w(this, function (t) {
            switch (t.label) {
              case 0:
                for (
                  n = [],
                    r = [],
                    o = Array.isArray(s)
                      ? s.map(function (t) {
                          return t.name
                        })
                      : Object.keys(s),
                    e = function (t) {
                      var e = o[t],
                        c = Array.isArray(s) ? s[t].tensor : s[e]
                      if ('float32' !== c.dtype && 'int32' !== c.dtype && 'bool' !== c.dtype && 'string' !== c.dtype)
                        throw new Error("Unsupported dtype in weight '" + e + "': " + c.dtype)
                      t = { name: e, shape: c.shape, dtype: c.dtype }
                      'string' === c.dtype
                        ? ((e = new Promise(function (u) {
                            return x(a, void 0, void 0, function () {
                              var e, n, r, o, i, a, s
                              return w(this, function (t) {
                                switch (t.label) {
                                  case 0:
                                    return [4, c.bytes()]
                                  case 1:
                                    for (
                                      e = t.sent(),
                                        n =
                                          e.reduce(function (t, e) {
                                            return t + e.length
                                          }, 0) +
                                          Wl * e.length,
                                        r = new Uint8Array(n),
                                        i = o = 0;
                                      i < e.length;
                                      i++
                                    )
                                      (a = e[i]),
                                        (s = new Uint8Array(new Uint32Array([a.length]).buffer)),
                                        r.set(s, o),
                                        (o += Wl),
                                        r.set(a, o),
                                        (o += a.length)
                                    return u(r), [2]
                                }
                              })
                            })
                          })),
                          r.push(e))
                        : r.push(c.data()),
                        null != u && (t.group = u),
                        n.push(t)
                    },
                    i = 0;
                  i < o.length;
                  ++i
                )
                  e(i)
                return [4, Promise.all(r)]
              case 1:
                return [
                  2,
                  {
                    data: (function (t) {
                      if (null === t) throw new Error('Invalid input value: ' + JSON.stringify(t))
                      var e = 0,
                        n = []
                      t.forEach(function (t) {
                        if (
                          ((e += t.byteLength),
                          n.push(t.byteLength === t.buffer.byteLength ? t : new t.constructor(t)),
                          !(t instanceof Float32Array || t instanceof Int32Array || t instanceof Uint8Array))
                        )
                          throw new Error('Unsupported TypedArray subtype: ' + t.constructor.name)
                      })
                      var r = new Uint8Array(e),
                        o = 0
                      return (
                        n.forEach(function (t) {
                          r.set(new Uint8Array(t.buffer), o), (o += t.byteLength)
                        }),
                        r.buffer
                      )
                    })(t.sent()),
                    specs: n,
                  },
                ]
            }
          })
        })
      },
      fromMemory: function (t, e, n, r) {
        return 1 === arguments.length
          ? null != t.modelTopology || null != t.weightSpecs
            ? new Fh(t)
            : (console.warn(
                'Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release.',
              ),
              new Fh({ modelTopology: t }))
          : (console.warn(
              'Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release.',
            ),
            new Fh({ modelTopology: t, weightSpecs: e, weightData: n, trainingConfig: r }))
      },
      getLoadHandlers: function (t, e) {
        return ql.getLoadHandlers(t, e)
      },
      getModelArtifactsInfoForJSON: jl,
      getSaveHandlers: function (t) {
        return ql.getSaveHandlers(t)
      },
      http: Oh,
      isHTTPScheme: Dh,
      loadWeights: function (e, n, r, o) {
        return (
          void 0 === n && (n = ''),
          x(this, void 0, void 0, function () {
            return w(this, function (t) {
              return [
                2,
                Nh(function (t) {
                  return Ah(t, { requestInit: o })
                })(e, n, r),
              ]
            })
          })
        )
      },
      registerLoadRouter: function (t) {
        return ql.registerLoadRouter(t)
      },
      registerSaveRouter: function (t) {
        return ql.registerSaveRouter(t)
      },
      weightsLoaderFactory: Nh,
      withSaveHandler: function (t) {
        return new Mh(t)
      },
      copyModel: function (e, n) {
        return x(this, void 0, void 0, function () {
          return w(this, function (t) {
            return [2, Ql(e, n, !1)]
          })
        })
      },
      listModels: function () {
        return x(this, void 0, void 0, function () {
          var e, n, r, o, i, a
          return w(this, function (t) {
            switch (t.label) {
              case 0:
                ;(r = Xl.getSchemes()), (e = {}), (n = 0), (r = r), (t.label = 1)
              case 1:
                return n < r.length ? ((o = r[n]), [4, Xl.getManager(o).listModels()]) : [3, 4]
              case 2:
                for (a in (i = t.sent())) e[o + Kl + a] = i[a]
                t.label = 3
              case 3:
                return n++, [3, 1]
              case 4:
                return [2, e]
            }
          })
        })
      },
      moveModel: function (e, n) {
        return x(this, void 0, void 0, function () {
          return w(this, function (t) {
            return [2, Ql(e, n, !0)]
          })
        })
      },
      removeModel: function (n) {
        return x(this, void 0, void 0, function () {
          var e
          return w(this, function (t) {
            return (e = Jl(n)), [2, Xl.getManager(e.scheme).removeModel(e.path)]
          })
        })
      },
    }),
    ul = on({
      confusionMatrix_: function (t, e, n) {
        var r = qe(t, 'labels', 'confusionMatrix'),
          o = qe(e, 'predictions', 'confusionMatrix')
        A(null == n || (0 < n && Number.isInteger(n)), function () {
          return 'If provided, numClasses must be a positive integer, but got ' + n
        }),
          A(1 === r.rank, function () {
            return 'Expected the rank of labels to be 1, but got ' + r.rank
          }),
          A(1 === o.rank, function () {
            return 'Expected the rank of predictions to be 1, but got ' + o.rank
          }),
          A(r.shape[0] === o.shape[0], function () {
            return (
              'Mismatch in the number of examples: ' +
              r.shape[0] +
              ' vs. ' +
              o.shape[0] +
              '. Labels and predictions should have the same number of elements.'
            )
          }),
          A(0 < n && Number.isInteger(n), function () {
            return 'numClasses is required to be a positive integer, but got ' + n
          })
        ;(t = Zn(r.asType('int32'), n)), (e = Zn(o.asType('int32'), n))
        return t.transpose().matMul(e).asType('int32')
      },
    })
  Object.freeze({ confusionMatrix: ul })
  var Br = on({
      fromPixels_: function (t, e) {
        if (4 < (e = void 0 === e ? 3 : e)) throw new Error('Cannot construct Tensor with more than 4 channels from pixels.')
        if (null == t) throw new Error('pixels passed to tf.browser.fromPixels() can not be null')
        var n = !1,
          r = !1,
          o = !1,
          i = !1,
          a = !1
        if (t.data instanceof Uint8Array) n = !0
        else if ('undefined' != typeof ImageData && t instanceof ImageData) r = !0
        else if ('undefined' != typeof HTMLVideoElement && t instanceof HTMLVideoElement) o = !0
        else if ('undefined' != typeof HTMLImageElement && t instanceof HTMLImageElement) i = !0
        else {
          if (null == t.getContext)
            throw new Error(
              'pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ' +
                t.constructor.name,
            )
          a = !0
        }
        if (o && o && t.readyState < 2)
          throw new Error(
            'The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.',
          )
        if (null != g('FromPixels', Pt.backendName)) return Pt.runKernel('FromPixels', { pixels: t }, { numChannels: e })
        var s,
          u = o ? [t.videoWidth, t.videoHeight] : [t.width, t.height],
          c = u[0],
          u = u[1]
        if (
          (a
            ? (s = t.getContext('2d').getImageData(0, 0, c, u).data)
            : r || n
            ? (s = t.data)
            : (i || o) &&
              (((Lh = null == Lh ? document.createElement('canvas').getContext('2d') : Lh).canvas.width = c),
              (Lh.canvas.height = u),
              Lh.drawImage(t, 0, 0, c, u),
              (s = Lh.getImageData(0, 0, c, u).data)),
          4 === e)
        )
          h = new Int32Array(s)
        else
          for (var l = c * u, h = new Int32Array(l * e), p = 0; p < l; p++)
            for (var d = 0; d < e; ++d) h[p * e + d] = s[4 * p + d]
        return fn(h, [u, c, e], 'int32')
      },
    }),
    zh = Object.freeze({
      toPixels: function (y, b) {
        return x(this, void 0, void 0, function () {
          var e, n, r, o, i, a, s, u, c, l, h, p, d, f, v, m, g
          return w(this, function (t) {
            switch (t.label) {
              case 0:
                if (((e = qe(y, 'img', 'toPixels')), 2 !== (e = !(y instanceof bt) ? e.toInt() : e).rank && 3 !== e.rank))
                  throw new Error('toPixels only supports rank 2 or 3 tensors, got rank ' + e.rank + '.')
                if (((m = e.shape.slice(0, 2)), (n = m[0]), (r = m[1]), 4 < (o = 2 === e.rank ? 1 : e.shape[2]) || 2 === o))
                  throw new Error('toPixels only supports depth of size 1, 3 or 4 but got ' + o)
                return [4, e.data()]
              case 1:
                return (i = t.sent()), (a = e.min()), (s = e.max()), [4, Promise.all([a.data(), s.data()])]
              case 2:
                if (
                  ((g = t.sent()),
                  (m = g[0]),
                  (g = g[1]),
                  (m = m[0]),
                  (g = g[0]),
                  a.dispose(),
                  s.dispose(),
                  'float32' === e.dtype)
                ) {
                  if (m < 0 || 1 < g)
                    throw new Error(
                      'Tensor values for a float32 Tensor must be in the range [0 - 1] but got range [' + m + ' - ' + g + '].',
                    )
                } else {
                  if ('int32' !== e.dtype)
                    throw new Error('Unsupported type for toPixels: ' + e.dtype + '. Please use float32 or int32 tensors.')
                  if (m < 0 || 255 < g)
                    throw new Error(
                      'Tensor values for a int32 Tensor must be in the range [0 - 255] but got range [' + m + ' - ' + g + '].',
                    )
                }
                for (u = 'float32' === e.dtype ? 255 : 1, c = new Uint8ClampedArray(r * n * 4), l = 0; l < n * r; ++l)
                  (f = d = p = h = void 0),
                    1 === o
                      ? ((h = i[l] * u), (p = i[l] * u), (d = i[l] * u), (f = 255))
                      : 3 === o
                      ? ((h = i[3 * l] * u), (p = i[3 * l + 1] * u), (d = i[3 * l + 2] * u), (f = 255))
                      : 4 === o && ((h = i[4 * l] * u), (p = i[4 * l + 1] * u), (d = i[4 * l + 2] * u), (f = i[4 * l + 3] * u)),
                    (c[0 + (v = 4 * l)] = Math.round(h)),
                    (c[1 + v] = Math.round(p)),
                    (c[2 + v] = Math.round(d)),
                    (c[3 + v] = Math.round(f))
                return (
                  null != b &&
                    ((b.width = r),
                    (b.height = n),
                    (m = b.getContext('2d')),
                    (g = new ImageData(c, r, n)),
                    m.putImageData(g, 0, 0)),
                  e !== y && e.dispose(),
                  [2, c]
                )
            }
          })
        })
      },
      fromPixels: Br,
    }),
    el =
      ((Vh.prototype.getClassName = function () {
        return this.constructor.className
      }),
      (Vh.fromConfig = function (t, e) {
        return new t(e)
      }),
      Vh),
    Gh =
      ((Uh.getMap = function () {
        return (Uh.instance = null == Uh.instance ? new Uh() : Uh.instance)
      }),
      (Uh.register = function (t) {
        Uh.getMap().classNameMap[t.className] = [t, t.fromConfig]
      }),
      Uh)
  function Uh() {
    this.classNameMap = {}
  }
  function Vh() {}
  function Hh(t) {
    A(null != t.className, function () {
      return 'Class being registered does not have the static className property defined.'
    }),
      A('string' == typeof t.className, function () {
        return 'className is required to be a string, but got type ' + typeof t.className
      }),
      A(0 < t.className.length, function () {
        return 'Class being registered has an empty-string as its className, which is disallowed.'
      }),
      Gh.register(t)
  }
  Object.freeze({ Serializable: el, SerializationMap: Gh, registerClass: Hh })
  function jh() {
    return 32 === Pt.backend.floatPrecision() ? 0.001 : 0.1
  }
  function qh(t, e, n) {
    var r = !0
    if (((z(t) || z(e)) && (r = !1), (r = z(t) && z(e) ? !0 : r))) {
      var o = t.constructor.name,
        i = e.constructor.name
      if (o !== i) throw new Error('Arrays are of different type. Actual: ' + o + '. Expected: ' + i)
    }
    if (Array.isArray(t) && Array.isArray(e)) {
      ;(o = He(t)), (i = He(e))
      if (!S(o, i)) throw new Error('Arrays have different shapes. Actual: [' + o + ']. Expected: [' + i + ']')
    }
    var a = z(t) ? t : E(t),
      s = z(e) ? e : E(e)
    if (a.length !== s.length)
      throw new Error(
        'Arrays have different lengths actual: ' +
          a.length +
          ' vs expected: ' +
          s.length +
          '.\nActual:   ' +
          a +
          '.\nExpected: ' +
          s +
          '.',
      )
    for (var u = 0; u < s.length; ++u) {
      var c = a[u],
        l = s[u]
      if (!n(c, l))
        throw new Error(
          'Arrays differ: actual[' +
            u +
            '] = ' +
            c +
            ', expected[' +
            u +
            '] = ' +
            l +
            '.\nActual:   ' +
            a +
            '.\nExpected: ' +
            s +
            '.',
        )
    }
  }
  function Kh(t, e, n) {
    return (!isFinite(t) && !isFinite(e)) || !(isNaN(t) || isNaN(e) || Math.abs(t - e) > n)
  }
  Object.freeze({
    TEST_EPSILON_FLOAT16: 0.1,
    expectArraysClose: function (t, e, n) {
      return (
        null == n && (n = jh()),
        qh(t, e, function (t, e) {
          return Kh(t, e, n)
        })
      )
    },
    testEpsilon: jh,
    expectPromiseToFail: function (t, e) {
      t().then(
        function () {
          return e.fail()
        },
        function () {
          return e()
        },
      )
    },
    expectArraysEqual: function (t, e) {
      var n = 'string' == typeof e || 'number' == typeof e || 'boolean' == typeof e ? [e] : e
      return V(t) || V(t[0]) || V(e) || V(e[0])
        ? qh(t, n, function (t, e) {
            return t == e
          })
        : qh(t, e, function (t, e) {
            return Kh(t, e, 0)
          })
    },
    expectNumbersClose: function (t, e, n) {
      if (!Kh(t, e, (n = null == n ? jh() : n))) throw new Error('Numbers differ: actual === ' + t + ', expected === ' + e)
    },
    expectValuesInRange: function (t, e, n) {
      for (var r = 0; r < t.length; r++)
        if (t[r] < e || t[r] > n) throw new Error('Value out of range:' + t[r] + ' low: ' + e + ', high: ' + n)
    },
    expectArrayBuffersEqual: function (t, e) {
      expect(new Float32Array(t)).toEqual(new Float32Array(e))
    },
  }),
    Object.freeze({
      gpgpu_util: Vi,
      webgl_util: Le,
      forceHalfFloat: function () {
        f.set('WEBGL_FORCE_F16_TEXTURES', !0)
      },
      MathBackendWebGL: es,
      setWebGLContext: Ht,
      GPGPUContext: Hi,
    })
  var Xh,
    $h,
    Yh,
    Jh,
    Qh,
    nl =
      (n(Zh, (Xh = el)),
      (Zh.prototype.minimize = function (t, e, n) {
        void 0 === e && (e = !1)
        var r = this.computeGradients(t, n),
          t = r.value,
          o = r.grads
        return (
          null != n
            ? ((n = n.map(function (t) {
                return { name: t.name, tensor: o[t.name] }
              })),
              this.applyGradients(n))
            : this.applyGradients(o),
          Ue(o),
          e ? t : (t.dispose(), null)
        )
      }),
      Object.defineProperty(Zh.prototype, 'iterations', {
        get: function () {
          return null == this.iterations_ && (this.iterations_ = 0), this.iterations_
        },
        enumerable: !0,
        configurable: !0,
      }),
      (Zh.prototype.incrementIterations = function () {
        this.iterations_ = this.iterations + 1
      }),
      (Zh.prototype.computeGradients = function (t, e) {
        if (
          (A(K(t), function () {
            return 'The f passed in variableGrads(f) must be a function'
          }),
          A(
            null == e ||
              (Array.isArray(e) &&
                e.every(function (t) {
                  return t instanceof Ct
                })),
            function () {
              return 'The varList passed in variableGrads(f, varList) must be an array of variables'
            },
          ),
          !(r = null != e))
        )
          for (var n in ((e = []), Pt.registeredVariables)) e.push(Pt.registeredVariables[n])
        var r = r
            ? e.filter(function (t) {
                return !t.trainable
              })
            : null,
          o = e.length
        A(
          0 <
            (e = e.filter(function (t) {
              return t.trainable
            })).length,
          function () {
            return (
              'variableGrads() expects at least one of the input variables to be trainable, but none of the ' +
              o +
              ' variables is trainable.'
            )
          },
        )
        var i = (t = Pt.gradients(t, e, null, !0)).value,
          a = t.grads
        A(
          a.some(function (t) {
            return null != t
          }),
          function () {
            return 'Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().'
          },
        ),
          A(0 === i.rank, function () {
            return 'The f passed in variableGrads(f) must return a scalar, but it returned a rank-' + i.rank + ' tensor'
          })
        var s = {}
        return (
          e.forEach(function (t, e) {
            null != a[e] && (s[t.name] = a[e])
          }),
          null != r &&
            r.forEach(function (t) {
              return (s[t.name] = null)
            }),
          { value: i, grads: s }
        )
      }),
      (Zh.prototype.dispose = function () {
        null != this.iterations_ && Ue(this.iterations_)
      }),
      (Zh.prototype.saveIterations = function () {
        return x(this, void 0, void 0, function () {
          return w(this, function (t) {
            return (
              null == this.iterations_ && (this.iterations_ = 0), [2, { name: 'iter', tensor: hn(this.iterations_, 'int32') }]
            )
          })
        })
      }),
      (Zh.prototype.getWeights = function () {
        return x(this, void 0, void 0, function () {
          return w(this, function (t) {
            throw new Error('getWeights() is not implemented for this optimizer yet.')
          })
        })
      }),
      (Zh.prototype.setWeights = function (t) {
        return x(this, void 0, void 0, function () {
          return w(this, function (t) {
            throw new Error('setWeights() is not implemented for this optimizer class ' + this.getClassName())
          })
        })
      }),
      (Zh.prototype.extractIterations = function (n) {
        return x(this, void 0, void 0, function () {
          var e
          return w(this, function (t) {
            switch (t.label) {
              case 0:
                return (e = this), [4, n[0].tensor.data()]
              case 1:
                return (e.iterations_ = t.sent()[0]), [2, n.slice(1)]
            }
          })
        })
      }),
      Zh)
  function Zh() {
    return (null !== Xh && Xh.apply(this, arguments)) || this
  }
  function tp(t, e, n) {
    void 0 === n && (n = null)
    var r = $h.call(this) || this
    return (
      (r.learningRate = t),
      (r.rho = e),
      (r.epsilon = n),
      (r.accumulatedGrads = []),
      (r.accumulatedUpdates = []),
      null == n && (r.epsilon = Pt.backend.epsilon()),
      r
    )
  }
  function ep(t, e) {
    void 0 === e && (e = 0.1)
    var n = Yh.call(this) || this
    return (n.learningRate = t), (n.initialAccumulatorValue = e), (n.accumulatedGrads = []), n
  }
  function np(t, e, n, r) {
    void 0 === r && (r = null)
    var o = Jh.call(this) || this
    return (
      (o.learningRate = t),
      (o.beta1 = e),
      (o.beta2 = n),
      (o.epsilon = r),
      (o.accumulatedFirstMoment = []),
      (o.accumulatedSecondMoment = []),
      Ge(function () {
        ;(o.accBeta1 = hn(e).variable()), (o.accBeta2 = hn(n).variable())
      }),
      null == r && (o.epsilon = Pt.backend.epsilon()),
      o
    )
  }
  function rp(t, e, n, r, o) {
    void 0 === r && (r = null), void 0 === o && (o = 0)
    var i = Qh.call(this) || this
    return (
      (i.learningRate = t),
      (i.beta1 = e),
      (i.beta2 = n),
      (i.epsilon = r),
      (i.decay = o),
      (i.accumulatedFirstMoment = []),
      (i.accumulatedWeightedInfNorm = []),
      Ge(function () {
        ;(i.iteration = hn(0).variable()), (i.accBeta1 = hn(e).variable())
      }),
      null == r && (i.epsilon = Pt.backend.epsilon()),
      i
    )
  }
  Object.defineProperty(nl, Symbol.hasInstance, {
    value: function (t) {
      return null != t.minimize && null != t.computeGradients && null != t.applyGradients
    },
  }),
    Hh(
      (n(tp, ($h = nl)),
      (tp.prototype.applyGradients = function (n) {
        var s = this
        ;(Array.isArray(n)
          ? n.map(function (t) {
              return t.name
            })
          : Object.keys(n)
        ).forEach(function (t, e) {
          var r = Pt.registeredVariables[t]
          null == s.accumulatedGrads[e] &&
            (s.accumulatedGrads[e] = {
              originalName: t + '/accum_grad',
              variable: Ge(function () {
                return wn(r).variable(!1)
              }),
            }),
            null == s.accumulatedUpdates[e] &&
              (s.accumulatedUpdates[e] = {
                originalName: t + '/accum_var',
                variable: Ge(function () {
                  return wn(r).variable(!1)
                }),
              })
          var o,
            i,
            a = Array.isArray(n) ? n[e].tensor : n[t]
          null != a &&
            ((o = s.accumulatedGrads[e].variable),
            (i = s.accumulatedUpdates[e].variable),
            Ge(function () {
              var t = o.mul(s.rho).add(a.square().mul(1 - s.rho)),
                e = i.add(s.epsilon).sqrt().div(o.add(s.epsilon).sqrt()).mul(a),
                n = i.mul(s.rho).add(e.square().mul(1 - s.rho))
              o.assign(t), i.assign(n)
              e = e.mul(-s.learningRate).add(r)
              r.assign(e)
            }))
        }),
          this.incrementIterations()
      }),
      (tp.prototype.dispose = function () {
        null != this.accumulatedUpdates &&
          (Ue(
            this.accumulatedGrads.map(function (t) {
              return t.variable
            }),
          ),
          Ue(
            this.accumulatedUpdates.map(function (t) {
              return t.variable
            }),
          ))
      }),
      (tp.prototype.getWeights = function () {
        return x(this, void 0, void 0, function () {
          var e
          return w(this, function (t) {
            switch (t.label) {
              case 0:
                return (e = this.accumulatedGrads.concat(this.accumulatedUpdates)), [4, this.saveIterations()]
              case 1:
                return [
                  2,
                  [t.sent()].concat(
                    e.map(function (t) {
                      return { name: t.originalName, tensor: t.variable }
                    }),
                  ),
                ]
            }
          })
        })
      }),
      (tp.prototype.setWeights = function (n) {
        return x(this, void 0, void 0, function () {
          var e
          return w(this, function (t) {
            switch (t.label) {
              case 0:
                return [4, this.extractIterations(n)]
              case 1:
                return (
                  (n = t.sent()),
                  (e = n.length / 2),
                  (this.accumulatedGrads = n.slice(0, e).map(function (t) {
                    return { originalName: t.name, variable: t.tensor.variable(!1) }
                  })),
                  (this.accumulatedUpdates = n.slice(e, 2 * e).map(function (t) {
                    return { originalName: t.name, variable: t.tensor.variable(!1) }
                  })),
                  [2]
                )
            }
          })
        })
      }),
      (tp.prototype.getConfig = function () {
        return { learningRate: this.learningRate, rho: this.rho, epsilon: this.epsilon }
      }),
      (tp.fromConfig = function (t, e) {
        return new t(e.learningRate, e.rho, e.epsilon)
      }),
      (tp.className = 'Adadelta'),
      tp),
    ),
    Hh(
      (n(ep, (Yh = nl)),
      (ep.prototype.applyGradients = function (i) {
        var a = this
        ;(Array.isArray(i)
          ? i.map(function (t) {
              return t.name
            })
          : Object.keys(i)
        ).forEach(function (t, e) {
          var n = Pt.registeredVariables[t]
          null == a.accumulatedGrads[e] &&
            (a.accumulatedGrads[e] = {
              originalName: t + '/accumulator',
              variable: Ge(function () {
                return yn(n.shape, a.initialAccumulatorValue).variable(!1)
              }),
            })
          var r,
            o = Array.isArray(i) ? i[e].tensor : i[t]
          null != o &&
            ((r = a.accumulatedGrads[e].variable),
            Ge(function () {
              var t = r.add(o.square())
              r.assign(t)
              t = o.div(t.add(Pt.backend.epsilon()).sqrt()).mul(-a.learningRate).add(n)
              n.assign(t)
            }))
        }),
          this.incrementIterations()
      }),
      (ep.prototype.dispose = function () {
        null != this.accumulatedGrads &&
          Ue(
            this.accumulatedGrads.map(function (t) {
              return t.variable
            }),
          )
      }),
      (ep.prototype.getWeights = function () {
        return x(this, void 0, void 0, function () {
          return w(this, function (t) {
            switch (t.label) {
              case 0:
                return [4, this.saveIterations()]
              case 1:
                return [
                  2,
                  [t.sent()].concat(
                    this.accumulatedGrads.map(function (t) {
                      return { name: t.originalName, tensor: t.variable }
                    }),
                  ),
                ]
            }
          })
        })
      }),
      (ep.prototype.setWeights = function (e) {
        return x(this, void 0, void 0, function () {
          return w(this, function (t) {
            switch (t.label) {
              case 0:
                return [4, this.extractIterations(e)]
              case 1:
                return (
                  (e = t.sent()),
                  (this.accumulatedGrads = e.map(function (t) {
                    return { originalName: t.name, variable: t.tensor.variable(!1) }
                  })),
                  [2]
                )
            }
          })
        })
      }),
      (ep.prototype.getConfig = function () {
        return { learningRate: this.learningRate, initialAccumulatorValue: this.initialAccumulatorValue }
      }),
      (ep.fromConfig = function (t, e) {
        return new t(e.learningRate, e.initialAccumulatorValue)
      }),
      (ep.className = 'Adagrad'),
      ep),
    ),
    Hh(
      (n(np, (Jh = nl)),
      (np.prototype.applyGradients = function (c) {
        var l = this,
          t = Array.isArray(c)
            ? c.map(function (t) {
                return t.name
              })
            : Object.keys(c)
        Ge(function () {
          var s = _u(1, l.accBeta1),
            u = _u(1, l.accBeta2)
          t.forEach(function (t, e) {
            var n = Pt.registeredVariables[t]
            null == l.accumulatedFirstMoment[e] &&
              (l.accumulatedFirstMoment[e] = {
                originalName: t + '/m',
                variable: Ge(function () {
                  return wn(n).variable(!1)
                }),
              }),
              null == l.accumulatedSecondMoment[e] &&
                (l.accumulatedSecondMoment[e] = {
                  originalName: t + '/v',
                  variable: Ge(function () {
                    return wn(n).variable(!1)
                  }),
                })
            var r,
              o,
              i,
              a = Array.isArray(c) ? c[e].tensor : c[t]
            null != a &&
              ((r = l.accumulatedFirstMoment[e].variable),
              (o = l.accumulatedSecondMoment[e].variable),
              (i = r.mul(l.beta1).add(a.mul(1 - l.beta1))),
              (t = o.mul(l.beta2).add(a.square().mul(1 - l.beta2))),
              (e = i.div(s)),
              (a = t.div(u)),
              r.assign(i),
              o.assign(t),
              (a = e.div(a.sqrt().add(l.epsilon)).mul(-l.learningRate).add(n)),
              n.assign(a))
          }),
            l.accBeta1.assign(l.accBeta1.mul(l.beta1)),
            l.accBeta2.assign(l.accBeta2.mul(l.beta2))
        }),
          this.incrementIterations()
      }),
      (np.prototype.dispose = function () {
        this.accBeta1.dispose(),
          this.accBeta2.dispose(),
          null != this.accumulatedFirstMoment &&
            Ue(
              this.accumulatedFirstMoment.map(function (t) {
                return t.variable
              }),
            ),
          null != this.accumulatedSecondMoment &&
            Ue(
              this.accumulatedSecondMoment.map(function (t) {
                return t.variable
              }),
            )
      }),
      (np.prototype.getWeights = function () {
        return x(this, void 0, void 0, function () {
          var e
          return w(this, function (t) {
            switch (t.label) {
              case 0:
                return (e = this.accumulatedFirstMoment.concat(this.accumulatedSecondMoment)), [4, this.saveIterations()]
              case 1:
                return [
                  2,
                  [t.sent()].concat(
                    e.map(function (t) {
                      return { name: t.originalName, tensor: t.variable }
                    }),
                  ),
                ]
            }
          })
        })
      }),
      (np.prototype.setWeights = function (r) {
        return x(this, void 0, void 0, function () {
          var e,
            n = this
          return w(this, function (t) {
            switch (t.label) {
              case 0:
                return [4, this.extractIterations(r)]
              case 1:
                return (
                  (r = t.sent()),
                  Ge(function () {
                    n.accBeta1.assign(Cu(n.beta1, n.iterations_ + 1)), n.accBeta2.assign(Cu(n.beta2, n.iterations_ + 1))
                  }),
                  (e = r.length / 2),
                  (this.accumulatedFirstMoment = r.slice(0, e).map(function (t) {
                    return { originalName: t.name, variable: t.tensor.variable(!1) }
                  })),
                  (this.accumulatedSecondMoment = r.slice(e, 2 * e).map(function (t) {
                    return { originalName: t.name, variable: t.tensor.variable(!1) }
                  })),
                  [2]
                )
            }
          })
        })
      }),
      (np.prototype.getConfig = function () {
        return { learningRate: this.learningRate, beta1: this.beta1, beta2: this.beta2, epsilon: this.epsilon }
      }),
      (np.fromConfig = function (t, e) {
        return new t(e.learningRate, e.beta1, e.beta2, e.epsilon)
      }),
      (np.className = 'Adam'),
      np),
    ),
    Hh(
      (n(rp, (Qh = nl)),
      (rp.prototype.applyGradients = function (u) {
        var c = this,
          t = Array.isArray(u)
            ? u.map(function (t) {
                return t.name
              })
            : Object.keys(u)
        Ge(function () {
          var a = _u(1, c.accBeta1),
            s = lu(-c.learningRate, c.iteration.mul(c.decay).add(1))
          t.forEach(function (t, e) {
            var n = Pt.registeredVariables[t]
            null == c.accumulatedFirstMoment[e] &&
              (c.accumulatedFirstMoment[e] = { originalName: t + '/m', variable: wn(n).variable(!1) }),
              null == c.accumulatedWeightedInfNorm[e] &&
                (c.accumulatedWeightedInfNorm[e] = { originalName: t + '/v', variable: wn(n).variable(!1) })
            var r,
              o,
              i = Array.isArray(u) ? u[e].tensor : u[t]
            null != i &&
              ((r = c.accumulatedFirstMoment[e].variable),
              (o = c.accumulatedWeightedInfNorm[e].variable),
              (t = r.mul(c.beta1).add(i.mul(1 - c.beta1))),
              (e = o.mul(c.beta2)),
              (i = i.abs()),
              (i = e.maximum(i)),
              r.assign(t),
              o.assign(i),
              (i = s
                .div(a)
                .mul(t.div(i.add(c.epsilon)))
                .add(n)),
              n.assign(i))
          }),
            c.iteration.assign(c.iteration.add(1)),
            c.accBeta1.assign(c.accBeta1.mul(c.beta1))
        }),
          this.incrementIterations()
      }),
      (rp.prototype.dispose = function () {
        this.accBeta1.dispose(),
          this.iteration.dispose(),
          null != this.accumulatedFirstMoment &&
            Ue(
              this.accumulatedFirstMoment.map(function (t) {
                return t.variable
              }),
            ),
          null != this.accumulatedWeightedInfNorm &&
            Ue(
              this.accumulatedWeightedInfNorm.map(function (t) {
                return t.variable
              }),
            )
      }),
      (rp.prototype.getWeights = function () {
        return x(this, void 0, void 0, function () {
          return w(this, function (t) {
            throw new Error('getWeights() is not implemented for Adamax yet.')
          })
        })
      }),
      (rp.prototype.setWeights = function (t) {
        return x(this, void 0, void 0, function () {
          return w(this, function (t) {
            throw new Error('setWeights() is not implemented for Adamax yet.')
          })
        })
      }),
      (rp.prototype.getConfig = function () {
        return {
          learningRate: this.learningRate,
          beta1: this.beta1,
          beta2: this.beta2,
          epsilon: this.epsilon,
          decay: this.decay,
        }
      }),
      (rp.fromConfig = function (t, e) {
        return new t(e.learningRate, e.beta1, e.beta2, e.epsilon, e.decay)
      }),
      (rp.className = 'Adamax'),
      rp),
    )
  var op,
    ip,
    ap,
    o =
      (n(sp, (op = nl)),
      (sp.prototype.applyGradients = function (o) {
        var i = this
        ;(Array.isArray(o)
          ? o.map(function (t) {
              return t.name
            })
          : Object.keys(o)
        ).forEach(function (t, e) {
          var n,
            r = Array.isArray(o) ? o[e].tensor : o[t]
          null != r &&
            ((n = Pt.registeredVariables[t]),
            Ge(function () {
              var t = i.c.mul(r).add(n)
              n.assign(t)
            }))
        }),
          this.incrementIterations()
      }),
      (sp.prototype.setLearningRate = function (t) {
        ;(this.learningRate = t), null != this.c && this.c.dispose(), (this.c = ((t = hn(-t)), Pt.keep(t)))
      }),
      (sp.prototype.dispose = function () {
        this.c.dispose()
      }),
      (sp.prototype.getWeights = function () {
        return x(this, void 0, void 0, function () {
          return w(this, function (t) {
            switch (t.label) {
              case 0:
                return [4, this.saveIterations()]
              case 1:
                return [2, [t.sent()]]
            }
          })
        })
      }),
      (sp.prototype.setWeights = function (e) {
        return x(this, void 0, void 0, function () {
          return w(this, function (t) {
            switch (t.label) {
              case 0:
                return [4, this.extractIterations(e)]
              case 1:
                if (0 !== (e = t.sent()).length) throw new Error('SGD optimizer does not have settable weights.')
                return [2]
            }
          })
        })
      }),
      (sp.prototype.getConfig = function () {
        return { learningRate: this.learningRate }
      }),
      (sp.fromConfig = function (t, e) {
        return new t(e.learningRate)
      }),
      (sp.className = 'SGD'),
      sp)
  function sp(t) {
    var e = op.call(this) || this
    return (e.learningRate = t), e.setLearningRate(t), e
  }
  function up(t, e, n) {
    void 0 === n && (n = !1)
    var r = ip.call(this, t) || this
    return (r.learningRate = t), (r.momentum = e), (r.useNesterov = n), (r.accumulations = []), (r.m = hn(r.momentum)), r
  }
  function cp(t, e, n, r, o) {
    void 0 === e && (e = 0.9), void 0 === n && (n = 0), void 0 === r && (r = null), void 0 === o && (o = !1)
    var i = ap.call(this) || this
    if (
      ((i.learningRate = t),
      (i.decay = e),
      (i.momentum = n),
      (i.epsilon = r),
      (i.accumulatedMeanSquares = []),
      (i.accumulatedMoments = []),
      (i.accumulatedMeanGrads = []),
      (i.centered = o),
      null == r && (i.epsilon = Pt.backend.epsilon()),
      null == t)
    )
      throw new Error('learningRate for RMSPropOptimizer must be defined.')
    return i
  }
  Hh(o),
    Hh(
      (n(up, (ip = o)),
      (up.prototype.applyGradients = function (i) {
        var a = this
        ;(Array.isArray(i)
          ? i.map(function (t) {
              return t.name
            })
          : Object.keys(i)
        ).forEach(function (t, e) {
          var n = Pt.registeredVariables[t]
          null == a.accumulations[e] &&
            (a.accumulations[e] = {
              originalName: t + '/momentum',
              variable: Ge(function () {
                return wn(n).variable(!1)
              }),
            })
          var r = a.accumulations[e].variable,
            o = Array.isArray(i) ? i[e].tensor : i[t]
          null != o &&
            Ge(function () {
              var t = a.m.mul(r).add(o),
                e = (a.useNesterov ? a.c.mul(o.add(t.mul(a.m))) : a.c.mul(t)).add(n)
              r.assign(t), n.assign(e)
            })
        }),
          this.incrementIterations()
      }),
      (up.prototype.dispose = function () {
        this.m.dispose(),
          null != this.accumulations &&
            Ue(
              this.accumulations.map(function (t) {
                return t.variable
              }),
            )
      }),
      (up.prototype.setMomentum = function (t) {
        this.momentum = t
      }),
      (up.prototype.getWeights = function () {
        return x(this, void 0, void 0, function () {
          return w(this, function (t) {
            switch (t.label) {
              case 0:
                return [4, this.saveIterations()]
              case 1:
                return [
                  2,
                  [t.sent()].concat(
                    this.accumulations.map(function (t) {
                      return { name: t.originalName, tensor: t.variable }
                    }),
                  ),
                ]
            }
          })
        })
      }),
      (up.prototype.setWeights = function (e) {
        return x(this, void 0, void 0, function () {
          return w(this, function (t) {
            switch (t.label) {
              case 0:
                return [4, this.extractIterations(e)]
              case 1:
                return (
                  (e = t.sent()),
                  (this.accumulations = e.map(function (t) {
                    return { originalName: t.name, variable: t.tensor.variable(!1) }
                  })),
                  [2]
                )
            }
          })
        })
      }),
      (up.prototype.getConfig = function () {
        return { learningRate: this.learningRate, momentum: this.momentum, useNesterov: this.useNesterov }
      }),
      (up.fromConfig = function (t, e) {
        return new t(e.learningRate, e.momentum, e.useNesterov)
      }),
      (up.className = 'Momentum'),
      up),
    ),
    Hh(
      (n(cp, (ap = nl)),
      (cp.prototype.applyGradients = function (e) {
        var c = this
        ;(Array.isArray(e)
          ? e.map(function (t) {
              return t.name
            })
          : Object.keys(e)
        ).forEach(function (t, o) {
          var i = Pt.registeredVariables[t]
          null == c.accumulatedMeanSquares[o] &&
            (c.accumulatedMeanSquares[o] = {
              originalName: t + '/rms',
              variable: Ge(function () {
                return wn(i).variable(!1)
              }),
            }),
            null == c.accumulatedMoments[o] &&
              (c.accumulatedMoments[o] = {
                originalName: t + '/momentum',
                variable: Ge(function () {
                  return wn(i).variable(!1)
                }),
              }),
            null == c.accumulatedMeanGrads[o] &&
              c.centered &&
              (c.accumulatedMeanGrads[o] = {
                originalName: t + '/mg',
                variable: Ge(function () {
                  return wn(i).variable(!1)
                }),
              })
          var a,
            s,
            u = Array.isArray(e) ? e[o].tensor : e[t]
          null != u &&
            ((a = c.accumulatedMeanSquares[o].variable),
            (s = c.accumulatedMoments[o].variable),
            Ge(function () {
              var t,
                e,
                n = a.mul(c.decay).add(u.square().mul(1 - c.decay)),
                r =
                  (c.centered
                    ? ((e = (t = c.accumulatedMeanGrads[o].variable).mul(c.decay).add(u.mul(1 - c.decay))),
                      (r = s.mul(c.momentum).add(u.mul(c.learningRate).div(n.sub(e.square().add(c.epsilon)).sqrt()))),
                      a.assign(n),
                      t.assign(e))
                    : ((e = a.mul(c.decay).add(u.square().mul(1 - c.decay))),
                      (r = s.mul(c.momentum).add(u.mul(c.learningRate).div(e.add(c.epsilon).sqrt()))),
                      a.assign(e)),
                  s.assign(r),
                  i.sub(r))
              i.assign(r)
            }))
        }),
          this.incrementIterations()
      }),
      (cp.prototype.dispose = function () {
        null != this.accumulatedMeanSquares &&
          Ue(
            this.accumulatedMeanSquares.map(function (t) {
              return t.variable
            }),
          ),
          null != this.accumulatedMeanGrads &&
            this.centered &&
            Ue(
              this.accumulatedMeanGrads.map(function (t) {
                return t.variable
              }),
            ),
          null != this.accumulatedMoments &&
            Ue(
              this.accumulatedMoments.map(function (t) {
                return t.variable
              }),
            )
      }),
      (cp.prototype.getWeights = function () {
        return x(this, void 0, void 0, function () {
          var e
          return w(this, function (t) {
            switch (t.label) {
              case 0:
                return (
                  (e = this.accumulatedMeanSquares.concat(this.accumulatedMoments)),
                  this.centered && e.push.apply(e, this.accumulatedMeanGrads),
                  [4, this.saveIterations()]
                )
              case 1:
                return [
                  2,
                  [t.sent()].concat(
                    e.map(function (t) {
                      return { name: t.originalName, tensor: t.variable }
                    }),
                  ),
                ]
            }
          })
        })
      }),
      (cp.prototype.setWeights = function (n) {
        return x(this, void 0, void 0, function () {
          var e
          return w(this, function (t) {
            switch (t.label) {
              case 0:
                return [4, this.extractIterations(n)]
              case 1:
                return (
                  (n = t.sent()),
                  (e = this.centered ? n.length / 3 : n.length / 2),
                  (this.accumulatedMeanSquares = n.slice(0, e).map(function (t) {
                    return { originalName: t.name, variable: t.tensor.variable(!1) }
                  })),
                  (this.accumulatedMoments = n.slice(e, 2 * e).map(function (t) {
                    return { originalName: t.name, variable: t.tensor.variable(!1) }
                  })),
                  this.centered &&
                    (this.accumulatedMeanGrads = n.slice(2 * e, 3 * e).map(function (t) {
                      return { originalName: t.name, variable: t.tensor.variable(!1) }
                    })),
                  [2]
                )
            }
          })
        })
      }),
      (cp.prototype.getConfig = function () {
        return {
          learningRate: this.learningRate,
          decay: this.decay,
          momentum: this.momentum,
          epsilon: this.epsilon,
          centered: this.centered,
        }
      }),
      (cp.fromConfig = function (t, e) {
        return new t(e.learningRate, e.decay, e.momentum, e.epsilon, e.centered)
      }),
      (cp.className = 'RMSProp'),
      cp),
    ),
    (bt.prototype.squaredDifference = function (t) {
      return is(this, t)
    })
  var mt = Zc,
    lp = function (t, e) {
      return (lp =
        Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array &&
          function (t, e) {
            t.__proto__ = e
          }) ||
        function (t, e) {
          for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
        })(t, e)
    }
  function hp(t, e) {
    function n() {
      this.constructor = t
    }
    lp(t, e), (t.prototype = null === e ? Object.create(e) : ((n.prototype = e.prototype), new n()))
  }
  var pp = function () {
    return (pp =
      Object.assign ||
      function (t) {
        for (var e, n = 1, r = arguments.length; n < r; n++)
          for (var o in (e = arguments[n])) Object.prototype.hasOwnProperty.call(e, o) && (t[o] = e[o])
        return t
      }).apply(this, arguments)
  }
  function dp(t, a, s, u) {
    return new (s = s || Promise)(function (n, e) {
      function r(t) {
        try {
          i(u.next(t))
        } catch (t) {
          e(t)
        }
      }
      function o(t) {
        try {
          i(u.throw(t))
        } catch (t) {
          e(t)
        }
      }
      function i(t) {
        var e
        t.done
          ? n(t.value)
          : ((e = t.value) instanceof s
              ? e
              : new s(function (t) {
                  t(e)
                })
            ).then(r, o)
      }
      i((u = u.apply(t, a || [])).next())
    })
  }
  function fp(n, r) {
    var o,
      i,
      a,
      s = {
        label: 0,
        sent: function () {
          if (1 & a[0]) throw a[1]
          return a[1]
        },
        trys: [],
        ops: [],
      },
      t = { next: e(0), throw: e(1), return: e(2) }
    return (
      'function' == typeof Symbol &&
        (t[Symbol.iterator] = function () {
          return this
        }),
      t
    )
    function e(e) {
      return function (t) {
        return (function (e) {
          if (o) throw new TypeError('Generator is already executing.')
          for (; s; )
            try {
              if (
                ((o = 1),
                i &&
                  (a = 2 & e[0] ? i.return : e[0] ? i.throw || ((a = i.return) && a.call(i), 0) : i.next) &&
                  !(a = a.call(i, e[1])).done)
              )
                return a
              switch (((i = 0), (e = a ? [2 & e[0], a.value] : e)[0])) {
                case 0:
                case 1:
                  a = e
                  break
                case 4:
                  return s.label++, { value: e[1], done: !1 }
                case 5:
                  s.label++, (i = e[1]), (e = [0])
                  continue
                case 7:
                  ;(e = s.ops.pop()), s.trys.pop()
                  continue
                default:
                  if (!(a = 0 < (a = s.trys).length && a[a.length - 1]) && (6 === e[0] || 2 === e[0])) {
                    s = 0
                    continue
                  }
                  if (3 === e[0] && (!a || (e[1] > a[0] && e[1] < a[3]))) {
                    s.label = e[1]
                    break
                  }
                  if (6 === e[0] && s.label < a[1]) {
                    ;(s.label = a[1]), (a = e)
                    break
                  }
                  if (a && s.label < a[2]) {
                    ;(s.label = a[2]), s.ops.push(e)
                    break
                  }
                  a[2] && s.ops.pop(), s.trys.pop()
                  continue
              }
              e = r.call(n, s)
            } catch (t) {
              ;(e = [6, t]), (i = 0)
            } finally {
              o = a = 0
            }
          if (5 & e[0]) throw e[1]
          return { value: e[0] ? e[1] : void 0, done: !0 }
        })([e, t])
      }
    }
  }
  function vp() {
    for (var t = 0, e = 0, n = arguments.length; e < n; e++) t += arguments[e].length
    for (var r = Array(t), o = 0, e = 0; e < n; e++)
      for (var i = arguments[e], a = 0, s = i.length; a < s; a++, o++) r[o] = i[a]
    return r
  }
  var mp =
    (Object.defineProperty(gp.prototype, 'width', {
      get: function () {
        return this._width
      },
      enumerable: !0,
      configurable: !0,
    }),
    Object.defineProperty(gp.prototype, 'height', {
      get: function () {
        return this._height
      },
      enumerable: !0,
      configurable: !0,
    }),
    (gp.prototype.reverse = function () {
      return new gp(1 / this.width, 1 / this.height)
    }),
    gp)
  function gp(t, e) {
    if (!_p(t) || !_p(e))
      throw new Error(
        'Dimensions.constructor - expected width and height to be valid numbers, instead have ' +
          JSON.stringify({ width: t, height: e }),
      )
    ;(this._width = t), (this._height = e)
  }
  function yp(t, e) {
    return t instanceof bt && t.shape.length === e
  }
  function bp(t) {
    return yp(t, 3)
  }
  function xp(t) {
    return yp(t, 4)
  }
  function wp(t) {
    return t % 2 == 0
  }
  function Cp(t) {
    return t && t.width && t.height
  }
  function Ep(t) {
    return t
      .reduce(function (t, e) {
        return t.add(e)
      }, new Ip(0, 0))
      .div(new Ip(t.length, t.length))
  }
  function Sp(t, n, r) {
    return Array(t)
      .fill(0)
      .map(function (t, e) {
        return n + e * r
      })
  }
  function _p(t) {
    return (!!t && t !== 1 / 0 && t !== -1 / 0 && !isNaN(t)) || 0 === t
  }
  function Rp(t) {
    return _p(t) && 0 <= t && t <= 1
  }
  var Ip =
    (Object.defineProperty(Ap.prototype, 'x', {
      get: function () {
        return this._x
      },
      enumerable: !0,
      configurable: !0,
    }),
    Object.defineProperty(Ap.prototype, 'y', {
      get: function () {
        return this._y
      },
      enumerable: !0,
      configurable: !0,
    }),
    (Ap.prototype.add = function (t) {
      return new Ap(this.x + t.x, this.y + t.y)
    }),
    (Ap.prototype.sub = function (t) {
      return new Ap(this.x - t.x, this.y - t.y)
    }),
    (Ap.prototype.mul = function (t) {
      return new Ap(this.x * t.x, this.y * t.y)
    }),
    (Ap.prototype.div = function (t) {
      return new Ap(this.x / t.x, this.y / t.y)
    }),
    (Ap.prototype.abs = function () {
      return new Ap(Math.abs(this.x), Math.abs(this.y))
    }),
    (Ap.prototype.magnitude = function () {
      return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2))
    }),
    (Ap.prototype.floor = function () {
      return new Ap(Math.floor(this.x), Math.floor(this.y))
    }),
    Ap)
  function Ap(t, e) {
    ;(this._x = t), (this._y = e)
  }
  var Np =
    ((kp.isRect = function (t) {
      return !!t && [t.x, t.y, t.width, t.height].every(_p)
    }),
    (kp.assertIsValidBox = function (t, e, n) {
      if ((void 0 === n && (n = !1), !kp.isRect(t)))
        throw new Error(e + ' - invalid box: ' + JSON.stringify(t) + ', expected object with properties x, y, width, height')
      if (!n && (t.width < 0 || t.height < 0))
        throw new Error(e + ' - width (' + t.width + ') and height (' + t.height + ') must be positive numbers')
    }),
    Object.defineProperty(kp.prototype, 'x', {
      get: function () {
        return this._x
      },
      enumerable: !0,
      configurable: !0,
    }),
    Object.defineProperty(kp.prototype, 'y', {
      get: function () {
        return this._y
      },
      enumerable: !0,
      configurable: !0,
    }),
    Object.defineProperty(kp.prototype, 'width', {
      get: function () {
        return this._width
      },
      enumerable: !0,
      configurable: !0,
    }),
    Object.defineProperty(kp.prototype, 'height', {
      get: function () {
        return this._height
      },
      enumerable: !0,
      configurable: !0,
    }),
    Object.defineProperty(kp.prototype, 'left', {
      get: function () {
        return this.x
      },
      enumerable: !0,
      configurable: !0,
    }),
    Object.defineProperty(kp.prototype, 'top', {
      get: function () {
        return this.y
      },
      enumerable: !0,
      configurable: !0,
    }),
    Object.defineProperty(kp.prototype, 'right', {
      get: function () {
        return this.x + this.width
      },
      enumerable: !0,
      configurable: !0,
    }),
    Object.defineProperty(kp.prototype, 'bottom', {
      get: function () {
        return this.y + this.height
      },
      enumerable: !0,
      configurable: !0,
    }),
    Object.defineProperty(kp.prototype, 'area', {
      get: function () {
        return this.width * this.height
      },
      enumerable: !0,
      configurable: !0,
    }),
    Object.defineProperty(kp.prototype, 'topLeft', {
      get: function () {
        return new Ip(this.left, this.top)
      },
      enumerable: !0,
      configurable: !0,
    }),
    Object.defineProperty(kp.prototype, 'topRight', {
      get: function () {
        return new Ip(this.right, this.top)
      },
      enumerable: !0,
      configurable: !0,
    }),
    Object.defineProperty(kp.prototype, 'bottomLeft', {
      get: function () {
        return new Ip(this.left, this.bottom)
      },
      enumerable: !0,
      configurable: !0,
    }),
    Object.defineProperty(kp.prototype, 'bottomRight', {
      get: function () {
        return new Ip(this.right, this.bottom)
      },
      enumerable: !0,
      configurable: !0,
    }),
    (kp.prototype.round = function () {
      var t = [this.x, this.y, this.width, this.height].map(function (t) {
        return Math.round(t)
      })
      return new kp({ x: t[0], y: t[1], width: t[2], height: t[3] })
    }),
    (kp.prototype.floor = function () {
      var t = [this.x, this.y, this.width, this.height].map(function (t) {
        return Math.floor(t)
      })
      return new kp({ x: t[0], y: t[1], width: t[2], height: t[3] })
    }),
    (kp.prototype.toSquare = function () {
      var t = this.x,
        e = this.y,
        n = this.width,
        r = this.height,
        o = Math.abs(n - r)
      return n < r && ((t -= o / 2), (n += o)), r < n && ((e -= o / 2), (r += o)), new kp({ x: t, y: e, width: n, height: r })
    }),
    (kp.prototype.rescale = function (t) {
      var e = Cp(t) ? t.width : t,
        t = Cp(t) ? t.height : t
      return new kp({ x: this.x * e, y: this.y * t, width: this.width * e, height: this.height * t })
    }),
    (kp.prototype.pad = function (t, e) {
      e = [this.x - t / 2, this.y - e / 2, this.width + t, this.height + e]
      return new kp({ x: e[0], y: e[1], width: e[2], height: e[3] })
    }),
    (kp.prototype.clipAtImageBorders = function (t, e) {
      var n = this.x,
        r = this.y,
        o = this.right,
        i = this.bottom,
        n = Math.max(n, 0),
        r = Math.max(r, 0),
        o = o - n,
        i = i - r
      return new kp({ x: n, y: r, width: Math.min(o, t - n), height: Math.min(i, e - r) }).floor()
    }),
    (kp.prototype.shift = function (t, e) {
      var n = this.width,
        r = this.height
      return new kp({ x: this.x + t, y: this.y + e, width: n, height: r })
    }),
    (kp.prototype.padAtBorders = function (t, e) {
      var n = this.width + 1,
        r = this.height + 1,
        o = n,
        i = r,
        a = this.left,
        s = this.top,
        u = this.right,
        c = this.bottom
      return (
        e < u && ((o = -u + e + n), (u = e)),
        t < c && ((i = -c + t + r), (c = t)),
        a < 1 && ((i = 2 - a), (a = 1)),
        s < 1 && ((i = 2 - s), (s = 1)),
        { dy: 1, edy: i, dx: 1, edx: o, y: s, ey: c, x: a, ex: u, w: n, h: r }
      )
    }),
    (kp.prototype.calibrate = function (t) {
      return new kp({
        left: this.left + t.left * this.width,
        top: this.top + t.top * this.height,
        right: this.right + t.right * this.width,
        bottom: this.bottom + t.bottom * this.height,
      })
        .toSquare()
        .round()
    }),
    kp)
  function kp(t, e) {
    void 0 === e && (e = !0)
    var n = t || {},
      r = [n.left, n.top, n.right, n.bottom].every(_p),
      o = [n.x, n.y, n.width, n.height].every(_p)
    if (!o && !r)
      throw new Error('Box.constructor - expected box to be IBoundingBox | IRect, instead have ' + JSON.stringify(n))
    ;(t = o ? [n.x, n.y, n.width, n.height] : [n.left, n.top, n.right - n.left, n.bottom - n.top]),
      (r = t[0]),
      (o = t[1]),
      (n = t[2]),
      (t = t[3])
    kp.assertIsValidBox({ x: r, y: o, width: n, height: t }, 'Box.constructor', e),
      (this._x = r),
      (this._y = o),
      (this._width = n),
      (this._height = t)
  }
  var Tp,
    Dp = (hp(Op, (Tp = Np)), Op)
  function Op(t, e, n, r, o) {
    return void 0 === o && (o = !1), Tp.call(this, { left: t, top: e, right: n, bottom: r }, o) || this
  }
  var Fp =
    (Object.defineProperty(Mp.prototype, 'score', {
      get: function () {
        return this._score
      },
      enumerable: !0,
      configurable: !0,
    }),
    Object.defineProperty(Mp.prototype, 'classScore', {
      get: function () {
        return this._classScore
      },
      enumerable: !0,
      configurable: !0,
    }),
    Object.defineProperty(Mp.prototype, 'className', {
      get: function () {
        return this._className
      },
      enumerable: !0,
      configurable: !0,
    }),
    Object.defineProperty(Mp.prototype, 'box', {
      get: function () {
        return this._box
      },
      enumerable: !0,
      configurable: !0,
    }),
    Object.defineProperty(Mp.prototype, 'imageDims', {
      get: function () {
        return this._imageDims
      },
      enumerable: !0,
      configurable: !0,
    }),
    Object.defineProperty(Mp.prototype, 'imageWidth', {
      get: function () {
        return this.imageDims.width
      },
      enumerable: !0,
      configurable: !0,
    }),
    Object.defineProperty(Mp.prototype, 'imageHeight', {
      get: function () {
        return this.imageDims.height
      },
      enumerable: !0,
      configurable: !0,
    }),
    Object.defineProperty(Mp.prototype, 'relativeBox', {
      get: function () {
        return new Np(this._box).rescale(this.imageDims.reverse())
      },
      enumerable: !0,
      configurable: !0,
    }),
    (Mp.prototype.forSize = function (t, e) {
      return new Mp(this.score, this.classScore, this.className, this.relativeBox, { width: t, height: e })
    }),
    Mp)
  function Mp(t, e, n, r, o) {
    ;(this._imageDims = new mp(o.width, o.height)),
      (this._score = t),
      (this._classScore = e),
      (this._className = n),
      (this._box = new Np(r).rescale(this._imageDims))
  }
  var Pp,
    Bp =
      (hp(Lp, (Pp = Fp)),
      (Lp.prototype.forSize = function (t, e) {
        e = Pp.prototype.forSize.call(this, t, e)
        return new Lp(e.score, e.relativeBox, e.imageDims)
      }),
      Lp)
  function Lp(t, e, n) {
    return Pp.call(this, t, t, '', e, n) || this
  }
  function Wp(a, t, s, u) {
    void 0 === u && (u = !0)
    for (
      var c = t
          .map(function (t, e) {
            return { score: t, boxIndex: e }
          })
          .sort(function (t, e) {
            return t.score - e.score
          })
          .map(function (t) {
            return t.boxIndex
          }),
        l = [],
        e = function () {
          var t = c.pop()
          l.push(t)
          for (var e = c, n = [], r = 0; r < e.length; r++) {
            var o = e[r],
              i = a[t],
              o = a[o]
            n.push(
              (function (t, e, n) {
                void 0 === n && (n = !0)
                var r =
                  Math.max(0, Math.min(t.right, e.right) - Math.max(t.left, e.left)) *
                  Math.max(0, Math.min(t.bottom, e.bottom) - Math.max(t.top, e.top))
                return n ? r / (t.area + e.area - r) : r / Math.min(t.area, e.area)
              })(i, o, u),
            )
          }
          c = c.filter(function (t, e) {
            return n[e] <= s
          })
        };
      0 < c.length;

    )
      e()
    return l
  }
  function zp(r, o) {
    return Ge(function () {
      var t = o[0],
        e = o[1],
        n = o[2],
        t = yn(vp(r.shape.slice(0, 3), [1]), t),
        e = yn(vp(r.shape.slice(0, 3), [1]), e),
        n = yn(vp(r.shape.slice(0, 3), [1]), n),
        n = Cn([t, e, n], 3)
      return _u(r, n)
    })
  }
  function Gp(t) {
    return 1 / (1 + Math.exp(-t))
  }
  var Up,
    Vp = (hp(Hp, (Up = Np)), Hp)
  function Hp(t, e, n, r, o) {
    return void 0 === o && (o = !1), Up.call(this, { x: t, y: e, width: n, height: r }, o) || this
  }
  var jp =
    (Object.defineProperty(qp.prototype, 'shift', {
      get: function () {
        return new Ip(this._shift.x, this._shift.y)
      },
      enumerable: !0,
      configurable: !0,
    }),
    Object.defineProperty(qp.prototype, 'imageWidth', {
      get: function () {
        return this._imgDims.width
      },
      enumerable: !0,
      configurable: !0,
    }),
    Object.defineProperty(qp.prototype, 'imageHeight', {
      get: function () {
        return this._imgDims.height
      },
      enumerable: !0,
      configurable: !0,
    }),
    Object.defineProperty(qp.prototype, 'positions', {
      get: function () {
        return this._positions
      },
      enumerable: !0,
      configurable: !0,
    }),
    Object.defineProperty(qp.prototype, 'relativePositions', {
      get: function () {
        var e = this
        return this._positions.map(function (t) {
          return t.sub(e._shift).div(new Ip(e.imageWidth, e.imageHeight))
        })
      },
      enumerable: !0,
      configurable: !0,
    }),
    (qp.prototype.forSize = function (t, e) {
      return new this.constructor(this.relativePositions, { width: t, height: e })
    }),
    (qp.prototype.shiftBy = function (t, e) {
      return new this.constructor(this.relativePositions, this._imgDims, new Ip(t, e))
    }),
    (qp.prototype.shiftByPoint = function (t) {
      return this.shiftBy(t.x, t.y)
    }),
    (qp.prototype.align = function (t, e) {
      if ((void 0 === e && (e = {}), t)) {
        var n = t instanceof Bp ? t.box.floor() : new Np(t)
        return this.shiftBy(n.x, n.y).align(null, e)
      }
      ;(n = Object.assign({}, { useDlibAlignment: !1, minBoxPadding: 0.2 }, e)), (e = n.useDlibAlignment), (n = n.minBoxPadding)
      return e ? this.alignDlib() : this.alignMinBbox(n)
    }),
    (qp.prototype.alignDlib = function () {
      var t = this.getRefPointsForAlignment(),
        e = t[0],
        n = t[1],
        r = t[2],
        o = function (t) {
          return r.sub(t).magnitude()
        },
        o = (o(e) + o(n)) / 2,
        n = Math.floor(o / 0.45),
        o = Ep(t),
        t = Math.floor(Math.max(0, o.x - 0.5 * n)),
        o = Math.floor(Math.max(0, o.y - 0.43 * n))
      return new Vp(t, o, Math.min(n, this.imageWidth + t), Math.min(n, this.imageHeight + o))
    }),
    (qp.prototype.alignMinBbox = function (t) {
      var e,
        n,
        r,
        o,
        r =
          ((e = this.positions),
          (n = e.map(function (t) {
            return t.x
          })),
          (r = e.map(function (t) {
            return t.y
          })),
          (o = n.reduce(function (t, e) {
            return e < t ? e : t
          }, 1 / 0)),
          (e = r.reduce(function (t, e) {
            return e < t ? e : t
          }, 1 / 0)),
          (n = n.reduce(function (t, e) {
            return t < e ? e : t
          }, 0)),
          (r = r.reduce(function (t, e) {
            return t < e ? e : t
          }, 0)),
          new Dp(o, e, n, r))
      return r.pad(r.width * t, r.height * t)
    }),
    (qp.prototype.getRefPointsForAlignment = function () {
      throw new Error('getRefPointsForAlignment not implemented by base class')
    }),
    qp)
  function qp(t, e, n) {
    void 0 === n && (n = new Ip(0, 0))
    var r = e.width,
      o = e.height
    ;(this._imgDims = new mp(r, o)),
      (this._shift = n),
      (this._positions = t.map(function (t) {
        return t.mul(new Ip(r, o)).add(n)
      }))
  }
  var Kp,
    Xp =
      (hp($p, (Kp = jp)),
      ($p.prototype.getRefPointsForAlignment = function () {
        var t = this.positions
        return [t[0], t[1], Ep([t[3], t[4]])]
      }),
      $p)
  function $p() {
    return (null !== Kp && Kp.apply(this, arguments)) || this
  }
  var Yp,
    Jp =
      (hp(Qp, (Yp = jp)),
      (Qp.prototype.getJawOutline = function () {
        return this.positions.slice(0, 17)
      }),
      (Qp.prototype.getLeftEyeBrow = function () {
        return this.positions.slice(17, 22)
      }),
      (Qp.prototype.getRightEyeBrow = function () {
        return this.positions.slice(22, 27)
      }),
      (Qp.prototype.getNose = function () {
        return this.positions.slice(27, 36)
      }),
      (Qp.prototype.getLeftEye = function () {
        return this.positions.slice(36, 42)
      }),
      (Qp.prototype.getRightEye = function () {
        return this.positions.slice(42, 48)
      }),
      (Qp.prototype.getMouth = function () {
        return this.positions.slice(48, 68)
      }),
      (Qp.prototype.getRefPointsForAlignment = function () {
        return [this.getLeftEye(), this.getRightEye(), this.getMouth()].map(Ep)
      }),
      Qp)
  function Qp() {
    return (null !== Yp && Yp.apply(this, arguments)) || this
  }
  var Zp =
    (Object.defineProperty(td.prototype, 'label', {
      get: function () {
        return this._label
      },
      enumerable: !0,
      configurable: !0,
    }),
    Object.defineProperty(td.prototype, 'distance', {
      get: function () {
        return this._distance
      },
      enumerable: !0,
      configurable: !0,
    }),
    (td.prototype.toString = function (t) {
      return (
        void 0 === t && (t = !0),
        this.label +
          (t ? ' (' + ((t = this.distance), void 0 === e && (e = 2), (e = Math.pow(10, e)), Math.floor(t * e) / e) + ')' : '')
      )
      var e
    }),
    td)
  function td(t, e) {
    ;(this._label = t), (this._distance = e)
  }
  var ed,
    nd =
      (hp(rd, (ed = Np)),
      (rd.assertIsValidLabeledBox = function (t, e) {
        if ((Np.assertIsValidBox(t, e), !_p(t.label)))
          throw new Error(e + ' - expected property label (' + t.label + ') to be a number')
      }),
      Object.defineProperty(rd.prototype, 'label', {
        get: function () {
          return this._label
        },
        enumerable: !0,
        configurable: !0,
      }),
      rd)
  function rd(t, e) {
    t = ed.call(this, t) || this
    return (t._label = e), t
  }
  var od,
    id,
    ad =
      (Object.defineProperty(sd.prototype, 'label', {
        get: function () {
          return this._label
        },
        enumerable: !0,
        configurable: !0,
      }),
      Object.defineProperty(sd.prototype, 'descriptors', {
        get: function () {
          return this._descriptors
        },
        enumerable: !0,
        configurable: !0,
      }),
      (sd.prototype.toJSON = function () {
        return {
          label: this.label,
          descriptors: this.descriptors.map(function (t) {
            return Array.from(t)
          }),
        }
      }),
      (sd.fromJSON = function (t) {
        var e = t.descriptors.map(function (t) {
          return new Float32Array(t)
        })
        return new sd(t.label, e)
      }),
      sd)
  function sd(t, e) {
    if ('string' != typeof t) throw new Error('LabeledFaceDescriptors - constructor expected label to be a string')
    if (
      !Array.isArray(e) ||
      e.some(function (t) {
        return !(t instanceof Float32Array)
      })
    )
      throw new Error('LabeledFaceDescriptors - constructor expected descriptors to be an array of Float32Array')
    ;(this._label = t), (this._descriptors = e)
  }
  function ud(t, e, n, r) {
    e = od.call(this, t, e) || this
    return (e._score = n), (e._classScore = r), e
  }
  function cd(t) {
    return t.detection instanceof Bp
  }
  function ld(t, e) {
    e = { detection: e }
    return Object.assign({}, t, e)
  }
  function hd() {
    var t =
      window.fetch ||
      function () {
        throw new Error('fetch - missing fetch implementation for browser environment')
      }
    return {
      Canvas: HTMLCanvasElement,
      CanvasRenderingContext2D: CanvasRenderingContext2D,
      Image: HTMLImageElement,
      ImageData: ImageData,
      Video: HTMLVideoElement,
      createCanvasElement: function () {
        return document.createElement('canvas')
      },
      createImageElement: function () {
        return document.createElement('img')
      },
      fetch: t,
      readFile: function () {
        throw new Error('readFile - filesystem not available for browser environment')
      },
    }
  }
  function pd(e) {
    var n = ''
    if (!e)
      try {
        e = require('fs')
      } catch (t) {
        n = t.toString()
      }
    return {
      readFile: e
        ? function (t) {
            return new Promise(function (n, r) {
              e.readFile(t, function (t, e) {
                return t ? r(t) : n(e)
              })
            })
          }
        : function () {
            throw new Error('readFile - failed to require fs in nodejs environment with error: ' + n)
          },
    }
  }
  function dd() {
    var t = global.Canvas || global.HTMLCanvasElement,
      e = global.Image || global.HTMLImageElement,
      n =
        global.fetch ||
        function () {
          throw new Error('fetch - missing fetch implementation for nodejs environment')
        },
      r = pd()
    return pp(
      {
        Canvas: t || function () {},
        CanvasRenderingContext2D: global.CanvasRenderingContext2D || function () {},
        Image: e || function () {},
        ImageData: global.ImageData || function () {},
        Video: global.HTMLVideoElement || function () {},
        createCanvasElement: function () {
          if (t) return new t()
          throw new Error('createCanvasElement - missing Canvas implementation for nodejs environment')
        },
        createImageElement: function () {
          if (e) return new e()
          throw new Error('createImageElement - missing Image implementation for nodejs environment')
        },
        fetch: n,
      },
      r,
    )
  }
  function fd() {
    return (
      'object' == typeof window &&
      'undefined' != typeof document &&
      'undefined' != typeof HTMLImageElement &&
      'undefined' != typeof HTMLCanvasElement &&
      'undefined' != typeof HTMLVideoElement &&
      'undefined' != typeof ImageData &&
      'undefined' != typeof CanvasRenderingContext2D
    )
  }
  function vd() {
    return (
      'object' == typeof global &&
      'function' == typeof require &&
      'undefined' != typeof module &&
      'undefined' != typeof process &&
      !!process.version
    )
  }
  function md(t) {
    id = t
  }
  function gd() {
    fd() && md(hd()), vd() && md(dd())
  }
  hp(ud, (od = nd)),
    (ud.assertIsValidPredictedBox = function (t, e) {
      if ((nd.assertIsValidLabeledBox(t, e), !Rp(t.score) || !Rp(t.classScore)))
        throw new Error(
          e + ' - expected properties score (' + t.score + ') and (' + t.classScore + ') to be a number between [0, 1]',
        )
    }),
    Object.defineProperty(ud.prototype, 'score', {
      get: function () {
        return this._score
      },
      enumerable: !0,
      configurable: !0,
    }),
    Object.defineProperty(ud.prototype, 'classScore', {
      get: function () {
        return this._classScore
      },
      enumerable: !0,
      configurable: !0,
    })
  var yd = {
    getEnv: function () {
      if (!id) throw new Error('getEnv - environment is not defined, check isNodejs() and isBrowser()')
      return id
    },
    setEnv: md,
    initialize: gd,
    createBrowserEnv: hd,
    createFileSystem: pd,
    createNodejsEnv: dd,
    monkeyPatch: function (t) {
      if ((id || gd(), !id)) throw new Error('monkeyPatch - environment is not defined, check isNodejs() and isBrowser()')
      var e = t.Canvas,
        n = void 0 === e ? id.Canvas : e,
        r = void 0 === (e = t.Image) ? id.Image : e
      ;(id.Canvas = n),
        (id.Image = r),
        (id.createCanvasElement =
          t.createCanvasElement ||
          function () {
            return new n()
          }),
        (id.createImageElement =
          t.createImageElement ||
          function () {
            return new r()
          }),
        (id.ImageData = t.ImageData || id.ImageData),
        (id.Video = t.Video || id.Video),
        (id.fetch = t.fetch || id.fetch),
        (id.readFile = t.readFile || id.readFile)
    },
    isBrowser: fd,
    isNodejs: vd,
  }
  function bd(t) {
    return yd.isNodejs() || 'string' != typeof t ? t : document.getElementById(t)
  }
  function xd(t) {
    var e = yd.getEnv(),
      n = e.Canvas
    if (t instanceof e.CanvasRenderingContext2D) return t
    t = bd(t)
    if (!(t instanceof n)) throw new Error('resolveContext2d - expected canvas to be of instance of Canvas')
    t = t.getContext('2d')
    if (!t) throw new Error('resolveContext2d - canvas 2d context is null')
    return t
  }
  function wd(t) {
    var e = yd.getEnv(),
      n = e.Image,
      e = e.Video
    return (t instanceof n && t.complete) || (t instanceof e && 3 <= t.readyState)
  }
  function Cd(t) {
    var e = yd.getEnv(),
      n = e.Image,
      e = e.Video
    return t instanceof n
      ? new mp(t.naturalWidth, t.naturalHeight)
      : t instanceof e
      ? new mp(t.videoWidth, t.videoHeight)
      : new mp(t.width, t.height)
  }
  function Ed(t) {
    var e = t.width,
      n = t.height,
      t = (0, yd.getEnv().createCanvasElement)()
    return (t.width = e), (t.height = n), t
  }
  function Sd(t, e) {
    var n = yd.getEnv().ImageData
    if (!(t instanceof n || wd(t))) throw new Error('createCanvasFromMedia - media has not finished loading yet')
    var r = e || Cd(t),
      o = r.width,
      e = r.height,
      r = Ed({ width: o, height: e })
    return t instanceof n ? xd(r).putImageData(t, 0, 0) : xd(r).drawImage(t, 0, 0, o, e), r
  }
  function _d(t) {
    var e = yd.getEnv(),
      n = e.Image,
      r = e.Canvas,
      e = e.Video
    return t instanceof n || t instanceof r || t instanceof e
  }
  gd(),
    ((Dt = {}).TOP_LEFT = 'TOP_LEFT'),
    (Dt.TOP_RIGHT = 'TOP_RIGHT'),
    (Dt.BOTTOM_LEFT = 'BOTTOM_LEFT'),
    (Dt.BOTTOM_RIGHT = 'BOTTOM_RIGHT')
  var Rd =
    (Object.defineProperty(Id.prototype, 'imageTensors', {
      get: function () {
        return this._imageTensors
      },
      enumerable: !0,
      configurable: !0,
    }),
    Object.defineProperty(Id.prototype, 'canvases', {
      get: function () {
        return this._canvases
      },
      enumerable: !0,
      configurable: !0,
    }),
    Object.defineProperty(Id.prototype, 'isBatchInput', {
      get: function () {
        return 1 < this.batchSize || this._treatAsBatchInput
      },
      enumerable: !0,
      configurable: !0,
    }),
    Object.defineProperty(Id.prototype, 'batchSize', {
      get: function () {
        return this._batchSize
      },
      enumerable: !0,
      configurable: !0,
    }),
    Object.defineProperty(Id.prototype, 'inputDimensions', {
      get: function () {
        return this._inputDimensions
      },
      enumerable: !0,
      configurable: !0,
    }),
    Object.defineProperty(Id.prototype, 'inputSize', {
      get: function () {
        return this._inputSize
      },
      enumerable: !0,
      configurable: !0,
    }),
    Object.defineProperty(Id.prototype, 'reshapedInputDimensions', {
      get: function () {
        var n = this
        return Sp(this.batchSize, 0, 1).map(function (t, e) {
          return n.getReshapedInputDimensions(e)
        })
      },
      enumerable: !0,
      configurable: !0,
    }),
    (Id.prototype.getInput = function (t) {
      return this.canvases[t] || this.imageTensors[t]
    }),
    (Id.prototype.getInputDimensions = function (t) {
      return this._inputDimensions[t]
    }),
    (Id.prototype.getInputHeight = function (t) {
      return this._inputDimensions[t][0]
    }),
    (Id.prototype.getInputWidth = function (t) {
      return this._inputDimensions[t][1]
    }),
    (Id.prototype.getReshapedInputDimensions = function (t) {
      if ('number' != typeof this.inputSize)
        throw new Error('getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet')
      var e = this.getInputWidth(t),
        n = this.getInputHeight(t)
      return (
        (t = { width: e, height: n }),
        (e = this.inputSize),
        (n = t.width),
        (t = t.height),
        (e /= Math.max(t, n)),
        new mp(Math.round(n * e), Math.round(t * e))
      )
    }),
    (Id.prototype.toBatchTensor = function (r, o) {
      var s = this
      return (
        void 0 === o && (o = !0),
        (this._inputSize = r),
        Ge(function () {
          var t = Sp(s.batchSize, 0, 1).map(function (t) {
            var i,
              a,
              e = s.getInput(t)
            if (e instanceof bt) {
              var n = xp(e) ? e : e.expandDims()
              return (
                (i = n),
                void 0 === (a = o) && (a = !1),
                (n =
                  (n = Ge(function () {
                    var t = i.shape.slice(1),
                      e = t[0],
                      n = t[1]
                    if (e === n) return i
                    var r = Math.abs(e - n),
                      t = Math.round(r * (a ? 0.5 : 1)),
                      o = n < e ? 2 : 1,
                      e = function (t) {
                        var e = i.shape.slice()
                        return (e[o] = t), yn(e, 0)
                      },
                      t = e(t),
                      r = r - t.shape[o],
                      t = [a && r ? e(r) : null, i, t]
                        .filter(function (t) {
                          return !!t
                        })
                        .map(function (t) {
                          return t.toFloat()
                        })
                    return Cn(t, o)
                  })).shape[1] !== r || n.shape[2] !== r
                    ? yl.resizeBilinear(n, [r, r])
                    : n).as3D(r, r, 3)
              )
            }
            if (e instanceof yd.getEnv().Canvas)
              return zh.fromPixels(
                (function (t, e, n) {
                  void 0 === n && (n = !1)
                  var r = (a = yd.getEnv()).Image,
                    o = a.Canvas
                  if (!(t instanceof r || t instanceof o))
                    throw new Error('imageToSquare - expected arg0 to be HTMLImageElement | HTMLCanvasElement')
                  var i = Cd(t),
                    r = (a = e / Math.max(i.height, i.width)) * i.width,
                    a = a * i.height,
                    i = Ed({ width: e, height: e }),
                    e = t instanceof o ? t : Sd(t),
                    o = Math.abs(r - a) / 2,
                    t = n && r < a ? o : 0,
                    o = n && a < r ? o : 0
                  return xd(i).drawImage(e, t, o, r, a), i
                })(e, r, o),
              )
            throw new Error(
              'toBatchTensor - at batchIdx ' +
                t +
                ', expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have ' +
                e,
            )
          })
          return pr(
            t.map(function (t) {
              return t.toFloat()
            }),
          ).as4D(s.batchSize, r, r, 3)
        })
      )
    }),
    Id)
  function Id(t, e) {
    var r = this
    if (
      (void 0 === e && (e = !1),
      (this._imageTensors = []),
      (this._canvases = []),
      (this._treatAsBatchInput = !1),
      (this._inputDimensions = []),
      !Array.isArray(t))
    )
      throw new Error(
        'NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have ' +
          t,
      )
    ;(this._treatAsBatchInput = e),
      (this._batchSize = t.length),
      t.forEach(function (t, e) {
        if (bp(t)) return (r._imageTensors[e] = t), void (r._inputDimensions[e] = t.shape)
        if (xp(t)) {
          var n = t.shape[0]
          if (1 !== n)
            throw new Error('NetInput - tf.Tensor4D with batchSize ' + n + ' passed, but not supported in input array')
          return (r._imageTensors[e] = t), void (r._inputDimensions[e] = t.shape.slice(1))
        }
        t = t instanceof yd.getEnv().Canvas ? t : Sd(t)
        ;(r._canvases[e] = t), (r._inputDimensions[e] = [t.height, t.width, 3])
      })
  }
  function Ad(o) {
    return dp(this, void 0, void 0, function () {
      var n, r, e
      return fp(this, function (t) {
        switch (t.label) {
          case 0:
            if (o instanceof Rd) return [2, o]
            if (!(n = Array.isArray(o) ? o : [o]).length) throw new Error('toNetInput - empty array passed as input')
            return (
              (r = function (t) {
                return Array.isArray(o) ? ' at input index ' + t + ':' : ''
              }),
              (e = n.map(bd)).forEach(function (t, e) {
                if (!_d(t) && !bp(t) && !xp(t)) {
                  if ('string' == typeof n[e])
                    throw new Error(
                      'toNetInput -' + r(e) + ' string passed, but could not resolve HTMLElement for element id ' + n[e],
                    )
                  throw new Error(
                    'toNetInput -' +
                      r(e) +
                      ' expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id',
                  )
                }
                if (xp(t)) {
                  t = t.shape[0]
                  if (1 !== t)
                    throw new Error(
                      'toNetInput -' + r(e) + ' tf.Tensor4D with batchSize ' + t + ' passed, but not supported in input array',
                    )
                }
              }),
              [
                4,
                Promise.all(
                  e.map(function (t) {
                    return (
                      _d(t) &&
                      ((i = t),
                      new Promise(function (e, n) {
                        if (i instanceof yd.getEnv().Canvas || wd(i)) return e()
                        function r(t) {
                          t.currentTarget &&
                            (t.currentTarget.removeEventListener('load', r),
                            t.currentTarget.removeEventListener('error', o),
                            e(t))
                        }
                        function o(t) {
                          t.currentTarget &&
                            (t.currentTarget.removeEventListener('load', r),
                            t.currentTarget.removeEventListener('error', o),
                            n(t))
                        }
                        i.addEventListener('load', r), i.addEventListener('error', o)
                      }))
                    )
                    var i
                  }),
                ),
              ]
            )
          case 1:
            return t.sent(), [2, new Rd(e, Array.isArray(o))]
        }
      })
    })
  }
  function Nd(a, s) {
    return dp(this, void 0, void 0, function () {
      var e, n, r, o, i
      return fp(this, function (t) {
        switch (t.label) {
          case 0:
            return (e = yd.getEnv().Canvas), (n = a) instanceof e ? [3, 5] : [4, Ad(a)]
          case 1:
            if (1 < (r = t.sent()).batchSize) throw new Error('extractFaces - batchSize > 1 not supported')
            return (r = r.getInput(0)) instanceof e ? ((o = r), [3, 4]) : [3, 2]
          case 2:
            return [
              4,
              (function (a, s) {
                return dp(this, void 0, void 0, function () {
                  var e, n, r, o, i
                  return fp(this, function (t) {
                    switch (t.label) {
                      case 0:
                        return (
                          (e = s || yd.getEnv().createCanvasElement()),
                          (i = a.shape.slice(xp(a) ? 1 : 0)),
                          (n = i[0]),
                          (r = i[1]),
                          (o = i[2]),
                          (i = Ge(function () {
                            return a.as3D(n, r, o).toInt()
                          })),
                          [4, zh.toPixels(i, e)]
                        )
                      case 1:
                        return t.sent(), i.dispose(), [2, e]
                    }
                  })
                })
              })(r),
            ]
          case 3:
            ;(o = t.sent()), (t.label = 4)
          case 4:
            ;(n = o), (t.label = 5)
          case 5:
            return (
              (i = xd(n)),
              [
                2,
                s
                  .map(function (t) {
                    return t instanceof Bp ? t.forSize(n.width, n.height).box.floor() : t
                  })
                  .map(function (t) {
                    return t.clipAtImageBorders(n.width, n.height)
                  })
                  .map(function (t) {
                    var e = t.x,
                      n = t.y,
                      r = t.width,
                      o = t.height,
                      t = Ed({ width: r, height: o })
                    return xd(t).putImageData(i.getImageData(e, n, r, o), 0, 0), t
                  }),
              ]
            )
        }
      })
    })
  }
  function kd(s, e) {
    return dp(this, void 0, void 0, function () {
      return fp(this, function (t) {
        if (!bp(s) && !xp(s)) throw new Error('extractFaceTensors - expected image tensor to be 3D or 4D')
        if (xp(s) && 1 < s.shape[0]) throw new Error('extractFaceTensors - batchSize > 1 not supported')
        return [
          2,
          Ge(function () {
            var t = s.shape.slice(xp(s) ? 1 : 0),
              o = t[0],
              i = t[1],
              a = t[2]
            return e
              .map(function (t) {
                return t instanceof Bp ? t.forSize(i, o).box : t
              })
              .map(function (t) {
                return t.clipAtImageBorders(i, o)
              })
              .map(function (t) {
                var e = t.x,
                  n = t.y,
                  r = t.width,
                  t = t.height
                return wc(s.as3D(o, i, a), [n, e, 0], [t, r, a])
              })
          }),
        ]
      })
    })
  }
  function Td(e) {
    return dp(this, void 0, void 0, function () {
      return fp(this, function (t) {
        switch (t.label) {
          case 0:
            return [
              4,
              (function (n, r) {
                return dp(this, void 0, void 0, function () {
                  var e
                  return fp(this, function (t) {
                    switch (t.label) {
                      case 0:
                        return [4, (0, yd.getEnv().fetch)(n, r)]
                      case 1:
                        if (!((e = t.sent()).status < 400))
                          throw new Error('failed to fetch: (' + e.status + ') ' + e.statusText + ', from url: ' + e.url)
                        return [2, e]
                    }
                  })
                })
              })(e),
            ]
          case 1:
            return [2, t.sent().json()]
        }
      })
    })
  }
  function Dd(t, e) {
    var n = e + '-weights_manifest.json'
    if (!t) return { modelBaseUri: '', manifestUri: n }
    if ('/' === t) return { modelBaseUri: '/', manifestUri: '/' + n }
    var r = t.startsWith('http://') ? 'http://' : t.startsWith('https://') ? 'https://' : '',
      e = (t = t.replace(r, '')).split('/').filter(function (t) {
        return t
      }),
      n = t.endsWith('.json') ? e[e.length - 1] : n,
      e = r + (t.endsWith('.json') ? e.slice(0, e.length - 1) : e).join('/')
    return { modelBaseUri: (e = t.startsWith('/') ? '/' + e : e), manifestUri: '/' === e ? '/' + n : e + '/' + n }
  }
  Object.defineProperty(Od.prototype, 'params', {
    get: function () {
      return this._params
    },
    enumerable: !0,
    configurable: !0,
  }),
    Object.defineProperty(Od.prototype, 'paramMappings', {
      get: function () {
        return this._paramMappings
      },
      enumerable: !0,
      configurable: !0,
    }),
    Object.defineProperty(Od.prototype, 'isLoaded', {
      get: function () {
        return !!this.params
      },
      enumerable: !0,
      configurable: !0,
    }),
    (Od.prototype.getParamFromPath = function (t) {
      t = this.traversePropertyPath(t)
      return t.obj[t.objProp]
    }),
    (Od.prototype.reassignParamFromPath = function (t, e) {
      var n = this.traversePropertyPath(t),
        t = n.obj,
        n = n.objProp
      t[n].dispose(), (t[n] = e)
    }),
    (Od.prototype.getParamList = function () {
      var e = this
      return this._paramMappings.map(function (t) {
        t = t.paramPath
        return { path: t, tensor: e.getParamFromPath(t) }
      })
    }),
    (Od.prototype.getTrainableParams = function () {
      return this.getParamList().filter(function (t) {
        return t.tensor instanceof Ct
      })
    }),
    (Od.prototype.getFrozenParams = function () {
      return this.getParamList().filter(function (t) {
        return !(t.tensor instanceof Ct)
      })
    }),
    (Od.prototype.variable = function () {
      var n = this
      this.getFrozenParams().forEach(function (t) {
        var e = t.path,
          t = t.tensor
        n.reassignParamFromPath(e, t.variable())
      })
    }),
    (Od.prototype.freeze = function () {
      var r = this
      this.getTrainableParams().forEach(function (t) {
        var e = t.path,
          n = t.tensor,
          t = cn(n.dataSync())
        n.dispose(), r.reassignParamFromPath(e, t)
      })
    }),
    (Od.prototype.dispose = function (e) {
      void 0 === e && (e = !0),
        this.getParamList().forEach(function (t) {
          if (e && t.tensor.isDisposed) throw new Error('param tensor has already been disposed for path ' + t.path)
          t.tensor.dispose()
        }),
        (this._params = void 0)
    }),
    (Od.prototype.serializeParams = function () {
      return new Float32Array(
        this.getParamList()
          .map(function (t) {
            t = t.tensor
            return Array.from(t.dataSync())
          })
          .reduce(function (t, e) {
            return t.concat(e)
          }),
      )
    }),
    (Od.prototype.load = function (e) {
      return dp(this, void 0, void 0, function () {
        return fp(this, function (t) {
          switch (t.label) {
            case 0:
              return e instanceof Float32Array ? (this.extractWeights(e), [2]) : [4, this.loadFromUri(e)]
            case 1:
              return t.sent(), [2]
          }
        })
      })
    }),
    (Od.prototype.loadFromUri = function (n) {
      return dp(this, void 0, void 0, function () {
        var e
        return fp(this, function (t) {
          switch (t.label) {
            case 0:
              if (n && 'string' != typeof n) throw new Error(this._name + '.loadFromUri - expected model uri')
              return [
                4,
                (function (r, o) {
                  return dp(this, void 0, void 0, function () {
                    var e, n
                    return fp(this, function (t) {
                      switch (t.label) {
                        case 0:
                          return (e = Dd(r, o)), (n = e.manifestUri), (e = e.modelBaseUri), [4, Td(n)]
                        case 1:
                          return (n = t.sent()), [2, Wh.loadWeights(n, e)]
                      }
                    })
                  })
                })(n, this.getDefaultModelName()),
              ]
            case 1:
              return (e = t.sent()), this.loadFromWeightMap(e), [2]
          }
        })
      })
    }),
    (Od.prototype.loadFromDisk = function (s) {
      return dp(this, void 0, void 0, function () {
        var e, n, r, o, i, a
        return fp(this, function (t) {
          switch (t.label) {
            case 0:
              if (s && 'string' != typeof s) throw new Error(this._name + '.loadFromDisk - expected model file path')
              return (
                (e = yd.getEnv().readFile),
                (o = Dd(s, this.getDefaultModelName())),
                (n = o.manifestUri),
                (a = o.modelBaseUri),
                (i = function (t) {
                  return Promise.all(
                    t.map(function (t) {
                      return e(t).then(function (t) {
                        return t.buffer
                      })
                    }),
                  )
                }),
                (r = Wh.weightsLoaderFactory(i)),
                (i = (o = JSON).parse),
                [4, e(n)]
              )
            case 1:
              return (o = i.apply(o, [t.sent().toString()])), [4, r(o, a)]
            case 2:
              return (a = t.sent()), this.loadFromWeightMap(a), [2]
          }
        })
      })
    }),
    (Od.prototype.loadFromWeightMap = function (t) {
      var e = this.extractParamsFromWeigthMap(t),
        t = e.paramMappings,
        e = e.params
      ;(this._paramMappings = t), (this._params = e)
    }),
    (Od.prototype.extractWeights = function (t) {
      var e = this.extractParams(t),
        t = e.paramMappings,
        e = e.params
      ;(this._paramMappings = t), (this._params = e)
    }),
    (Od.prototype.traversePropertyPath = function (n) {
      if (!this.params) throw new Error('traversePropertyPath - model has no loaded params')
      var t = n.split('/').reduce(
          function (t, e) {
            if (!t.nextObj.hasOwnProperty(e))
              throw new Error('traversePropertyPath - object does not have property ' + e + ', for path ' + n)
            return { obj: t.nextObj, objProp: e, nextObj: t.nextObj[e] }
          },
          { nextObj: this.params },
        ),
        e = t.obj,
        t = t.objProp
      if (!(e && t && e[t] instanceof bt)) throw new Error('traversePropertyPath - parameter is not a tensor, for path ' + n)
      return { obj: e, objProp: t }
    }),
    (al = Od)
  function Od(t) {
    ;(this._name = t), (this._params = void 0), (this._paramMappings = [])
  }
  function Fd(e, n, r) {
    return Ge(function () {
      var t = tc(e, n.depthwise_filter, n.pointwise_filter, r, 'same')
      return (t = au(t, n.bias))
    })
  }
  function Md(r, o, i) {
    return (
      void 0 === i && (i = !1),
      Ge(function () {
        var t = Lc(i ? au(Ku(r, o.conv0.filters, [2, 2], 'same'), o.conv0.bias) : Fd(r, o.conv0, [2, 2])),
          e = Fd(t, o.conv1, [1, 1]),
          n = Fd(Lc(au(t, e)), o.conv2, [1, 1])
        return Lc(au(t, au(e, n)))
      })
    )
  }
  function Pd(o, i, a, s) {
    return (
      void 0 === a && (a = !1),
      void 0 === s && (s = !0),
      Ge(function () {
        var t = Lc(
            a ? au(Ku(o, i.conv0.filters, s ? [2, 2] : [1, 1], 'same'), i.conv0.bias) : Fd(o, i.conv0, s ? [2, 2] : [1, 1]),
          ),
          e = Fd(t, i.conv1, [1, 1]),
          n = Fd(Lc(au(t, e)), i.conv2, [1, 1]),
          r = Fd(Lc(au(t, au(e, n))), i.conv3, [1, 1])
        return Lc(au(t, au(e, au(n, r))))
      })
    )
  }
  function Bd(e, n, r, o) {
    return (
      void 0 === r && (r = 'same'),
      void 0 === o && (o = !1),
      Ge(function () {
        var t = au(Ku(e, n.filters, [1, 1], r), n.bias)
        return o ? Lc(t) : t
      })
    )
  }
  function Ld(t, n) {
    Object.keys(t).forEach(function (e) {
      n.some(function (t) {
        return t.originalPath === e
      }) || t[e].dispose()
    })
  }
  function Wd(o, i) {
    return function (t, e, n, r) {
      ;(t = vn(o(t * e * n * n), [n, n, t, e])), (e = pn(o(e)))
      return i.push({ paramPath: r + '/filters' }, { paramPath: r + '/bias' }), { filters: t, bias: e }
    }
  }
  function zd(r, o) {
    return function (t, e, n) {
      ;(t = dn(r(t * e), [t, e])), (e = pn(r(e)))
      return o.push({ paramPath: n + '/weights' }, { paramPath: n + '/bias' }), { weights: t, bias: e }
    }
  }
  var Gd = function (t, e, n) {
    ;(this.depthwise_filter = t), (this.pointwise_filter = e), (this.bias = n)
  }
  function Ud(o, i) {
    return function (t, e, n) {
      var r = vn(o(9 * t), [3, 3, t, 1]),
        t = vn(o(t * e), [1, 1, t, e]),
        e = pn(o(e))
      return (
        i.push({ paramPath: n + '/depthwise_filter' }, { paramPath: n + '/pointwise_filter' }, { paramPath: n + '/bias' }),
        new Gd(r, t, e)
      )
    }
  }
  function Vd(r) {
    return function (t) {
      var e = r(t + '/depthwise_filter', 4),
        n = r(t + '/pointwise_filter', 4),
        t = r(t + '/bias', 1)
      return new Gd(e, n, t)
    }
  }
  function Hd(o, i) {
    return function (t, e, n) {
      var r = o[t]
      if (!yp(r, e)) throw new Error('expected weightMap[' + t + '] to be a Tensor' + e + 'D, instead have ' + r)
      return i.push({ originalPath: t, paramPath: n || t }), r
    }
  }
  function jd(t) {
    var n = t
    return {
      extractWeights: function (t) {
        var e = n.slice(0, t)
        return (n = n.slice(t)), e
      },
      getRemainingWeights: function () {
        return n
      },
    }
  }
  function qd(t, e) {
    var o = Wd(t, e),
      i = Ud(t, e)
    function a(t, e, n, r) {
      return {
        conv0: (r = void 0 === r ? !1 : r) ? o(t, e, 3, n + '/conv0') : i(t, e, n + '/conv0'),
        conv1: i(e, e, n + '/conv1'),
        conv2: i(e, e, n + '/conv2'),
      }
    }
    return {
      extractDenseBlock3Params: a,
      extractDenseBlock4Params: function (t, e, n, r) {
        return {
          conv0: (r = a(t, e, n, (r = void 0 === r ? !1 : r))).conv0,
          conv1: r.conv1,
          conv2: r.conv2,
          conv3: i(e, e, n + '/conv3'),
        }
      },
    }
  }
  function Kd(e) {
    return function (t) {
      return { filters: e(t + '/filters', 4), bias: e(t + '/bias', 1) }
    }
  }
  function Xd(t, e) {
    var e = Hd(t, e),
      n = Kd(e),
      r = Vd(e)
    return {
      extractDenseBlock3Params: function (t, e) {
        return { conv0: ((e = void 0 === e ? !1 : e) ? n : r)(t + '/conv0'), conv1: r(t + '/conv1'), conv2: r(t + '/conv2') }
      },
      extractDenseBlock4Params: function (t, e) {
        return {
          conv0: ((e = void 0 === e ? !1 : e) ? n : r)(t + '/conv0'),
          conv1: r(t + '/conv1'),
          conv2: r(t + '/conv2'),
          conv3: r(t + '/conv3'),
        }
      },
    }
  }
  var $d,
    Yd =
      (hp(Jd, ($d = al)),
      (Jd.prototype.forwardInput = function (e) {
        var n = this.params
        if (!n) throw new Error('FaceFeatureExtractor - load model before inference')
        return Ge(function () {
          var t = Pd(zp(e.toBatchTensor(112, !0), [122.782, 117.001, 104.298]).div(hn(255)), n.dense0, !0),
            t = Pd(t, n.dense1)
          return (t = Pd(t, n.dense2)), (t = Pd(t, n.dense3)), fc(t, [7, 7], [2, 2], 'valid')
        })
      }),
      (Jd.prototype.forward = function (n) {
        return dp(this, void 0, void 0, function () {
          var e
          return fp(this, function (t) {
            switch (t.label) {
              case 0:
                return (e = this.forwardInput), [4, Ad(n)]
              case 1:
                return [2, e.apply(this, [t.sent()])]
            }
          })
        })
      }),
      (Jd.prototype.getDefaultModelName = function () {
        return 'face_feature_extractor_model'
      }),
      (Jd.prototype.extractParamsFromWeigthMap = function (t) {
        return (
          (t = {
            dense0: (t = Xd((e = t), (n = [])).extractDenseBlock4Params)('dense0', !0),
            dense1: t('dense1'),
            dense2: t('dense2'),
            dense3: t('dense3'),
          }),
          Ld(e, n),
          { params: t, paramMappings: n }
        )
        var e, n
      }),
      (Jd.prototype.extractParams = function (t) {
        var e = [],
          n = (o = jd(t)).extractWeights,
          r = o.getRemainingWeights,
          t = (i = qd(n, e).extractDenseBlock4Params)(3, 32, 'dense0', !0),
          o = i(32, 64, 'dense1'),
          n = i(64, 128, 'dense2'),
          i = i(128, 256, 'dense3')
        if (0 !== r().length) throw new Error('weights remaing after extract: ' + r().length)
        return { paramMappings: e, params: { dense0: t, dense1: o, dense2: n, dense3: i } }
      }),
      Jd)
  function Jd() {
    return $d.call(this, 'FaceFeatureExtractor') || this
  }
  function Qd(t, e) {
    return Ge(function () {
      return au(rc(t, e.weights), e.bias)
    })
  }
  function Zd(e) {
    var n = {},
      r = {}
    return (
      Object.keys(e).forEach(function (t) {
        ;(t.startsWith('fc') ? r : n)[t] = e[t]
      }),
      { featureExtractorMap: n, classifierMap: r }
    )
  }
  var tf,
    ul =
      (hp(ef, (tf = al)),
      Object.defineProperty(ef.prototype, 'faceFeatureExtractor', {
        get: function () {
          return this._faceFeatureExtractor
        },
        enumerable: !0,
        configurable: !0,
      }),
      (ef.prototype.runNet = function (e) {
        var n = this,
          r = this.params
        if (!r) throw new Error(this._name + ' - load model before inference')
        return Ge(function () {
          var t = e instanceof Rd ? n.faceFeatureExtractor.forwardInput(e) : e
          return Qd(t.as2D(t.shape[0], -1), r.fc)
        })
      }),
      (ef.prototype.dispose = function (t) {
        void 0 === t && (t = !0), this.faceFeatureExtractor.dispose(t), tf.prototype.dispose.call(this, t)
      }),
      (ef.prototype.loadClassifierParams = function (t) {
        var e = this.extractClassifierParams(t),
          t = e.params,
          e = e.paramMappings
        ;(this._params = t), (this._paramMappings = e)
      }),
      (ef.prototype.extractClassifierParams = function (t) {
        return (function (t, e, n) {
          var r = [],
            t = (o = jd(t)).extractWeights,
            o = o.getRemainingWeights,
            n = zd(t, r)(e, n, 'fc')
          if (0 !== o().length) throw new Error('weights remaing after extract: ' + o().length)
          return { paramMappings: r, params: { fc: n } }
        })(t, this.getClassifierChannelsIn(), this.getClassifierChannelsOut())
      }),
      (ef.prototype.extractParamsFromWeigthMap = function (t) {
        var e = Zd(t),
          n = e.featureExtractorMap,
          r = e.classifierMap
        return (
          this.faceFeatureExtractor.loadFromWeightMap(n),
          (n = Hd((t = r), (e = []))),
          (r = { fc: { weights: n((r = 'fc') + '/weights', 2), bias: n(r + '/bias', 1) } }),
          Ld(t, e),
          { params: r, paramMappings: e }
        )
      }),
      (ef.prototype.extractParams = function (t) {
        var e = this.getClassifierChannelsIn(),
          n = this.getClassifierChannelsOut(),
          e = n * e + n,
          n = t.slice(0, t.length - e),
          e = t.slice(t.length - e)
        return this.faceFeatureExtractor.extractWeights(n), this.extractClassifierParams(e)
      }),
      ef)
  function ef(t, e) {
    t = tf.call(this, t) || this
    return (t._faceFeatureExtractor = e), t
  }
  var nf = ['neutral', 'happy', 'sad', 'angry', 'fearful', 'disgusted', 'surprised'],
    rf =
      ((of.prototype.asSortedArray = function () {
        var e = this
        return nf
          .map(function (t) {
            return { expression: t, probability: e[t] }
          })
          .sort(function (t, e) {
            return e.probability - t.probability
          })
      }),
      of)
  function of(n) {
    var r = this
    if (7 !== n.length)
      throw new Error('FaceExpressions.constructor - expected probabilities.length to be 7, have: ' + n.length)
    nf.forEach(function (t, e) {
      r[t] = n[e]
    })
  }
  var af,
    Br =
      (hp(sf, (af = ul)),
      (sf.prototype.forwardInput = function (t) {
        var e = this
        return Ge(function () {
          return Fr(e.runNet(t))
        })
      }),
      (sf.prototype.forward = function (n) {
        return dp(this, void 0, void 0, function () {
          var e
          return fp(this, function (t) {
            switch (t.label) {
              case 0:
                return (e = this.forwardInput), [4, Ad(n)]
              case 1:
                return [2, e.apply(this, [t.sent()])]
            }
          })
        })
      }),
      (sf.prototype.predictExpressions = function (i) {
        return dp(this, void 0, void 0, function () {
          var e,
            n,
            r,
            o = this
          return fp(this, function (t) {
            switch (t.label) {
              case 0:
                return [4, Ad(i)]
              case 1:
                return (e = t.sent()), [4, this.forwardInput(e)]
              case 2:
                return (
                  (n = t.sent()),
                  [
                    4,
                    Promise.all(
                      vr(n).map(function (n) {
                        return dp(o, void 0, void 0, function () {
                          var e
                          return fp(this, function (t) {
                            switch (t.label) {
                              case 0:
                                return [4, n.data()]
                              case 1:
                                return (e = t.sent()), n.dispose(), [2, e]
                            }
                          })
                        })
                      }),
                    ),
                  ]
                )
              case 3:
                return (
                  (r = t.sent()),
                  n.dispose(),
                  (r = r.map(function (t) {
                    return new rf(t)
                  })),
                  [2, e.isBatchInput ? r : r[0]]
                )
            }
          })
        })
      }),
      (sf.prototype.getDefaultModelName = function () {
        return 'face_expression_model'
      }),
      (sf.prototype.getClassifierChannelsIn = function () {
        return 256
      }),
      (sf.prototype.getClassifierChannelsOut = function () {
        return 7
      }),
      sf)
  function sf(t) {
    return void 0 === t && (t = new Yd()), af.call(this, 'FaceExpressionNet', t) || this
  }
  function uf(t, e) {
    e = { expressions: e }
    return Object.assign({}, t, e)
  }
  function cf(t) {
    return cd(t) && t.landmarks instanceof jp && t.unshiftedLandmarks instanceof jp && t.alignedRect instanceof Bp
  }
  function lf(t, e) {
    var n = t.detection.box,
      r = e.shiftBy(n.x, n.y),
      o = r.align(),
      n = t.detection.imageDims,
      n = { landmarks: r, unshiftedLandmarks: e, alignedRect: new Bp(t.detection.score, o.rescale(n.reverse()), n) }
    return Object.assign({}, t, n)
  }
  function hf(t, e) {
    var r = Wd(t, e),
      o = Ud(t, e)
    return {
      extractConvParams: r,
      extractSeparableConvParams: o,
      extractReductionBlockParams: function (t, e, n) {
        return {
          separable_conv0: o(t, e, n + '/separable_conv0'),
          separable_conv1: o(e, e, n + '/separable_conv1'),
          expansion_conv: r(t, e, 1, n + '/expansion_conv'),
        }
      },
      extractMainBlockParams: function (t, e) {
        return {
          separable_conv0: o(t, t, e + '/separable_conv0'),
          separable_conv1: o(t, t, e + '/separable_conv1'),
          separable_conv2: o(t, t, e + '/separable_conv2'),
        }
      },
    }
  }
  function pf(t, e) {
    var e = Hd(t, e),
      n = Kd(e),
      r = Vd(e)
    return {
      extractConvParams: n,
      extractSeparableConvParams: r,
      extractReductionBlockParams: function (t) {
        return {
          separable_conv0: r(t + '/separable_conv0'),
          separable_conv1: r(t + '/separable_conv1'),
          expansion_conv: n(t + '/expansion_conv'),
        }
      },
      extractMainBlockParams: function (t) {
        return {
          separable_conv0: r(t + '/separable_conv0'),
          separable_conv1: r(t + '/separable_conv1'),
          separable_conv2: r(t + '/separable_conv2'),
        }
      },
    }
  }
  function df(t, e, n) {
    return au(Ku(t, e.filters, n, 'same'), e.bias)
  }
  function ff(t, e, n) {
    n = Fd((n = (n = void 0 === n ? !0 : n) ? Lc(t) : t), e.separable_conv0, [1, 1])
    return (
      (n = Fd(Lc(n), e.separable_conv1, [1, 1])),
      (n = dc(n, [3, 3], [2, 2], 'same')),
      (n = au(n, df(t, e.expansion_conv, [2, 2])))
    )
  }
  var vf,
    mf,
    gf =
      (hp(yf, (vf = al)),
      (yf.prototype.forwardInput = function (e) {
        var n = this,
          o = this.params
        if (!o) throw new Error('TinyXception - load model before inference')
        return Ge(function () {
          var t = zp(e.toBatchTensor(112, !0), [122.782, 117.001, 104.298]).div(hn(256)),
            r = ff((r = Lc(df(t, o.entry_flow.conv_in, [2, 2]))), o.entry_flow.reduction_block_0, !1)
          return (
            (r = ff(r, o.entry_flow.reduction_block_1)),
            Sp(n._numMainBlocks, 0, 1).forEach(function (t) {
              var e, n
              ;(e = r),
                (n = o.middle_flow['main_block_' + t]),
                (t = Fd(Lc(e), n.separable_conv0, [1, 1])),
                (t = Fd(Lc(t), n.separable_conv1, [1, 1])),
                (t = Fd(Lc(t), n.separable_conv2, [1, 1])),
                (r = au(t, e))
            }),
            (r = ff(r, o.exit_flow.reduction_block)),
            (r = Lc(Fd(r, o.exit_flow.separable_conv, [1, 1])))
          )
        })
      }),
      (yf.prototype.forward = function (n) {
        return dp(this, void 0, void 0, function () {
          var e
          return fp(this, function (t) {
            switch (t.label) {
              case 0:
                return (e = this.forwardInput), [4, Ad(n)]
              case 1:
                return [2, e.apply(this, [t.sent()])]
            }
          })
        })
      }),
      (yf.prototype.getDefaultModelName = function () {
        return 'tiny_xception_model'
      }),
      (yf.prototype.extractParamsFromWeigthMap = function (t) {
        return (
          (e = t),
          (n = this._numMainBlocks),
          (o = pf(e, (r = []))),
          (i = o.extractConvParams),
          (a = o.extractSeparableConvParams),
          (t = o.extractReductionBlockParams),
          (s = o.extractMainBlockParams),
          (i = {
            conv_in: i('entry_flow/conv_in'),
            reduction_block_0: t('entry_flow/reduction_block_0'),
            reduction_block_1: t('entry_flow/reduction_block_1'),
          }),
          (u = {}),
          Sp(n, 0, 1).forEach(function (t) {
            u['main_block_' + t] = s('middle_flow/main_block_' + t)
          }),
          (a = { reduction_block: t('exit_flow/reduction_block'), separable_conv: a('exit_flow/separable_conv') }),
          Ld(e, r),
          { params: { entry_flow: i, middle_flow: u, exit_flow: a }, paramMappings: r }
        )
        var e, n, r, o, i, a, s, u
      }),
      (yf.prototype.extractParams = function (t) {
        return (function (t, e) {
          var n = [],
            r = (a = jd(t)).extractWeights,
            o = a.getRemainingWeights,
            i = hf(r, n),
            t = i.extractConvParams,
            a = i.extractSeparableConvParams,
            r = i.extractReductionBlockParams,
            s = i.extractMainBlockParams,
            t = {
              conv_in: t(3, 32, 3, 'entry_flow/conv_in'),
              reduction_block_0: r(32, 64, 'entry_flow/reduction_block_0'),
              reduction_block_1: r(64, 128, 'entry_flow/reduction_block_1'),
            },
            u = {}
          if (
            (Sp(e, 0, 1).forEach(function (t) {
              u['main_block_' + t] = s(128, 'middle_flow/main_block_' + t)
            }),
            (a = {
              reduction_block: r(128, 256, 'exit_flow/reduction_block'),
              separable_conv: a(256, 512, 'exit_flow/separable_conv'),
            }),
            0 !== o().length)
          )
            throw new Error('weights remaing after extract: ' + o().length)
          return { paramMappings: n, params: { entry_flow: t, middle_flow: u, exit_flow: a } }
        })(t, this._numMainBlocks)
      }),
      yf)
  function yf(t) {
    var e = vf.call(this, 'TinyXception') || this
    return (e._numMainBlocks = t), e
  }
  ;((Vi = mf = mf || {}).FEMALE = 'female'), (Vi.MALE = 'male')
  var bf,
    Le =
      (hp(xf, (bf = al)),
      Object.defineProperty(xf.prototype, 'faceFeatureExtractor', {
        get: function () {
          return this._faceFeatureExtractor
        },
        enumerable: !0,
        configurable: !0,
      }),
      (xf.prototype.runNet = function (e) {
        var n = this,
          r = this.params
        if (!r) throw new Error(this._name + ' - load model before inference')
        return Ge(function () {
          var t = e instanceof Rd ? n.faceFeatureExtractor.forwardInput(e) : e,
            t = fc(t, [7, 7], [2, 2], 'valid').as2D(t.shape[0], -1)
          return { age: Qd(t, r.fc.age).as1D(), gender: Qd(t, r.fc.gender) }
        })
      }),
      (xf.prototype.forwardInput = function (n) {
        var r = this
        return Ge(function () {
          var t = r.runNet(n),
            e = t.age,
            t = t.gender
          return { age: e, gender: Fr(t) }
        })
      }),
      (xf.prototype.forward = function (n) {
        return dp(this, void 0, void 0, function () {
          var e
          return fp(this, function (t) {
            switch (t.label) {
              case 0:
                return (e = this.forwardInput), [4, Ad(n)]
              case 1:
                return [2, e.apply(this, [t.sent()])]
            }
          })
        })
      }),
      (xf.prototype.predictAgeAndGender = function (i) {
        return dp(this, void 0, void 0, function () {
          var e,
            n,
            r,
            o,
            s = this
          return fp(this, function (t) {
            switch (t.label) {
              case 0:
                return [4, Ad(i)]
              case 1:
                return (e = t.sent()), [4, this.forwardInput(e)]
              case 2:
                return (
                  (n = t.sent()),
                  (o = vr(n.age)),
                  (r = vr(n.gender)),
                  (o = o.map(function (t, e) {
                    return { ageTensor: t, genderTensor: r[e] }
                  })),
                  [
                    4,
                    Promise.all(
                      o.map(function (t) {
                        var i = t.ageTensor,
                          a = t.genderTensor
                        return dp(s, void 0, void 0, function () {
                          var e, n, r, o
                          return fp(this, function (t) {
                            switch (t.label) {
                              case 0:
                                return [4, i.data()]
                              case 1:
                                return (e = t.sent()[0]), [4, a.data()]
                              case 2:
                                return (
                                  (o = t.sent()[0]),
                                  (r = (n = 0.5 < o) ? mf.MALE : mf.FEMALE),
                                  (o = n ? o : 1 - o),
                                  i.dispose(),
                                  a.dispose(),
                                  [2, { age: e, gender: r, genderProbability: o }]
                                )
                            }
                          })
                        })
                      }),
                    ),
                  ]
                )
              case 3:
                return (o = t.sent()), n.age.dispose(), n.gender.dispose(), [2, e.isBatchInput ? o : o[0]]
            }
          })
        })
      }),
      (xf.prototype.getDefaultModelName = function () {
        return 'age_gender_model'
      }),
      (xf.prototype.dispose = function (t) {
        void 0 === t && (t = !0), this.faceFeatureExtractor.dispose(t), bf.prototype.dispose.call(this, t)
      }),
      (xf.prototype.loadClassifierParams = function (t) {
        var e = this.extractClassifierParams(t),
          t = e.params,
          e = e.paramMappings
        ;(this._params = t), (this._paramMappings = e)
      }),
      (xf.prototype.extractClassifierParams = function (t) {
        var e = [],
          n = (r = jd(t)).extractWeights,
          t = r.getRemainingWeights,
          n = (r = zd(n, e))(512, 1, 'fc/age'),
          r = r(512, 2, 'fc/gender')
        if (0 !== t().length) throw new Error('weights remaing after extract: ' + t().length)
        return { paramMappings: e, params: { fc: { age: n, gender: r } } }
      }),
      (xf.prototype.extractParamsFromWeigthMap = function (t) {
        var e,
          n = Zd(t),
          r = n.featureExtractorMap,
          t = n.classifierMap
        return (
          this.faceFeatureExtractor.loadFromWeightMap(r),
          (e = Hd((n = t), (r = []))),
          (t = { fc: { age: o('fc/age'), gender: o('fc/gender') } }),
          Ld(n, r),
          { params: t, paramMappings: r }
        )
        function o(t) {
          return { weights: e(t + '/weights', 2), bias: e(t + '/bias', 1) }
        }
      }),
      (xf.prototype.extractParams = function (t) {
        var e = t.slice(0, t.length - 1539),
          t = t.slice(t.length - 1539)
        return this.faceFeatureExtractor.extractWeights(e), this.extractClassifierParams(t)
      }),
      xf)
  function xf(t) {
    void 0 === t && (t = new gf(2))
    var e = bf.call(this, 'AgeGenderNet') || this
    return (e._faceFeatureExtractor = t), e
  }
  var wf,
    el =
      (hp(Cf, (wf = ul)),
      (Cf.prototype.postProcess = function (t, o, e) {
        var i = e.map(function (t) {
            var e = t.width,
              n = t.height,
              t = o / Math.max(n, e)
            return { width: e * t, height: n * t }
          }),
          a = i.length
        return Ge(function () {
          function n(t, e) {
            return pr([yn([68], t), yn([68], e)], 1)
              .as2D(1, 136)
              .as1D()
          }
          function r(t, e) {
            var t = (n = i[t]).width,
              n = n.height
            return e(t, n) ? Math.abs(t - n) / 2 : 0
          }
          return t
            .mul(yn([a, 136], o))
            .sub(
              pr(
                Array.from(Array(a), function (t, e) {
                  return n(
                    r(e, function (t, e) {
                      return t < e
                    }),
                    r(e, function (t, e) {
                      return e < t
                    }),
                  )
                }),
              ),
            )
            .div(
              pr(
                Array.from(Array(a), function (t, e) {
                  return n(i[e].width, i[e].height)
                }),
              ),
            )
        })
      }),
      (Cf.prototype.forwardInput = function (e) {
        var n = this
        return Ge(function () {
          var t = n.runNet(e)
          return n.postProcess(
            t,
            e.inputSize,
            e.inputDimensions.map(function (t) {
              return { height: t[0], width: t[1] }
            }),
          )
        })
      }),
      (Cf.prototype.forward = function (n) {
        return dp(this, void 0, void 0, function () {
          var e
          return fp(this, function (t) {
            switch (t.label) {
              case 0:
                return (e = this.forwardInput), [4, Ad(n)]
              case 1:
                return [2, e.apply(this, [t.sent()])]
            }
          })
        })
      }),
      (Cf.prototype.detectLandmarks = function (o) {
        return dp(this, void 0, void 0, function () {
          var s,
            e,
            n,
            r = this
          return fp(this, function (t) {
            switch (t.label) {
              case 0:
                return [4, Ad(o)]
              case 1:
                return (
                  (s = t.sent()),
                  (e = Ge(function () {
                    return vr(r.forwardInput(s))
                  })),
                  [
                    4,
                    Promise.all(
                      e.map(function (i, a) {
                        return dp(r, void 0, void 0, function () {
                          var e, n, r, o
                          return fp(this, function (t) {
                            switch (t.label) {
                              case 0:
                                return (n = (e = Array).from), [4, i.data()]
                              case 1:
                                return (
                                  (e = n.apply(e, [t.sent()])),
                                  (r = e.filter(function (t, e) {
                                    return wp(e)
                                  })),
                                  (o = e.filter(function (t, e) {
                                    return !wp(e)
                                  })),
                                  [
                                    2,
                                    new Jp(
                                      Array(68)
                                        .fill(0)
                                        .map(function (t, e) {
                                          return new Ip(r[e], o[e])
                                        }),
                                      { height: s.getInputHeight(a), width: s.getInputWidth(a) },
                                    ),
                                  ]
                                )
                            }
                          })
                        })
                      }),
                    ),
                  ]
                )
              case 2:
                return (
                  (n = t.sent()),
                  e.forEach(function (t) {
                    return t.dispose()
                  }),
                  [2, s.isBatchInput ? n : n[0]]
                )
            }
          })
        })
      }),
      (Cf.prototype.getClassifierChannelsOut = function () {
        return 136
      }),
      Cf)
  function Cf() {
    return (null !== wf && wf.apply(this, arguments)) || this
  }
  var Ef,
    o =
      (hp(Sf, (Ef = el)),
      (Sf.prototype.getDefaultModelName = function () {
        return 'face_landmark_68_model'
      }),
      (Sf.prototype.getClassifierChannelsIn = function () {
        return 256
      }),
      Sf)
  function Sf(t) {
    return void 0 === t && (t = new Yd()), Ef.call(this, 'FaceLandmark68Net', t) || this
  }
  var _f,
    Rf =
      (hp(If, (_f = al)),
      (If.prototype.forwardInput = function (e) {
        var n = this.params
        if (!n) throw new Error('TinyFaceFeatureExtractor - load model before inference')
        return Ge(function () {
          var t = Md(zp(e.toBatchTensor(112, !0), [122.782, 117.001, 104.298]).div(hn(255)), n.dense0, !0),
            t = Md(t, n.dense1)
          return (t = Md(t, n.dense2)), fc(t, [14, 14], [2, 2], 'valid')
        })
      }),
      (If.prototype.forward = function (n) {
        return dp(this, void 0, void 0, function () {
          var e
          return fp(this, function (t) {
            switch (t.label) {
              case 0:
                return (e = this.forwardInput), [4, Ad(n)]
              case 1:
                return [2, e.apply(this, [t.sent()])]
            }
          })
        })
      }),
      (If.prototype.getDefaultModelName = function () {
        return 'face_feature_extractor_tiny_model'
      }),
      (If.prototype.extractParamsFromWeigthMap = function (t) {
        return (
          (t = {
            dense0: (t = Xd((e = t), (n = [])).extractDenseBlock3Params)('dense0', !0),
            dense1: t('dense1'),
            dense2: t('dense2'),
          }),
          Ld(e, n),
          { params: t, paramMappings: n }
        )
        var e, n
      }),
      (If.prototype.extractParams = function (t) {
        var e = [],
          n = (o = jd(t)).extractWeights,
          r = o.getRemainingWeights,
          o = (t = qd(n, e).extractDenseBlock3Params)(3, 32, 'dense0', !0),
          n = t(32, 64, 'dense1'),
          t = t(64, 128, 'dense2')
        if (0 !== r().length) throw new Error('weights remaing after extract: ' + r().length)
        return { paramMappings: e, params: { dense0: o, dense1: n, dense2: t } }
      }),
      If)
  function If() {
    return _f.call(this, 'TinyFaceFeatureExtractor') || this
  }
  var Af,
    Nf,
    nl =
      (hp(kf, (Af = el)),
      (kf.prototype.getDefaultModelName = function () {
        return 'face_landmark_68_tiny_model'
      }),
      (kf.prototype.getClassifierChannelsIn = function () {
        return 128
      }),
      kf)
  function kf(t) {
    return void 0 === t && (t = new Rf()), Af.call(this, 'FaceLandmark68TinyNet', t) || this
  }
  function Tf() {
    return (null !== Nf && Nf.apply(this, arguments)) || this
  }
  function Df(t, e, n, r, o) {
    void 0 === o && (o = 'same')
    var i = e.conv,
      a = i.filters,
      i = i.bias,
      o = Ku(t, a, n, o),
      o = au(o, i)
    return (i = o), (e = e.scale), (o = au(xu(i, e.weights), e.biases)), r ? Lc(o) : o
  }
  function Of(t, e) {
    return Df(t, e, [1, 1], !1)
  }
  function Ff(t, e) {
    return Df(t, e, [2, 2], !0, 'valid')
  }
  function Mf(i, o) {
    function a(t, e, n, r) {
      ;(n = (function (t, e, n) {
        var r = i(t),
          o = r.length / (e * n * n)
        if (o % 1 != 0)
          throw new Error(
            'depth has to be an integer: ' + o + ', weights.length: ' + r.length + ', numFilters: ' + e + ', filterSize: ' + n,
          )
        return Ge(function () {
          return Gc(vn(r, [e, o, n, n]), [2, 3, 1, 0])
        })
      })(t, e, n)),
        (e = pn(i(e)))
      return o.push({ paramPath: r + '/filters' }, { paramPath: r + '/bias' }), { filters: n, bias: e }
    }
    function s(t, e, n, r) {
      return {
        conv: a(t, e, n, r + '/conv'),
        scale:
          ((n = r + '/scale'),
          (e = pn(i((r = e)))),
          (r = pn(i(r))),
          o.push({ paramPath: n + '/weights' }, { paramPath: n + '/biases' }),
          { weights: e, biases: r }),
      }
    }
    return {
      extractConvLayerParams: s,
      extractResidualLayerParams: function (t, e, n, r, o) {
        return { conv1: s(((o = void 0 === o ? !1 : o) ? 0.5 : 1) * t, e, n, r + '/conv1'), conv2: s(t, e, n, r + '/conv2') }
      },
    }
  }
  function Pf(t, e) {
    var n = Hd(t, e)
    function r(t) {
      return {
        conv: { filters: n(t + '/conv/filters', 4), bias: n(t + '/conv/bias', 1) },
        scale: { weights: n((t = t) + '/scale/weights', 1), biases: n(t + '/scale/biases', 1) },
      }
    }
    return {
      extractConvLayerParams: r,
      extractResidualLayerParams: function (t) {
        return { conv1: r(t + '/conv1'), conv2: r(t + '/conv2') }
      },
    }
  }
  function Bf(t) {
    var e = [],
      n = Pf(t, e),
      r = n.extractConvLayerParams,
      o = n.extractResidualLayerParams,
      i = r('conv32_down'),
      a = o('conv32_1'),
      s = o('conv32_2'),
      u = o('conv32_3'),
      c = o('conv64_down'),
      l = o('conv64_1'),
      h = o('conv64_2'),
      p = o('conv64_3'),
      d = o('conv128_down'),
      f = o('conv128_1'),
      v = o('conv128_2'),
      m = o('conv256_down'),
      g = o('conv256_1'),
      n = o('conv256_2'),
      r = o('conv256_down_out'),
      o = t.fc
    if ((e.push({ originalPath: 'fc', paramPath: 'fc' }), !yp(o, 2)))
      throw new Error('expected weightMap[fc] to be a Tensor2D, instead have ' + o)
    o = {
      conv32_down: i,
      conv32_1: a,
      conv32_2: s,
      conv32_3: u,
      conv64_down: c,
      conv64_1: l,
      conv64_2: h,
      conv64_3: p,
      conv128_down: d,
      conv128_1: f,
      conv128_2: v,
      conv256_down: m,
      conv256_1: g,
      conv256_2: n,
      conv256_down_out: r,
      fc: o,
    }
    return Ld(t, e), { params: o, paramMappings: e }
  }
  function Lf(t, e) {
    var n,
      r = Of((r = ((n = t), (r = e.conv1), Df(n, r, [1, 1], !0))), e.conv2)
    return (r = au(r, t)), (r = Lc(r))
  }
  function Wf(t, e) {
    var n = Ff(t, e.conv1)
    n = Of(n, e.conv2)
    var r = fc(t, 2, 2, 'valid'),
      o = gn(r.shape),
      e = r.shape[3] !== n.shape[3]
    return (
      (r.shape[1] !== n.shape[1] || r.shape[2] !== n.shape[2]) &&
        (((t = vp(n.shape))[1] = 1),
        (t = gn(t)),
        ((t = vp((n = Cn([n, t], 1)).shape))[2] = 1),
        (t = gn(t)),
        (n = Cn([n, t], 2))),
      (r = e ? Cn([r, o], 3) : r),
      (n = au(r, n)),
      (n = Lc(n))
    )
  }
  hp(Tf, (Nf = o))
  var zf,
    Zc =
      (hp(Gf, (zf = al)),
      (Gf.prototype.forwardInput = function (e) {
        var n = this.params
        if (!n) throw new Error('FaceRecognitionNet - load model before inference')
        return Ge(function () {
          var t = Ff(zp(e.toBatchTensor(150, !0).toFloat(), [122.782, 117.001, 104.298]).div(hn(256)), n.conv32_down)
          ;(t = Lf((t = dc(t, 3, 2, 'valid')), n.conv32_1)),
            (t = Lf(t, n.conv32_2)),
            (t = Lf(t, n.conv32_3)),
            (t = Lf((t = Wf(t, n.conv64_down)), n.conv64_1)),
            (t = Lf(t, n.conv64_2)),
            (t = Lf(t, n.conv64_3)),
            (t = Lf((t = Wf(t, n.conv128_down)), n.conv128_1)),
            (t = Lf(t, n.conv128_2)),
            (t = Lf((t = Wf(t, n.conv256_down)), n.conv256_1))
          t = (t = Wf((t = Lf(t, n.conv256_2)), n.conv256_down_out)).mean([1, 2])
          return rc(t, n.fc)
        })
      }),
      (Gf.prototype.forward = function (n) {
        return dp(this, void 0, void 0, function () {
          var e
          return fp(this, function (t) {
            switch (t.label) {
              case 0:
                return (e = this.forwardInput), [4, Ad(n)]
              case 1:
                return [2, e.apply(this, [t.sent()])]
            }
          })
        })
      }),
      (Gf.prototype.computeFaceDescriptor = function (i) {
        return dp(this, void 0, void 0, function () {
          var e,
            n,
            r,
            o = this
          return fp(this, function (t) {
            switch (t.label) {
              case 0:
                return [4, Ad(i)]
              case 1:
                return (
                  (e = t.sent()),
                  (n = Ge(function () {
                    return vr(o.forwardInput(e))
                  })),
                  [
                    4,
                    Promise.all(
                      n.map(function (t) {
                        return t.data()
                      }),
                    ),
                  ]
                )
              case 2:
                return (
                  (r = t.sent()),
                  n.forEach(function (t) {
                    return t.dispose()
                  }),
                  [2, e.isBatchInput ? r : r[0]]
                )
            }
          })
        })
      }),
      (Gf.prototype.getDefaultModelName = function () {
        return 'face_recognition_model'
      }),
      (Gf.prototype.extractParamsFromWeigthMap = Bf),
      (Gf.prototype.extractParams = function (t) {
        var e = (g = jd(t)).extractWeights,
          n = g.getRemainingWeights,
          r = [],
          o = (y = Mf(e, r)).extractConvLayerParams,
          i = y.extractResidualLayerParams,
          a = o(4704, 32, 7, 'conv32_down'),
          s = i(9216, 32, 3, 'conv32_1'),
          u = i(9216, 32, 3, 'conv32_2'),
          c = i(9216, 32, 3, 'conv32_3'),
          l = i(36864, 64, 3, 'conv64_down', !0),
          h = i(36864, 64, 3, 'conv64_1'),
          p = i(36864, 64, 3, 'conv64_2'),
          d = i(36864, 64, 3, 'conv64_3'),
          f = i(147456, 128, 3, 'conv128_down', !0),
          v = i(147456, 128, 3, 'conv128_1'),
          m = i(147456, 128, 3, 'conv128_2'),
          t = i(589824, 256, 3, 'conv256_down', !0),
          g = i(589824, 256, 3, 'conv256_1'),
          y = i(589824, 256, 3, 'conv256_2'),
          o = i(589824, 256, 3, 'conv256_down_out'),
          i = Ge(function () {
            return Gc(dn(e(32768), [128, 256]), [1, 0])
          })
        if ((r.push({ paramPath: 'fc' }), 0 !== n().length)) throw new Error('weights remaing after extract: ' + n().length)
        return {
          params: {
            conv32_down: a,
            conv32_1: s,
            conv32_2: u,
            conv32_3: c,
            conv64_down: l,
            conv64_1: h,
            conv64_2: p,
            conv64_3: d,
            conv128_down: f,
            conv128_1: v,
            conv128_2: m,
            conv256_down: t,
            conv256_1: g,
            conv256_2: y,
            conv256_down_out: o,
            fc: i,
          },
          paramMappings: r,
        }
      }),
      Gf)
  function Gf() {
    return zf.call(this, 'FaceRecognitionNet') || this
  }
  function Uf(t, e) {
    e = { descriptor: e }
    return Object.assign({}, t, e)
  }
  function Vf(t, e) {
    e = { age: e }
    return Object.assign({}, t, e)
  }
  function Hf(t, e, n) {
    n = { gender: e, genderProbability: n }
    return Object.assign({}, t, n)
  }
  var jf =
    (Object.defineProperty(qf.prototype, 'minFaceSize', {
      get: function () {
        return this._minFaceSize
      },
      enumerable: !0,
      configurable: !0,
    }),
    Object.defineProperty(qf.prototype, 'scaleFactor', {
      get: function () {
        return this._scaleFactor
      },
      enumerable: !0,
      configurable: !0,
    }),
    Object.defineProperty(qf.prototype, 'maxNumScales', {
      get: function () {
        return this._maxNumScales
      },
      enumerable: !0,
      configurable: !0,
    }),
    Object.defineProperty(qf.prototype, 'scoreThresholds', {
      get: function () {
        return this._scoreThresholds
      },
      enumerable: !0,
      configurable: !0,
    }),
    Object.defineProperty(qf.prototype, 'scaleSteps', {
      get: function () {
        return this._scaleSteps
      },
      enumerable: !0,
      configurable: !0,
    }),
    qf)
  function qf(t) {
    var e = void 0 === t ? {} : t,
      n = e.minFaceSize,
      r = e.scaleFactor,
      o = e.maxNumScales,
      t = e.scoreThresholds,
      e = e.scaleSteps
    if (
      ((this._name = 'MtcnnOptions'),
      (this._minFaceSize = n || 20),
      (this._scaleFactor = r || 0.709),
      (this._maxNumScales = o || 10),
      (this._scoreThresholds = t || [0.6, 0.7, 0.7]),
      (this._scaleSteps = e),
      'number' != typeof this._minFaceSize || this._minFaceSize < 0)
    )
      throw new Error(this._name + ' - expected minFaceSize to be a number > 0')
    if ('number' != typeof this._scaleFactor || this._scaleFactor <= 0 || 1 <= this._scaleFactor)
      throw new Error(this._name + ' - expected scaleFactor to be a number between 0 and 1')
    if ('number' != typeof this._maxNumScales || this._maxNumScales < 0)
      throw new Error(this._name + ' - expected maxNumScales to be a number > 0')
    if (
      !Array.isArray(this._scoreThresholds) ||
      3 !== this._scoreThresholds.length ||
      this._scoreThresholds.some(function (t) {
        return 'number' != typeof t
      })
    )
      throw new Error(this._name + ' - expected scoreThresholds to be an array of numbers of length 3')
    if (
      this._scaleSteps &&
      (!Array.isArray(this._scaleSteps) ||
        this._scaleSteps.some(function (t) {
          return 'number' != typeof t
        }))
    )
      throw new Error(this._name + ' - expected scaleSteps to be an array of numbers')
  }
  function Kf(c, l) {
    function o(t, e, n, r, o) {
      ;(t = vn(c(t * e * n * n), [n, n, t, e])), (e = pn(c(e)))
      return (
        l.push({ paramPath: r + '/filters' }, { paramPath: r + '/' + (o ? 'batch_norm_offset' : 'bias') }),
        { filters: t, bias: e }
      )
    }
    function h(t, e, n, r) {
      r = o(t, e, n, r, !0)
      return { filters: r.filters, batch_norm_offset: r.bias }
    }
    function t(t, e, n) {
      var r, o, i, a, s, u
      return {
        depthwise_conv:
          ((o = n + '/depthwise_conv'),
          (i = vn(c(9 * (r = t)), [3, 3, r, 1])),
          (a = pn(c(r))),
          (s = pn(c(r))),
          (u = pn(c(r))),
          (r = pn(c(r))),
          l.push(
            { paramPath: o + '/filters' },
            { paramPath: o + '/batch_norm_scale' },
            { paramPath: o + '/batch_norm_offset' },
            { paramPath: o + '/batch_norm_mean' },
            { paramPath: o + '/batch_norm_variance' },
          ),
          { filters: i, batch_norm_scale: a, batch_norm_offset: s, batch_norm_mean: u, batch_norm_variance: r }),
        pointwise_conv: h(t, e, 1, n + '/pointwise_conv'),
      }
    }
    return {
      extractMobilenetV1Params: function () {
        return {
          conv_0: h(3, 32, 3, 'mobilenetv1/conv_0'),
          conv_1: t(32, 64, 'mobilenetv1/conv_1'),
          conv_2: t(64, 128, 'mobilenetv1/conv_2'),
          conv_3: t(128, 128, 'mobilenetv1/conv_3'),
          conv_4: t(128, 256, 'mobilenetv1/conv_4'),
          conv_5: t(256, 256, 'mobilenetv1/conv_5'),
          conv_6: t(256, 512, 'mobilenetv1/conv_6'),
          conv_7: t(512, 512, 'mobilenetv1/conv_7'),
          conv_8: t(512, 512, 'mobilenetv1/conv_8'),
          conv_9: t(512, 512, 'mobilenetv1/conv_9'),
          conv_10: t(512, 512, 'mobilenetv1/conv_10'),
          conv_11: t(512, 512, 'mobilenetv1/conv_11'),
          conv_12: t(512, 1024, 'mobilenetv1/conv_12'),
          conv_13: t(1024, 1024, 'mobilenetv1/conv_13'),
        }
      },
      extractPredictionLayerParams: function () {
        return {
          conv_0: h(1024, 256, 1, 'prediction_layer/conv_0'),
          conv_1: h(256, 512, 3, 'prediction_layer/conv_1'),
          conv_2: h(512, 128, 1, 'prediction_layer/conv_2'),
          conv_3: h(128, 256, 3, 'prediction_layer/conv_3'),
          conv_4: h(256, 128, 1, 'prediction_layer/conv_4'),
          conv_5: h(128, 256, 3, 'prediction_layer/conv_5'),
          conv_6: h(256, 64, 1, 'prediction_layer/conv_6'),
          conv_7: h(64, 128, 3, 'prediction_layer/conv_7'),
          box_predictor_0: {
            box_encoding_predictor: o(512, 12, 1, 'prediction_layer/box_predictor_0/box_encoding_predictor'),
            class_predictor: o(512, 9, 1, 'prediction_layer/box_predictor_0/class_predictor'),
          },
          box_predictor_1: {
            box_encoding_predictor: o(1024, 24, 1, 'prediction_layer/box_predictor_1/box_encoding_predictor'),
            class_predictor: o(1024, 18, 1, 'prediction_layer/box_predictor_1/class_predictor'),
          },
          box_predictor_2: {
            box_encoding_predictor: o(512, 24, 1, 'prediction_layer/box_predictor_2/box_encoding_predictor'),
            class_predictor: o(512, 18, 1, 'prediction_layer/box_predictor_2/class_predictor'),
          },
          box_predictor_3: {
            box_encoding_predictor: o(256, 24, 1, 'prediction_layer/box_predictor_3/box_encoding_predictor'),
            class_predictor: o(256, 18, 1, 'prediction_layer/box_predictor_3/class_predictor'),
          },
          box_predictor_4: {
            box_encoding_predictor: o(256, 24, 1, 'prediction_layer/box_predictor_4/box_encoding_predictor'),
            class_predictor: o(256, 18, 1, 'prediction_layer/box_predictor_4/class_predictor'),
          },
          box_predictor_5: {
            box_encoding_predictor: o(128, 24, 1, 'prediction_layer/box_predictor_5/box_encoding_predictor'),
            class_predictor: o(128, 18, 1, 'prediction_layer/box_predictor_5/class_predictor'),
          },
        }
      },
    }
  }
  function Xf(t) {
    var o,
      e = [],
      n =
        ((o = Hd(t, e)),
        {
          extractMobilenetV1Params: function () {
            return {
              conv_0: a('MobilenetV1', 0, 'mobilenetv1/conv_0'),
              conv_1: s(1),
              conv_2: s(2),
              conv_3: s(3),
              conv_4: s(4),
              conv_5: s(5),
              conv_6: s(6),
              conv_7: s(7),
              conv_8: s(8),
              conv_9: s(9),
              conv_10: s(10),
              conv_11: s(11),
              conv_12: s(12),
              conv_13: s(13),
            }
          },
          extractPredictionLayerParams: function () {
            return {
              conv_0: a('Prediction', 0, 'prediction_layer/conv_0'),
              conv_1: a('Prediction', 1, 'prediction_layer/conv_1'),
              conv_2: a('Prediction', 2, 'prediction_layer/conv_2'),
              conv_3: a('Prediction', 3, 'prediction_layer/conv_3'),
              conv_4: a('Prediction', 4, 'prediction_layer/conv_4'),
              conv_5: a('Prediction', 5, 'prediction_layer/conv_5'),
              conv_6: a('Prediction', 6, 'prediction_layer/conv_6'),
              conv_7: a('Prediction', 7, 'prediction_layer/conv_7'),
              box_predictor_0: c(0),
              box_predictor_1: c(1),
              box_predictor_2: c(2),
              box_predictor_3: c(3),
              box_predictor_4: c(4),
              box_predictor_5: c(5),
            }
          },
        }),
      r = n.extractMobilenetV1Params,
      i = n.extractPredictionLayerParams
    function a(t, e, n) {
      return {
        filters: o(t + '/Conv2d_' + e + '_pointwise/weights', 4, n + '/filters'),
        batch_norm_offset: o(t + '/Conv2d_' + e + '_pointwise/convolution_bn_offset', 1, n + '/batch_norm_offset'),
      }
    }
    function s(t) {
      var e = 'mobilenetv1/conv_' + t,
        n = 'MobilenetV1/Conv2d_' + t + '_depthwise',
        r = e + '/depthwise_conv',
        e = e + '/pointwise_conv'
      return {
        depthwise_conv: {
          filters: o(n + '/depthwise_weights', 4, r + '/filters'),
          batch_norm_scale: o(n + '/BatchNorm/gamma', 1, r + '/batch_norm_scale'),
          batch_norm_offset: o(n + '/BatchNorm/beta', 1, r + '/batch_norm_offset'),
          batch_norm_mean: o(n + '/BatchNorm/moving_mean', 1, r + '/batch_norm_mean'),
          batch_norm_variance: o(n + '/BatchNorm/moving_variance', 1, r + '/batch_norm_variance'),
        },
        pointwise_conv: a('MobilenetV1', t, e),
      }
    }
    function u(t, e) {
      return { filters: o(t + '/weights', 4, e + '/filters'), bias: o(t + '/biases', 1, e + '/bias') }
    }
    function c(t) {
      return {
        box_encoding_predictor: u(
          'Prediction/BoxPredictor_' + t + '/BoxEncodingPredictor',
          'prediction_layer/box_predictor_' + t + '/box_encoding_predictor',
        ),
        class_predictor: u(
          'Prediction/BoxPredictor_' + t + '/ClassPredictor',
          'prediction_layer/box_predictor_' + t + '/class_predictor',
        ),
      }
    }
    n = t['Output/extra_dim']
    if ((e.push({ originalPath: 'Output/extra_dim', paramPath: 'output_layer/extra_dim' }), !bp(n)))
      throw new Error("expected weightMap['Output/extra_dim'] to be a Tensor3D, instead have " + n)
    n = { mobilenetv1: r(), prediction_layer: i(), output_layer: { extra_dim: n } }
    return Ld(t, e), { params: n, paramMappings: e }
  }
  function $f(e, n, r) {
    return Ge(function () {
      var t = Ku(e, n.filters, r, 'same'),
        t = au(t, n.batch_norm_offset)
      return fs(t, 0, 6)
    })
  }
  var Yf = 0.0010000000474974513
  function Jf(t, e) {
    return Ge(function () {
      var s = null,
        u = $f(t, e.conv_0, [2, 2])
      if (
        ([
          e.conv_1,
          e.conv_2,
          e.conv_3,
          e.conv_4,
          e.conv_5,
          e.conv_6,
          e.conv_7,
          e.conv_8,
          e.conv_9,
          e.conv_10,
          e.conv_11,
          e.conv_12,
          e.conv_13,
        ].forEach(function (t, e) {
          var n,
            r,
            o,
            i,
            a = e + 1,
            e =
              ((n = a),
              [2, 4, 6, 12].some(function (t) {
                return t === n
              })
                ? [2, 2]
                : [1, 1])
          ;(r = u),
            (o = t.depthwise_conv),
            (i = e),
            (u = $f(
              (u = Ge(function () {
                var t = Ju(r, o.filters, i, 'same'),
                  t = Js(t, o.batch_norm_mean, o.batch_norm_variance, o.batch_norm_offset, o.batch_norm_scale, Yf)
                return fs(t, 0, 6)
              })),
              t.pointwise_conv,
              [1, 1],
            )),
            11 === a && (s = u)
        }),
        null === s)
      )
        throw new Error('mobileNetV1 - output of conv layer 11 is null')
      return { out: u, conv11: s }
    })
  }
  function Qf(o, t, e, i, a) {
    var n = o.shape[0],
      s = Math.min(e, n),
      t = t
        .map(function (t, e) {
          return { score: t, boxIndex: e }
        })
        .filter(function (t) {
          return t.score > a
        })
        .sort(function (t, e) {
          return e.score - t.score
        }),
      u = []
    return (
      t.forEach(function (t) {
        if (!(u.length >= s)) {
          for (var e = t.score, n = u.length - 1; 0 <= n; --n) {
            var r = (function (t, e, n) {
              var r = t.arraySync(),
                o = Math.min(r[e][0], r[e][2]),
                i = Math.min(r[e][1], r[e][3]),
                a = Math.max(r[e][0], r[e][2]),
                s = Math.max(r[e][1], r[e][3]),
                u = Math.min(r[n][0], r[n][2]),
                c = Math.min(r[n][1], r[n][3]),
                t = Math.max(r[n][0], r[n][2]),
                e = Math.max(r[n][1], r[n][3]),
                r = (a - o) * (s - i),
                n = (t - u) * (e - c)
              if (r <= 0 || n <= 0) return 0
              ;(u = Math.max(o, u)),
                (c = Math.max(i, c)),
                (t = Math.min(a, t)),
                (e = Math.min(s, e)),
                (c = Math.max(t - u, 0) * Math.max(e - c, 0))
              return c / (r + n - c)
            })(o, t.boxIndex, u[n])
            if (0 !== r && ((t.score *= r <= i ? 1 : 0), t.score <= a)) break
          }
          e === t.score && u.push(t.boxIndex)
        }
      }),
      u
    )
  }
  function Zf(t, e) {
    var n =
        ((o = vr(Gc((i = t), [1, 0]))),
        { sizes: (i = [_u(o[2], o[0]), _u(o[3], o[1])]), centers: [au(o[0], lu(i[0], hn(2))), au(o[1], lu(i[1], hn(2)))] }),
      r = n.sizes,
      t = n.centers,
      o = vr(Gc(e, [1, 0])),
      i = lu(xu(ys(lu(o[2], hn(5))), r[0]), hn(2)),
      n = au(xu(lu(o[0], hn(10)), r[0]), t[0]),
      e = lu(xu(ys(lu(o[3], hn(5))), r[1]), hn(2)),
      t = au(xu(lu(o[1], hn(10)), r[1]), t[1])
    return Gc(pr([_u(n, i), _u(t, e), au(n, i), au(t, e)]), [1, 0])
  }
  function tv(e, n) {
    return Ge(function () {
      var t = e.shape[0]
      return {
        boxPredictionEncoding: cr(Bd(e, n.box_encoding_predictor), [t, -1, 1, 4]),
        classPrediction: cr(Bd(e, n.class_predictor), [t, -1, 3]),
      }
    })
  }
  var ev =
    (Object.defineProperty(nv.prototype, 'minConfidence', {
      get: function () {
        return this._minConfidence
      },
      enumerable: !0,
      configurable: !0,
    }),
    Object.defineProperty(nv.prototype, 'maxResults', {
      get: function () {
        return this._maxResults
      },
      enumerable: !0,
      configurable: !0,
    }),
    nv)
  function nv(t) {
    var e = void 0 === t ? {} : t,
      t = e.minConfidence,
      e = e.maxResults
    if (
      ((this._name = 'SsdMobilenetv1Options'),
      (this._minConfidence = t || 0.5),
      (this._maxResults = e || 100),
      'number' != typeof this._minConfidence || this._minConfidence <= 0 || 1 <= this._minConfidence)
    )
      throw new Error(this._name + ' - expected minConfidence to be a number between 0 and 1')
    if ('number' != typeof this._maxResults) throw new Error(this._name + ' - expected maxResults to be a number')
  }
  var rv,
    ov,
    Dt =
      (hp(iv, (rv = al)),
      (iv.prototype.forwardInput = function (n) {
        var c = this.params
        if (!c) throw new Error('SsdMobilenetv1 - load model before inference')
        return Ge(function () {
          var a,
            s,
            u,
            r,
            o,
            i,
            t = n.toBatchTensor(512, !1).toFloat(),
            e = Jf(_u(xu(t, hn(0.007843137718737125)), hn(1)), c.mobilenetv1),
            t =
              ((a = e.out),
              (s = e.conv11),
              (u = c.prediction_layer),
              Ge(function () {
                var t = $f(a, u.conv_0, [1, 1]),
                  e = $f(t, u.conv_1, [2, 2]),
                  n = $f(e, u.conv_2, [1, 1]),
                  r = $f(n, u.conv_3, [2, 2]),
                  o = $f(r, u.conv_4, [1, 1]),
                  i = $f(o, u.conv_5, [2, 2]),
                  t = $f(i, u.conv_6, [1, 1]),
                  n = $f(t, u.conv_7, [2, 2]),
                  o = tv(s, u.box_predictor_0),
                  t = tv(a, u.box_predictor_1),
                  e = tv(e, u.box_predictor_2),
                  r = tv(r, u.box_predictor_3),
                  i = tv(i, u.box_predictor_4),
                  n = tv(n, u.box_predictor_5)
                return {
                  boxPredictions: Cn(
                    [
                      o.boxPredictionEncoding,
                      t.boxPredictionEncoding,
                      e.boxPredictionEncoding,
                      r.boxPredictionEncoding,
                      i.boxPredictionEncoding,
                      n.boxPredictionEncoding,
                    ],
                    1,
                  ),
                  classPredictions: Cn(
                    [
                      o.classPrediction,
                      t.classPrediction,
                      e.classPrediction,
                      r.classPrediction,
                      i.classPrediction,
                      n.classPrediction,
                    ],
                    1,
                  ),
                }
              })),
            e = t.boxPredictions,
            t = t.classPredictions
          return (
            (r = e),
            (o = t),
            (i = c.output_layer),
            Ge(function () {
              var t = r.shape[0],
                e = Zf(cr(dr(i.extra_dim, [t, 1, 1]), [-1, 4]), cr(r, [-1, 4])),
                e = cr(e, [t, e.shape[0] / t, 4]),
                n = As(yc(o, [0, 0, 1], [-1, -1, -1])),
                n = yc(n, [0, 0, 0], [-1, -1, 1]),
                n = cr(n, [t, n.shape[1]])
              return { boxes: vr(e), scores: vr(n) }
            })
          )
        })
      }),
      (iv.prototype.forward = function (n) {
        return dp(this, void 0, void 0, function () {
          var e
          return fp(this, function (t) {
            switch (t.label) {
              case 0:
                return (e = this.forwardInput), [4, Ad(n)]
              case 1:
                return [2, e.apply(this, [t.sent()])]
            }
          })
        })
      }),
      (iv.prototype.locateFaces = function (v, m) {
        return (
          void 0 === m && (m = {}),
          dp(this, void 0, void 0, function () {
            var i, e, n, r, o, a, s, u, c, l, h, p, d, f
            return fp(this, function (t) {
              switch (t.label) {
                case 0:
                  return (l = new ev(m)), (c = l.maxResults), (l = l.minConfidence), [4, Ad(v)]
                case 1:
                  for (
                    i = t.sent(), u = this.forwardInput(i), e = u.boxes, n = u.scores, r = e[0], o = n[0], a = 1;
                    a < e.length;
                    a++
                  )
                    e[a].dispose(), n[a].dispose()
                  return (u = (f = Array).from), [4, o.data()]
                case 2:
                  return (
                    (s = u.apply(f, [t.sent()])),
                    (f = Qf(r, s, c, 0.5, l)),
                    (c = i.getReshapedInputDimensions(0)),
                    (l = i.inputSize),
                    (h = l / c.width),
                    (p = l / c.height),
                    (d = r.arraySync()),
                    (f = f.map(function (t) {
                      var e = [Math.max(0, d[t][0]), Math.min(1, d[t][2])].map(function (t) {
                          return t * p
                        }),
                        n = e[0],
                        r = e[1],
                        o = [Math.max(0, d[t][1]), Math.min(1, d[t][3])].map(function (t) {
                          return t * h
                        }),
                        e = o[0],
                        o = o[1]
                      return new Bp(s[t], new Vp(e, n, o - e, r - n), {
                        height: i.getInputHeight(0),
                        width: i.getInputWidth(0),
                      })
                    })),
                    r.dispose(),
                    o.dispose(),
                    [2, f]
                  )
              }
            })
          })
        )
      }),
      (iv.prototype.getDefaultModelName = function () {
        return 'ssd_mobilenetv1_model'
      }),
      (iv.prototype.extractParamsFromWeigthMap = Xf),
      (iv.prototype.extractParams = function (t) {
        var e = [],
          n = (o = jd(t)).extractWeights,
          r = o.getRemainingWeights,
          o = (t = Kf(n, e)).extractMobilenetV1Params,
          t = t.extractPredictionLayerParams,
          o = o(),
          t = t(),
          n = { extra_dim: fn(n(20472), [1, 5118, 4]) }
        if ((e.push({ paramPath: 'output_layer/extra_dim' }), 0 !== r().length))
          throw new Error('weights remaing after extract: ' + r().length)
        return { params: { mobilenetv1: o, prediction_layer: t, output_layer: n }, paramMappings: e }
      }),
      iv)
  function iv() {
    return rv.call(this, 'SsdMobilenetv1') || this
  }
  function av() {
    return (null !== ov && ov.apply(this, arguments)) || this
  }
  hp(av, (ov = Dt))
  var sv = [
      new Ip(0.738768, 0.874946),
      new Ip(2.42204, 2.65704),
      new Ip(4.30971, 7.04493),
      new Ip(10.246, 4.59428),
      new Ip(12.6868, 11.8741),
    ],
    uv = [
      new Ip(1.603231, 2.094468),
      new Ip(6.041143, 7.080126),
      new Ip(2.882459, 3.518061),
      new Ip(4.266906, 5.178857),
      new Ip(9.041765, 10.66308),
    ],
    cv = [117.001, 114.697, 97.404],
    lv = function (t) {
      return 'number' == typeof t
    }
  function hv(e) {
    return Ge(function () {
      var t = xu(e, hn(0.10000000149011612))
      return au(Lc(_u(e, t)), t)
    })
  }
  function pv(e, n) {
    return Ge(function () {
      var t = tr(e, [
          [0, 0],
          [1, 1],
          [1, 1],
          [0, 0],
        ]),
        t = Ku(t, n.conv.filters, [1, 1], 'valid')
      return (t = _u(t, n.bn.sub)), (t = xu(t, n.bn.truediv)), hv(au(t, n.conv.bias))
    })
  }
  function dv(e, n) {
    return Ge(function () {
      var t = tr(e, [
          [0, 0],
          [1, 1],
          [1, 1],
          [0, 0],
        ]),
        t = tc(t, n.depthwise_filter, n.pointwise_filter, [1, 1], 'valid')
      return hv(au(t, n.bias))
    })
  }
  function fv(r, o) {
    var i = Wd(r, o)
    var t = Ud(r, o)
    return {
      extractConvParams: i,
      extractConvWithBatchNormParams: function (t, e, n) {
        return {
          conv: i(t, e, 3, n + '/conv'),
          bn:
            ((t = n + '/bn'),
            (e = pn(r((n = e)))),
            (n = pn(r(n))),
            o.push({ paramPath: t + '/sub' }, { paramPath: t + '/truediv' }),
            { sub: e, truediv: n }),
        }
      },
      extractSeparableConvParams: t,
    }
  }
  function vv(t, e) {
    var n = Hd(t, e)
    function r(t) {
      return { filters: n(t + '/filters', 4), bias: n(t + '/bias', 1) }
    }
    return {
      extractConvParams: r,
      extractConvWithBatchNormParams: function (t) {
        return { conv: r(t + '/conv'), bn: { sub: n((t = t + '/bn') + '/sub', 1), truediv: n(t + '/truediv', 1) } }
      },
      extractSeparableConvParams: Vd(n),
    }
  }
  ;((Vi = {})[(Vi.XS = 224)] = 'XS'), (Vi[(Vi.SM = 320)] = 'SM'), (Vi[(Vi.MD = 416)] = 'MD'), (Vi[(Vi.LG = 608)] = 'LG')
  var mv =
    (Object.defineProperty(gv.prototype, 'inputSize', {
      get: function () {
        return this._inputSize
      },
      enumerable: !0,
      configurable: !0,
    }),
    Object.defineProperty(gv.prototype, 'scoreThreshold', {
      get: function () {
        return this._scoreThreshold
      },
      enumerable: !0,
      configurable: !0,
    }),
    gv)
  function gv(t) {
    var e = void 0 === t ? {} : t,
      t = e.inputSize,
      e = e.scoreThreshold
    if (
      ((this._name = 'TinyYolov2Options'),
      (this._inputSize = t || 416),
      (this._scoreThreshold = e || 0.5),
      'number' != typeof this._inputSize || this._inputSize % 32 != 0)
    )
      throw new Error(this._name + ' - expected inputSize to be a number divisible by 32')
    if ('number' != typeof this._scoreThreshold || this._scoreThreshold <= 0 || 1 <= this._scoreThreshold)
      throw new Error(this._name + ' - expected scoreThreshold to be a number between 0 and 1')
  }
  var yv,
    ul =
      (hp(bv, (yv = al)),
      Object.defineProperty(bv.prototype, 'config', {
        get: function () {
          return this._config
        },
        enumerable: !0,
        configurable: !0,
      }),
      Object.defineProperty(bv.prototype, 'withClassScores', {
        get: function () {
          return this.config.withClassScores || 1 < this.config.classes.length
        },
        enumerable: !0,
        configurable: !0,
      }),
      Object.defineProperty(bv.prototype, 'boxEncodingSize', {
        get: function () {
          return 5 + (this.withClassScores ? this.config.classes.length : 0)
        },
        enumerable: !0,
        configurable: !0,
      }),
      (bv.prototype.runTinyYolov2 = function (t, e) {
        t = pv(t, e.conv0)
        return (
          (t = pv((t = dc(t, [2, 2], [2, 2], 'same')), e.conv1)),
          (t = pv((t = dc(t, [2, 2], [2, 2], 'same')), e.conv2)),
          (t = pv((t = dc(t, [2, 2], [2, 2], 'same')), e.conv3)),
          (t = pv((t = dc(t, [2, 2], [2, 2], 'same')), e.conv4)),
          (t = pv((t = dc(t, [2, 2], [2, 2], 'same')), e.conv5)),
          (t = pv((t = dc(t, [2, 2], [1, 1], 'same')), e.conv6)),
          Bd((t = pv(t, e.conv7)), e.conv8, 'valid', !1)
        )
      }),
      (bv.prototype.runMobilenet = function (t, e) {
        t = this.config.isFirstLayerConv2d ? hv(Bd(t, e.conv0, 'valid', !1)) : dv(t, e.conv0)
        return (
          (t = dv((t = dc(t, [2, 2], [2, 2], 'same')), e.conv1)),
          (t = dv((t = dc(t, [2, 2], [2, 2], 'same')), e.conv2)),
          (t = dv((t = dc(t, [2, 2], [2, 2], 'same')), e.conv3)),
          (t = dv((t = dc(t, [2, 2], [2, 2], 'same')), e.conv4)),
          (t = dv((t = dc(t, [2, 2], [2, 2], 'same')), e.conv5)),
          (t = dc(t, [2, 2], [1, 1], 'same')),
          (t = e.conv6 ? dv(t, e.conv6) : t),
          Bd((t = e.conv7 ? dv(t, e.conv7) : t), e.conv8, 'valid', !1)
        )
      }),
      (bv.prototype.forwardInput = function (e, n) {
        var r = this,
          o = this.params
        if (!o) throw new Error('TinyYolov2 - load model before inference')
        return Ge(function () {
          var t = e.toBatchTensor(n, !1).toFloat()
          return (
            (t = (t = r.config.meanRgb ? zp(t, r.config.meanRgb) : t).div(hn(256))),
            r.config.withSeparableConvs ? r.runMobilenet(t, o) : r.runTinyYolov2(t, o)
          )
        })
      }),
      (bv.prototype.forward = function (n, r) {
        return dp(this, void 0, void 0, function () {
          var e
          return fp(this, function (t) {
            switch (t.label) {
              case 0:
                return (e = this.forwardInput), [4, Ad(n)]
              case 1:
                return [4, e.apply(this, [t.sent(), r])]
              case 2:
                return [2, t.sent()]
            }
          })
        })
      }),
      (bv.prototype.detect = function (p, d) {
        return (
          void 0 === d && (d = {}),
          dp(this, void 0, void 0, function () {
            var e,
              n,
              r,
              o,
              i,
              a,
              s,
              u,
              c,
              l,
              h = this
            return fp(this, function (t) {
              switch (t.label) {
                case 0:
                  return (l = new mv(d)), (e = l.inputSize), (l = l.scoreThreshold), [4, Ad(p)]
                case 1:
                  return (n = t.sent()), [4, this.forwardInput(n, e)]
                case 2:
                  return (
                    (r = t.sent()),
                    (o = Ge(function () {
                      return vr(r)[0].expandDims()
                    })),
                    (i = { width: n.getInputWidth(0), height: n.getInputHeight(0) }),
                    [4, this.extractBoxes(o, n.getReshapedInputDimensions(0), l)]
                  )
                case 3:
                  return (
                    (l = t.sent()),
                    r.dispose(),
                    o.dispose(),
                    (a = l.map(function (t) {
                      return t.box
                    })),
                    (s = l.map(function (t) {
                      return t.score
                    })),
                    (u = l.map(function (t) {
                      return t.classScore
                    })),
                    (c = l.map(function (t) {
                      return h.config.classes[t.label]
                    })),
                    (l = Wp(
                      a.map(function (t) {
                        return t.rescale(e)
                      }),
                      s,
                      this.config.iouThreshold,
                      !0,
                    )),
                    [
                      2,
                      l.map(function (t) {
                        return new Fp(s[t], u[t], c[t], a[t], i)
                      }),
                    ]
                  )
              }
            })
          })
        )
      }),
      (bv.prototype.getDefaultModelName = function () {
        return ''
      }),
      (bv.prototype.extractParamsFromWeigthMap = function (t) {
        return (
          (e = t),
          (n = this.config),
          (o = vv(e, (r = []))),
          (i = o.extractConvParams),
          (a = o.extractConvWithBatchNormParams),
          (t = o.extractSeparableConvParams),
          (i = n.withSeparableConvs
            ? ((o = (n.filterSizes && n.filterSizes.length) || 9),
              {
                conv0: (n.isFirstLayerConv2d ? i : t)('conv0'),
                conv1: t('conv1'),
                conv2: t('conv2'),
                conv3: t('conv3'),
                conv4: t('conv4'),
                conv5: t('conv5'),
                conv6: 7 < o ? t('conv6') : void 0,
                conv7: 8 < o ? t('conv7') : void 0,
                conv8: i('conv8'),
              })
            : {
                conv0: a('conv0'),
                conv1: a('conv1'),
                conv2: a('conv2'),
                conv3: a('conv3'),
                conv4: a('conv4'),
                conv5: a('conv5'),
                conv6: a('conv6'),
                conv7: a('conv7'),
                conv8: i('conv8'),
              }),
          Ld(e, r),
          { params: i, paramMappings: r }
        )
        var e, n, r, o, i, a
      }),
      (bv.prototype.extractParams = function (t) {
        var e = this.config.filterSizes || bv.DEFAULT_FILTER_SIZES,
          n = e ? e.length : void 0
        if (7 !== n && 8 !== n && 9 !== n)
          throw new Error('TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found ' + n + ' filterSizes in config')
        return (function (t, e, n, r) {
          var o,
            i,
            a,
            s,
            u,
            c,
            l,
            h,
            p,
            d = (m = jd(t)).extractWeights,
            f = m.getRemainingWeights,
            v = [],
            m = (t = fv(d, v)).extractConvParams,
            d = t.extractConvWithBatchNormParams,
            t = t.extractSeparableConvParams
          if (
            ((n = e.withSeparableConvs
              ? ((o = r[0]),
                (i = r[1]),
                (a = r[2]),
                (s = r[3]),
                (u = r[4]),
                (c = r[5]),
                (l = r[6]),
                (h = r[7]),
                (p = r[8]),
                {
                  conv0: e.isFirstLayerConv2d ? m(o, i, 3, 'conv0') : t(o, i, 'conv0'),
                  conv1: t(i, a, 'conv1'),
                  conv2: t(a, s, 'conv2'),
                  conv3: t(s, u, 'conv3'),
                  conv4: t(u, c, 'conv4'),
                  conv5: t(c, l, 'conv5'),
                  conv6: h ? t(l, h, 'conv6') : void 0,
                  conv7: p ? t(h, p, 'conv7') : void 0,
                  conv8: m(p || h || l, 5 * n, 1, 'conv8'),
                })
              : ((o = r[0]),
                (i = r[1]),
                (a = r[2]),
                (s = r[3]),
                (u = r[4]),
                (c = r[5]),
                (l = r[6]),
                (h = r[7]),
                (p = r[8]),
                {
                  conv0: d(o, i, 'conv0'),
                  conv1: d(i, a, 'conv1'),
                  conv2: d(a, s, 'conv2'),
                  conv3: d(s, u, 'conv3'),
                  conv4: d(u, c, 'conv4'),
                  conv5: d(c, l, 'conv5'),
                  conv6: d(l, h, 'conv6'),
                  conv7: d(h, p, 'conv7'),
                  conv8: m(p, 5 * n, 1, 'conv8'),
                })),
            0 !== f().length)
          )
            throw new Error('weights remaing after extract: ' + f().length)
          return { params: n, paramMappings: v }
        })(t, this.config, this.boxEncodingSize, e)
      }),
      (bv.prototype.extractBoxes = function (E, S, _) {
        return dp(this, void 0, void 0, function () {
          var e,
            n,
            r,
            o,
            i,
            a,
            s,
            u,
            c,
            l,
            h,
            p,
            d,
            f,
            v,
            m,
            g,
            y,
            b,
            x,
            w,
            C = this
          return fp(this, function (t) {
            switch (t.label) {
              case 0:
                return (
                  (i = S.width),
                  (s = S.height),
                  (a = Math.max(i, s)),
                  (e = a / i),
                  (n = a / s),
                  (r = E.shape[1]),
                  (o = this.config.anchors.length),
                  (u = Ge(function () {
                    var t = E.reshape([r, r, o, C.boxEncodingSize])
                    return [
                      t.slice([0, 0, 0, 0], [r, r, o, 4]),
                      t.slice([0, 0, 0, 4], [r, r, o, 1]),
                      C.withClassScores ? Fr(t.slice([0, 0, 0, 5], [r, r, o, C.config.classes.length]), 3) : hn(0),
                    ]
                  })),
                  (i = u[0]),
                  (a = u[1]),
                  (s = u[2]),
                  (u = []),
                  [4, a.array()]
                )
              case 1:
                return (c = t.sent()), [4, i.array()]
              case 2:
                ;(l = t.sent()), (h = 0), (t.label = 3)
              case 3:
                if (!(h < r)) return [3, 12]
                ;(p = 0), (t.label = 4)
              case 4:
                if (!(p < r)) return [3, 11]
                ;(d = 0), (t.label = 5)
              case 5:
                return d < o
                  ? ((f = Gp(c[h][p][d][0])),
                    !_ || _ < f
                      ? ((b = ((p + Gp(l[h][p][d][0])) / r) * e),
                        (x = ((h + Gp(l[h][p][d][1])) / r) * n),
                        (v = ((Math.exp(l[h][p][d][2]) * this.config.anchors[d].x) / r) * e),
                        (m = ((Math.exp(l[h][p][d][3]) * this.config.anchors[d].y) / r) * n),
                        (g = b - v / 2),
                        (y = x - m / 2),
                        (b = { row: h, col: p, anchor: d }),
                        this.withClassScores ? [4, this.extractPredictedClass(s, b)] : [3, 7])
                      : [3, 9])
                  : [3, 10]
              case 6:
                return (w = t.sent()), [3, 8]
              case 7:
                ;(w = { classScore: 1, label: 0 }), (t.label = 8)
              case 8:
                ;(x = w.classScore),
                  (w = w.label),
                  u.push(pp({ box: new Dp(g, y, g + v, y + m), score: f, classScore: f * x, label: w }, b)),
                  (t.label = 9)
              case 9:
                return d++, [3, 5]
              case 10:
                return p++, [3, 4]
              case 11:
                return h++, [3, 3]
              case 12:
                return i.dispose(), a.dispose(), s.dispose(), [2, u]
            }
          })
        })
      }),
      (bv.prototype.extractPredictedClass = function (e, a) {
        return dp(this, void 0, void 0, function () {
          var n, r, o, i
          return fp(this, function (t) {
            switch (t.label) {
              case 0:
                return (n = a.row), (r = a.col), (o = a.anchor), [4, e.array()]
              case 1:
                return (
                  (i = t.sent()),
                  [
                    2,
                    Array(this.config.classes.length)
                      .fill(0)
                      .map(function (t, e) {
                        return i[n][r][o][e]
                      })
                      .map(function (t, e) {
                        return { classScore: t, label: e }
                      })
                      .reduce(function (t, e) {
                        return t.classScore > e.classScore ? t : e
                      }),
                  ]
                )
            }
          })
        })
      }),
      (bv.DEFAULT_FILTER_SIZES = [3, 16, 32, 64, 128, 256, 512, 1024, 1024]),
      bv)
  function bv(t) {
    var e = yv.call(this, 'TinyYolov2') || this
    return (
      (function (t) {
        if (!t) throw new Error('invalid config: ' + t)
        if ('boolean' != typeof t.withSeparableConvs)
          throw new Error('config.withSeparableConvs has to be a boolean, have: ' + t.withSeparableConvs)
        if (!lv(t.iouThreshold) || t.iouThreshold < 0 || 1 < t.iouThreshold)
          throw new Error('config.iouThreshold has to be a number between [0, 1], have: ' + t.iouThreshold)
        if (
          !Array.isArray(t.classes) ||
          !t.classes.length ||
          !t.classes.every(function (t) {
            return 'string' == typeof t
          })
        )
          throw new Error('config.classes has to be an array class names: string[], have: ' + JSON.stringify(t.classes))
        if (
          !Array.isArray(t.anchors) ||
          !t.anchors.length ||
          !t.anchors
            .map(function (t) {
              return t || {}
            })
            .every(function (t) {
              return lv(t.x) && lv(t.y)
            })
        )
          throw new Error('config.anchors has to be an array of { x: number, y: number }, have: ' + JSON.stringify(t.anchors))
        if (t.meanRgb && (!Array.isArray(t.meanRgb) || 3 !== t.meanRgb.length || !t.meanRgb.every(lv)))
          throw new Error(
            'config.meanRgb has to be an array of shape [number, number, number], have: ' + JSON.stringify(t.meanRgb),
          )
      })(t),
      (e._config = t),
      e
    )
  }
  var xv,
    el =
      (hp(wv, (xv = ul)),
      Object.defineProperty(wv.prototype, 'withSeparableConvs', {
        get: function () {
          return this.config.withSeparableConvs
        },
        enumerable: !0,
        configurable: !0,
      }),
      Object.defineProperty(wv.prototype, 'anchors', {
        get: function () {
          return this.config.anchors
        },
        enumerable: !0,
        configurable: !0,
      }),
      (wv.prototype.locateFaces = function (e, n) {
        return dp(this, void 0, void 0, function () {
          return fp(this, function (t) {
            switch (t.label) {
              case 0:
                return [4, this.detect(e, n)]
              case 1:
                return [
                  2,
                  t.sent().map(function (t) {
                    return new Bp(t.score, t.relativeBox, { width: t.imageWidth, height: t.imageHeight })
                  }),
                ]
            }
          })
        })
      }),
      (wv.prototype.getDefaultModelName = function () {
        return this.withSeparableConvs ? 'tiny_yolov2_separable_conv_model' : 'tiny_yolov2_model'
      }),
      (wv.prototype.extractParamsFromWeigthMap = function (t) {
        return xv.prototype.extractParamsFromWeigthMap.call(this, t)
      }),
      wv)
  function wv(t) {
    void 0 === t && (t = !0)
    t = Object.assign(
      {},
      { withSeparableConvs: t, iouThreshold: 0.4, classes: ['face'] },
      t ? { anchors: uv, meanRgb: cv } : { anchors: sv, withClassScores: !0 },
    )
    return xv.call(this, t) || this
  }
  var Cv,
    Ev = (hp(Sv, (Cv = mv)), Sv)
  function Sv() {
    var t = (null !== Cv && Cv.apply(this, arguments)) || this
    return (t._name = 'TinyFaceDetectorOptions'), t
  }
  ;(_v.prototype.then = function (n) {
    return dp(this, void 0, void 0, function () {
      var e
      return fp(this, function (t) {
        switch (t.label) {
          case 0:
            return (e = n), [4, this.run()]
          case 1:
            return [2, e.apply(void 0, [t.sent()])]
        }
      })
    })
  }),
    (_v.prototype.run = function () {
      return dp(this, void 0, void 0, function () {
        return fp(this, function (t) {
          throw new Error('ComposableTask - run is not implemented')
        })
      })
    }),
    (Vi = _v)
  function _v() {}
  function Rv(i, a, s, u, c) {
    return (
      void 0 === c &&
        (c = function (t) {
          return t.alignedRect
        }),
      dp(this, void 0, void 0, function () {
        var e, n, r, o
        return fp(this, function (t) {
          switch (t.label) {
            case 0:
              return (
                (e = i.map(function (t) {
                  return cf(t) ? c(t) : t.detection
                })),
                (o = u) ? [3, 5] : a instanceof bt ? [4, kd(a, e)] : [3, 2]
              )
            case 1:
              return (r = t.sent()), [3, 4]
            case 2:
              return [4, Nd(a, e)]
            case 3:
              ;(r = t.sent()), (t.label = 4)
            case 4:
              ;(o = r), (t.label = 5)
            case 5:
              return [4, s((n = o))]
            case 6:
              return (
                (o = t.sent()),
                n.forEach(function (t) {
                  return t instanceof bt && t.dispose()
                }),
                [2, o]
              )
          }
        })
      })
    )
  }
  function Iv(e, r, o, i, a) {
    return dp(this, void 0, void 0, function () {
      var n = this
      return fp(this, function (t) {
        return [
          2,
          Rv(
            [e],
            r,
            function (e) {
              return dp(n, void 0, void 0, function () {
                return fp(this, function (t) {
                  return [2, o(e[0])]
                })
              })
            },
            i,
            a,
          ),
        ]
      })
    })
  }
  var Av = 2,
    Nv = 12
  function kv(n, r) {
    var u = Wd(n, r),
      c = zd(n, r)
    function l(t, e) {
      t = pn(n(t))
      return r.push({ paramPath: e }), t
    }
    function h(t, e, n) {
      return (
        void 0 === n && (n = !1),
        {
          conv1: u(t[0], t[1], 3, e + '/conv1'),
          prelu1_alpha: l(t[1], e + '/prelu1_alpha'),
          conv2: u(t[1], t[2], 3, e + '/conv2'),
          prelu2_alpha: l(t[2], e + '/prelu2_alpha'),
          conv3: u(t[2], t[3], n ? 2 : 3, e + '/conv3'),
          prelu3_alpha: l(t[3], e + '/prelu3_alpha'),
        }
      )
    }
    return {
      extractPNetParams: function () {
        var t = h([3, 10, 16, 32], 'pnet'),
          e = u(32, 2, 1, 'pnet/conv4_1'),
          n = u(32, 4, 1, 'pnet/conv4_2')
        return pp(pp({}, t), { conv4_1: e, conv4_2: n })
      },
      extractRNetParams: function () {
        var t = h([3, 28, 48, 64], 'rnet', !0),
          e = c(576, 128, 'rnet/fc1'),
          n = l(128, 'rnet/prelu4_alpha'),
          r = c(128, 2, 'rnet/fc2_1'),
          o = c(128, 4, 'rnet/fc2_2')
        return pp(pp({}, t), { fc1: e, prelu4_alpha: n, fc2_1: r, fc2_2: o })
      },
      extractONetParams: function () {
        var t = h([3, 32, 64, 64], 'onet'),
          e = u(64, 128, 2, 'onet/conv4'),
          n = l(128, 'onet/prelu4_alpha'),
          r = c(1152, 256, 'onet/fc1'),
          o = l(256, 'onet/prelu5_alpha'),
          i = c(256, 2, 'onet/fc2_1'),
          a = c(256, 4, 'onet/fc2_2'),
          s = c(256, 10, 'onet/fc2_3')
        return pp(pp({}, t), { conv4: e, prelu4_alpha: n, fc1: r, prelu5_alpha: o, fc2_1: i, fc2_2: a, fc2_3: s })
      },
    }
  }
  function Tv(t, e) {
    var n = Hd(t, e)
    function u(t) {
      return { filters: n(t + '/weights', 4, t + '/filters'), bias: n(t + '/bias', 1) }
    }
    function c(t) {
      return { weights: n(t + '/weights', 2), bias: n(t + '/bias', 1) }
    }
    function l(t) {
      return n(t, 1)
    }
    function h(t) {
      return {
        conv1: u(t + '/conv1'),
        prelu1_alpha: l(t + '/prelu1_alpha'),
        conv2: u(t + '/conv2'),
        prelu2_alpha: l(t + '/prelu2_alpha'),
        conv3: u(t + '/conv3'),
        prelu3_alpha: l(t + '/prelu3_alpha'),
      }
    }
    return {
      extractPNetParams: function () {
        var t = h('pnet'),
          e = u('pnet/conv4_1'),
          n = u('pnet/conv4_2')
        return pp(pp({}, t), { conv4_1: e, conv4_2: n })
      },
      extractRNetParams: function () {
        var t = h('rnet'),
          e = c('rnet/fc1'),
          n = l('rnet/prelu4_alpha'),
          r = c('rnet/fc2_1'),
          o = c('rnet/fc2_2')
        return pp(pp({}, t), { fc1: e, prelu4_alpha: n, fc2_1: r, fc2_2: o })
      },
      extractONetParams: function () {
        var t = h('onet'),
          e = u('onet/conv4'),
          n = l('onet/prelu4_alpha'),
          r = c('onet/fc1'),
          o = l('onet/prelu5_alpha'),
          i = c('onet/fc2_1'),
          a = c('onet/fc2_2'),
          s = c('onet/fc2_3')
        return pp(pp({}, t), { conv4: e, prelu4_alpha: n, fc1: r, prelu5_alpha: o, fc2_1: i, fc2_2: a, fc2_3: s })
      },
    }
  }
  function Dv(t, e) {
    var n = e[0],
      e = e[1]
    return { height: Math.floor(n * t), width: Math.floor(e * t) }
  }
  var Ov,
    Fv = (hp(Mv, (Ov = Np)), Mv)
  function Mv(t, e, n, r) {
    return Ov.call(this, { left: t, top: e, right: n, bottom: r }, !0) || this
  }
  function Pv(t) {
    return Ge(function () {
      return xu(_u(t, hn(127.5)), hn(0.0078125))
    })
  }
  function Bv(t, e) {
    return Ge(function () {
      return au(Lc(t), xu(e, Ss(Lc(Ss(t)))))
    })
  }
  function Lv(e, n, r) {
    return (
      void 0 === r && (r = !1),
      Ge(function () {
        var t = Bv((t = Bd(e, n.conv1, 'valid')), n.prelu1_alpha)
        return (
          (t = Bv((t = Bd((t = dc(t, r ? [2, 2] : [3, 3], [2, 2], 'same')), n.conv2, 'valid')), n.prelu2_alpha)),
          (t = Bv((t = Bd((t = r ? t : dc(t, [3, 3], [2, 2], 'valid')), n.conv3, 'valid')), n.prelu3_alpha))
        )
      })
    )
  }
  function Wv(c, t, i, l, a) {
    a.stage1 = []
    var e,
      n = t
        .map(function (u) {
          return Ge(function () {
            var n,
              r,
              o,
              i,
              t = { scale: u },
              e =
                ((n = c),
                (r = u),
                Ge(function () {
                  var t = Dv(r, n.shape.slice(1)),
                    e = t.height,
                    t = t.width,
                    t = Pv(yl.resizeBilinear(n, [e, t]))
                  return Gc(t, [0, 2, 1, 3])
                })),
              a = Date.now(),
              s =
                ((o = e),
                (i = l),
                Ge(function () {
                  var t = Lv(o, i, !0),
                    e = Bd(t, i.conv4_1, 'valid'),
                    n = Yn(Nc(e, 3), 3)
                  return { prob: Fr(_u(e, n), 3), regions: Bd(t, i.conv4_2, 'valid') }
                })),
              e = s.prob,
              s = s.regions
            return (
              (t.pnet = Date.now() - a),
              { scoresTensor: vr(vr(e, 3)[1])[0], regionsTensor: vr(s)[0], scale: u, statsForScale: t }
            )
          })
        })
        .map(function (t) {
          var e = t.scoresTensor,
            n = t.regionsTensor,
            r = t.scale,
            t = t.statsForScale,
            o = (function (t, o, i, e) {
              for (var n = [], a = t.arraySync(), r = 0; r < t.shape[0]; r++)
                for (var s = 0; s < t.shape[1]; s++) a[r][s] >= e && n.push(new Ip(s, r))
              return n.map(function (t) {
                var e = new Dp(
                    Math.round((t.y * Av + 1) / i),
                    Math.round((t.x * Av + 1) / i),
                    Math.round((t.y * Av + Nv) / i),
                    Math.round((t.x * Av + Nv) / i),
                  ),
                  n = a[t.y][t.x],
                  r = o.arraySync()
                return { cell: e, score: n, region: new Fv(r[t.y][t.x][0], r[t.y][t.x][1], r[t.y][t.x][2], r[t.y][t.x][3]) }
              })
            })(e, n, r, i)
          if ((e.dispose(), n.dispose(), !o.length)) return a.stage1.push(t), []
          ;(e = Date.now()),
            (n = Wp(
              o.map(function (t) {
                return t.cell
              }),
              o.map(function (t) {
                return t.score
              }),
              0.5,
            ))
          return (
            (t.nms = Date.now() - e),
            (t.numBoxes = n.length),
            a.stage1.push(t),
            n.map(function (t) {
              return o[t]
            })
          )
        })
        .reduce(function (t, e) {
          return t.concat(e)
        }, []),
      r = [],
      o = []
    return (
      0 < n.length &&
        ((e = Date.now()),
        (t = Wp(
          n.map(function (t) {
            return t.cell
          }),
          n.map(function (t) {
            return t.score
          }),
          0.7,
        )),
        (a.stage1_nms = Date.now() - e),
        (o = t.map(function (t) {
          return n[t].score
        })),
        (r = t
          .map(function (t) {
            return n[t]
          })
          .map(function (t) {
            var e = t.cell,
              t = t.region
            return new Dp(
              e.left + t.left * e.width,
              e.top + t.top * e.height,
              e.right + t.right * e.width,
              e.bottom + t.bottom * e.height,
            )
              .toSquare()
              .round()
          }))),
      { boxes: r, scores: o }
    )
  }
  function zv(s, r, t) {
    var u = t.width,
      c = t.height
    return dp(this, void 0, void 0, function () {
      var a,
        e,
        i,
        n = this
      return fp(this, function (t) {
        switch (t.label) {
          case 0:
            return (
              (a = xd(s)),
              [
                4,
                Promise.all(
                  r.map(function (i) {
                    return dp(n, void 0, void 0, function () {
                      var e, n, r, o
                      return fp(this, function (t) {
                        return (
                          (n = i.padAtBorders(s.height, s.width)),
                          (o = n.y),
                          (e = n.ey),
                          (r = n.x),
                          (n = n.ex),
                          (r = r - 1),
                          (o = o - 1),
                          (o = a.getImageData(r, o, n - r, e - o)),
                          [2, (yd.isNodejs() ? Sd : createImageBitmap)(o)]
                        )
                      })
                    })
                  }),
                ),
              ]
            )
          case 1:
            return (
              (e = t.sent()),
              (i = []),
              e.forEach(function (t) {
                var e = xd(Ed({ width: u, height: c }))
                e.drawImage(t, 0, 0, u, c)
                for (var n = e.getImageData(0, 0, u, c).data, r = [], o = 0; o < n.length; o += 4)
                  r.push(n[o + 2]), r.push(n[o + 1]), r.push(n[o])
                i.push(r)
              }),
              [
                2,
                i.map(function (t) {
                  return Ge(function () {
                    return Pv(Gc(vn(t, [1, u, c, 3]), [0, 2, 1, 3]).toFloat())
                  })
                }),
              ]
            )
        }
      })
    })
  }
  function Gv(h, p, d, f, v) {
    return dp(this, void 0, void 0, function () {
      var e, n, r, o, i, a, s, u, c, l
      return fp(this, function (t) {
        switch (t.label) {
          case 0:
            return (e = Date.now()), [4, zv(h, p, { width: 24, height: 24 })]
          case 1:
            return (
              (s = t.sent()),
              (v.stage2_extractImagePatches = Date.now() - e),
              (e = Date.now()),
              (n = s.map(function (t) {
                var r,
                  o,
                  e =
                    ((r = t),
                    (o = f),
                    Ge(function () {
                      var t = Lv(r, o),
                        e = Bv(Qd(cr(t, [t.shape[0], o.fc1.weights.shape[0]]), o.fc1), o.prelu4_alpha),
                        n = Qd(e, o.fc2_1),
                        t = Yn(Nc(n, 1), 1),
                        t = Fr(_u(n, t), 1),
                        e = Qd(e, o.fc2_2)
                      return { scores: vr(t, 1)[1], regions: e }
                    }))
                return t.dispose(), e
              })),
              (v.stage2_rnet = Date.now() - e),
              (c =
                1 < n.length
                  ? Cn(
                      n.map(function (t) {
                        return t.scores
                      }),
                    )
                  : n[0].scores),
              (s = (u = Array).from),
              [4, c.data()]
            )
          case 2:
            return (
              (r = s.apply(u, [t.sent()])),
              c.dispose(),
              (o = r
                .map(function (t, e) {
                  return { score: t, idx: e }
                })
                .filter(function (t) {
                  return t.score > d
                })
                .map(function (t) {
                  return t.idx
                })),
              (i = o.map(function (t) {
                return p[t]
              })),
              (a = o.map(function (t) {
                return r[t]
              })),
              (s = []),
              (u = []),
              0 < i.length &&
                ((e = Date.now()),
                (c = Wp(i, a, 0.7)),
                (v.stage2_nms = Date.now() - e),
                (l = c.map(function (t) {
                  t = n[o[t]].regions.arraySync()
                  return new Fv(t[0][0], t[0][1], t[0][2], t[0][3])
                })),
                (u = c.map(function (t) {
                  return a[t]
                })),
                (s = c.map(function (t, e) {
                  return i[t].calibrate(l[e])
                }))),
              n.forEach(function (t) {
                t.regions.dispose(), t.scores.dispose()
              }),
              [2, { boxes: s, scores: u }]
            )
        }
      })
    })
  }
  function Uv(h, p, d, f, v) {
    return dp(this, void 0, void 0, function () {
      var e, i, n, r, o, a, s, u, c, l
      return fp(this, function (t) {
        switch (t.label) {
          case 0:
            return (e = Date.now()), [4, zv(h, p, { width: 48, height: 48 })]
          case 1:
            return (
              (l = t.sent()),
              (v.stage3_extractImagePatches = Date.now() - e),
              (e = Date.now()),
              (i = l.map(function (t) {
                var r,
                  o,
                  e =
                    ((r = t),
                    (o = f),
                    Ge(function () {
                      var t = Lv(r, o)
                      t = Bv((t = Bd((t = dc(t, [2, 2], [2, 2], 'same')), o.conv4, 'valid')), o.prelu4_alpha)
                      var e = Bv(Qd(cr(t, [t.shape[0], o.fc1.weights.shape[0]]), o.fc1), o.prelu5_alpha),
                        n = Qd(e, o.fc2_1),
                        t = Yn(Nc(n, 1), 1),
                        n = Fr(_u(n, t), 1),
                        t = Qd(e, o.fc2_2),
                        e = Qd(e, o.fc2_3)
                      return { scores: vr(n, 1)[1], regions: t, points: e }
                    }))
                return t.dispose(), e
              })),
              (v.stage3_onet = Date.now() - e),
              (c =
                1 < i.length
                  ? Cn(
                      i.map(function (t) {
                        return t.scores
                      }),
                    )
                  : i[0].scores),
              (l = (u = Array).from),
              [4, c.data()]
            )
          case 2:
            return (
              (n = l.apply(u, [t.sent()])),
              c.dispose(),
              (l = n
                .map(function (t, e) {
                  return { score: t, idx: e }
                })
                .filter(function (t) {
                  return t.score > d
                })
                .map(function (t) {
                  return t.idx
                })),
              (r = l.map(function (t) {
                t = i[t].regions.arraySync()
                return new Fv(t[0][0], t[0][1], t[0][2], t[0][3])
              })),
              (o = l.map(function (t, e) {
                return p[t].calibrate(r[e])
              })),
              (a = l.map(function (t) {
                return n[t]
              })),
              (s = []),
              (u = []),
              (c = []),
              0 < o.length &&
                ((e = Date.now()),
                (l = Wp(o, a, 0.7, !1)),
                (v.stage3_nms = Date.now() - e),
                (s = l.map(function (t) {
                  return o[t]
                })),
                (u = l.map(function (t) {
                  return a[t]
                })),
                (c = l.map(function (r, o) {
                  return Array(5)
                    .fill(0)
                    .map(function (t, e) {
                      var n = i[r].points.arraySync()
                      return new Ip(n[0][e] * (s[o].width + 1) + s[o].left, n[0][e + 5] * (s[o].height + 1) + s[o].top)
                    })
                }))),
              i.forEach(function (t) {
                t.regions.dispose(), t.scores.dispose(), t.points.dispose()
              }),
              [2, { boxes: s, scores: u, points: c }]
            )
        }
      })
    })
  }
  var Vv,
    al =
      (hp(Hv, (Vv = al)),
      (Hv.prototype.load = function (e) {
        return dp(this, void 0, void 0, function () {
          return fp(this, function (t) {
            return console.warn('mtcnn is deprecated and will be removed soon'), [2, Vv.prototype.load.call(this, e)]
          })
        })
      }),
      (Hv.prototype.loadFromDisk = function (e) {
        return dp(this, void 0, void 0, function () {
          return fp(this, function (t) {
            return console.warn('mtcnn is deprecated and will be removed soon'), [2, Vv.prototype.loadFromDisk.call(this, e)]
          })
        })
      }),
      (Hv.prototype.forwardInput = function (m, g) {
        return (
          void 0 === g && (g = {}),
          dp(this, void 0, void 0, function () {
            var e, n, r, o, i, a, s, u, c, l, h, p, d, f, v
            return fp(this, function (t) {
              switch (t.label) {
                case 0:
                  if (!(e = this.params)) throw new Error('Mtcnn - load model before inference')
                  if (!(n = m.canvases[0]))
                    throw new Error(
                      'Mtcnn - inputCanvas is not defined, note that passing tensors into Mtcnn.forwardInput is not supported yet.',
                    )
                  return (
                    (r = {}),
                    (o = Date.now()),
                    (i = Ge(function () {
                      return (
                        (t = Yn(zh.fromPixels(n)).toFloat()),
                        Ge(function () {
                          return pr(vr(t, 3).reverse(), 3)
                        })
                      )
                      var t
                    })),
                    (a = function (t) {
                      return i.dispose(), (r.total = Date.now() - o), t
                    }),
                    (l = i.shape.slice(1)),
                    (s = l[0]),
                    (u = l[1]),
                    (h = new jf(g)),
                    (c = h.minFaceSize),
                    (p = h.scaleFactor),
                    (v = h.maxNumScales),
                    (l = h.scoreThresholds),
                    (h = h.scaleSteps),
                    (p = (
                      h ||
                      (function (t, e, n) {
                        for (var r = n[0], n = n[1], o = Nv / t, i = [], a = Math.min(r, n) * o, s = 0; 12 <= a; )
                          i.push(o * Math.pow(e, s)), (a *= e), (s += 1)
                        return i
                      })(c, p, [s, u])
                    )
                      .filter(function (t) {
                        t = Dv(t, [s, u])
                        return Math.min(t.width, t.height) > Nv
                      })
                      .slice(0, v)),
                    (r.scales = p),
                    (r.pyramid = p.map(function (t) {
                      return Dv(t, [s, u])
                    })),
                    (v = Date.now()),
                    [4, Wv(i, p, l[0], e.pnet, r)]
                  )
                case 1:
                  return ((d = t.sent()), (r.total_stage1 = Date.now() - v), d.boxes.length)
                    ? ((r.stage2_numInputBoxes = d.boxes.length), (v = Date.now()), [4, Gv(n, d.boxes, l[1], e.rnet, r)])
                    : [2, a({ results: [], stats: r })]
                case 2:
                  return ((d = t.sent()), (r.total_stage2 = Date.now() - v), d.boxes.length)
                    ? ((r.stage3_numInputBoxes = d.boxes.length), (v = Date.now()), [4, Uv(n, d.boxes, l[2], e.onet, r)])
                    : [2, a({ results: [], stats: r })]
                case 3:
                  return (
                    (f = t.sent()),
                    (r.total_stage3 = Date.now() - v),
                    (v = f.boxes.map(function (e, t) {
                      return lf(
                        ld(
                          {},
                          new Bp(f.scores[t], new Vp(e.left / u, e.top / s, e.width / u, e.height / s), {
                            height: s,
                            width: u,
                          }),
                        ),
                        new Xp(
                          f.points[t].map(function (t) {
                            return t.sub(new Ip(e.left, e.top)).div(new Ip(e.width, e.height))
                          }),
                          { width: e.width, height: e.height },
                        ),
                      )
                    })),
                    [2, a({ results: v, stats: r })]
                  )
              }
            })
          })
        )
      }),
      (Hv.prototype.forward = function (n, r) {
        return (
          void 0 === r && (r = {}),
          dp(this, void 0, void 0, function () {
            var e
            return fp(this, function (t) {
              switch (t.label) {
                case 0:
                  return (e = this.forwardInput), [4, Ad(n)]
                case 1:
                  return [4, e.apply(this, [t.sent(), r])]
                case 2:
                  return [2, t.sent().results]
              }
            })
          })
        )
      }),
      (Hv.prototype.forwardWithStats = function (n, r) {
        return (
          void 0 === r && (r = {}),
          dp(this, void 0, void 0, function () {
            var e
            return fp(this, function (t) {
              switch (t.label) {
                case 0:
                  return (e = this.forwardInput), [4, Ad(n)]
                case 1:
                  return [2, e.apply(this, [t.sent(), r])]
              }
            })
          })
        )
      }),
      (Hv.prototype.getDefaultModelName = function () {
        return 'mtcnn_model'
      }),
      (Hv.prototype.extractParamsFromWeigthMap = function (t) {
        return (
          (r = (o = Tv((e = t), (n = []))).extractPNetParams),
          (t = o.extractRNetParams),
          (o = o.extractONetParams),
          (r = r()),
          (t = t()),
          (o = o()),
          Ld(e, n),
          { params: { pnet: r, rnet: t, onet: o }, paramMappings: n }
        )
        var e, n, r, o
      }),
      (Hv.prototype.extractParams = function (t) {
        var e = (o = jd(t)).extractWeights,
          n = o.getRemainingWeights,
          r = [],
          o = (t = kv(e, r)).extractPNetParams,
          e = t.extractRNetParams,
          t = t.extractONetParams,
          o = o(),
          e = e(),
          t = t()
        if (0 !== n().length) throw new Error('weights remaing after extract: ' + n().length)
        return { params: { pnet: o, rnet: e, onet: t }, paramMappings: r }
      }),
      Hv)
  function Hv() {
    return Vv.call(this, 'Mtcnn') || this
  }
  var jv,
    qv = [
      new Ip(1.603231, 2.094468),
      new Ip(6.041143, 7.080126),
      new Ip(2.882459, 3.518061),
      new Ip(4.266906, 5.178857),
      new Ip(9.041765, 10.66308),
    ],
    Kv = [117.001, 114.697, 97.404],
    ul =
      (hp(Xv, (jv = ul)),
      Object.defineProperty(Xv.prototype, 'anchors', {
        get: function () {
          return this.config.anchors
        },
        enumerable: !0,
        configurable: !0,
      }),
      (Xv.prototype.locateFaces = function (e, n) {
        return dp(this, void 0, void 0, function () {
          return fp(this, function (t) {
            switch (t.label) {
              case 0:
                return [4, this.detect(e, n)]
              case 1:
                return [
                  2,
                  t.sent().map(function (t) {
                    return new Bp(t.score, t.relativeBox, { width: t.imageWidth, height: t.imageHeight })
                  }),
                ]
            }
          })
        })
      }),
      (Xv.prototype.getDefaultModelName = function () {
        return 'tiny_face_detector_model'
      }),
      (Xv.prototype.extractParamsFromWeigthMap = function (t) {
        return jv.prototype.extractParamsFromWeigthMap.call(this, t)
      }),
      Xv)
  function Xv() {
    var t = {
      withSeparableConvs: !0,
      iouThreshold: 0.4,
      classes: ['face'],
      anchors: qv,
      meanRgb: Kv,
      isFirstLayerConv2d: !0,
      filterSizes: [3, 16, 32, 64, 128, 256, 512],
    }
    return jv.call(this, t) || this
  }
  var $v,
    Yv = {
      ssdMobilenetv1: new Dt(),
      tinyFaceDetector: new ul(),
      tinyYolov2: new el(),
      mtcnn: new al(),
      faceLandmark68Net: new o(),
      faceLandmark68TinyNet: new nl(),
      faceRecognitionNet: new Zc(),
      faceExpressionNet: new Br(),
      ageGenderNet: new Le(),
    },
    Le = (hp(Jv, ($v = Vi)), Jv)
  function Jv(t, e, n) {
    var r = $v.call(this) || this
    return (r.parentTask = t), (r.input = e), (r.extractedFaces = n), r
  }
  var Qv,
    Zv =
      (hp(tm, (Qv = Le)),
      (tm.prototype.run = function () {
        return dp(this, void 0, void 0, function () {
          var e,
            n,
            r = this
          return fp(this, function (t) {
            switch (t.label) {
              case 0:
                return [4, this.parentTask]
              case 1:
                return [
                  4,
                  Rv(
                    (e = t.sent()),
                    this.input,
                    function (e) {
                      return dp(r, void 0, void 0, function () {
                        return fp(this, function (t) {
                          switch (t.label) {
                            case 0:
                              return [
                                4,
                                Promise.all(
                                  e.map(function (t) {
                                    return Yv.faceExpressionNet.predictExpressions(t)
                                  }),
                                ),
                              ]
                            case 1:
                              return [2, t.sent()]
                          }
                        })
                      })
                    },
                    this.extractedFaces,
                  ),
                ]
              case 2:
                return (
                  (n = t.sent()),
                  [
                    2,
                    e.map(function (t, e) {
                      return uf(t, n[e])
                    }),
                  ]
                )
            }
          })
        })
      }),
      (tm.prototype.withAgeAndGender = function () {
        return new dm(this, this.input)
      }),
      tm)
  function tm() {
    return (null !== Qv && Qv.apply(this, arguments)) || this
  }
  var em,
    nm =
      (hp(rm, (em = Le)),
      (rm.prototype.run = function () {
        return dp(this, void 0, void 0, function () {
          var e, n
          return fp(this, function (t) {
            switch (t.label) {
              case 0:
                return [4, this.parentTask]
              case 1:
                return (e = t.sent())
                  ? [
                      4,
                      Iv(
                        e,
                        this.input,
                        function (t) {
                          return Yv.faceExpressionNet.predictExpressions(t)
                        },
                        this.extractedFaces,
                      ),
                    ]
                  : [2]
              case 2:
                return (n = t.sent()), [2, uf(e, n)]
            }
          })
        })
      }),
      (rm.prototype.withAgeAndGender = function () {
        return new mm(this, this.input)
      }),
      rm)
  function rm() {
    return (null !== em && em.apply(this, arguments)) || this
  }
  var om,
    im =
      (hp(am, (om = Zv)),
      (am.prototype.withAgeAndGender = function () {
        return new bm(this, this.input)
      }),
      (am.prototype.withFaceDescriptors = function () {
        return new Im(this, this.input)
      }),
      am)
  function am() {
    return (null !== om && om.apply(this, arguments)) || this
  }
  var sm,
    um =
      (hp(cm, (sm = nm)),
      (cm.prototype.withAgeAndGender = function () {
        return new Cm(this, this.input)
      }),
      (cm.prototype.withFaceDescriptor = function () {
        return new km(this, this.input)
      }),
      cm)
  function cm() {
    return (null !== sm && sm.apply(this, arguments)) || this
  }
  var lm,
    Le = (hp(hm, (lm = Vi)), hm)
  function hm(t, e, n) {
    var r = lm.call(this) || this
    return (r.parentTask = t), (r.input = e), (r.extractedFaces = n), r
  }
  var pm,
    dm =
      (hp(fm, (pm = Le)),
      (fm.prototype.run = function () {
        return dp(this, void 0, void 0, function () {
          var e,
            r,
            n = this
          return fp(this, function (t) {
            switch (t.label) {
              case 0:
                return [4, this.parentTask]
              case 1:
                return [
                  4,
                  Rv(
                    (e = t.sent()),
                    this.input,
                    function (e) {
                      return dp(n, void 0, void 0, function () {
                        return fp(this, function (t) {
                          switch (t.label) {
                            case 0:
                              return [
                                4,
                                Promise.all(
                                  e.map(function (t) {
                                    return Yv.ageGenderNet.predictAgeAndGender(t)
                                  }),
                                ),
                              ]
                            case 1:
                              return [2, t.sent()]
                          }
                        })
                      })
                    },
                    this.extractedFaces,
                  ),
                ]
              case 2:
                return (
                  (r = t.sent()),
                  [
                    2,
                    e.map(function (t, e) {
                      var n = r[e],
                        e = n.age
                      return Vf(Hf(t, n.gender, n.genderProbability), e)
                    }),
                  ]
                )
            }
          })
        })
      }),
      (fm.prototype.withFaceExpressions = function () {
        return new Zv(this, this.input)
      }),
      fm)
  function fm() {
    return (null !== pm && pm.apply(this, arguments)) || this
  }
  var vm,
    mm =
      (hp(gm, (vm = Le)),
      (gm.prototype.run = function () {
        return dp(this, void 0, void 0, function () {
          var e, n, r, o
          return fp(this, function (t) {
            switch (t.label) {
              case 0:
                return [4, this.parentTask]
              case 1:
                return (e = t.sent())
                  ? [
                      4,
                      Iv(
                        e,
                        this.input,
                        function (t) {
                          return Yv.ageGenderNet.predictAgeAndGender(t)
                        },
                        this.extractedFaces,
                      ),
                    ]
                  : [2]
              case 2:
                return (o = t.sent()), (n = o.age), (r = o.gender), (o = o.genderProbability), [2, Vf(Hf(e, r, o), n)]
            }
          })
        })
      }),
      (gm.prototype.withFaceExpressions = function () {
        return new nm(this, this.input)
      }),
      gm)
  function gm() {
    return (null !== vm && vm.apply(this, arguments)) || this
  }
  var ym,
    bm =
      (hp(xm, (ym = dm)),
      (xm.prototype.withFaceExpressions = function () {
        return new im(this, this.input)
      }),
      (xm.prototype.withFaceDescriptors = function () {
        return new Im(this, this.input)
      }),
      xm)
  function xm() {
    return (null !== ym && ym.apply(this, arguments)) || this
  }
  var wm,
    Cm =
      (hp(Em, (wm = mm)),
      (Em.prototype.withFaceExpressions = function () {
        return new um(this, this.input)
      }),
      (Em.prototype.withFaceDescriptor = function () {
        return new km(this, this.input)
      }),
      Em)
  function Em() {
    return (null !== wm && wm.apply(this, arguments)) || this
  }
  var Sm,
    Le = (hp(_m, (Sm = Vi)), _m)
  function _m(t, e) {
    var n = Sm.call(this) || this
    return (n.parentTask = t), (n.input = e), n
  }
  var Rm,
    Im =
      (hp(Am, (Rm = Le)),
      (Am.prototype.run = function () {
        return dp(this, void 0, void 0, function () {
          var n
          return fp(this, function (t) {
            switch (t.label) {
              case 0:
                return [4, this.parentTask]
              case 1:
                return [
                  4,
                  Rv(
                    (n = t.sent()),
                    this.input,
                    function (t) {
                      return Promise.all(
                        t.map(function (t) {
                          return Yv.faceRecognitionNet.computeFaceDescriptor(t)
                        }),
                      )
                    },
                    null,
                    function (t) {
                      return t.landmarks.align(null, { useDlibAlignment: !0 })
                    },
                  ),
                ]
              case 2:
                return [
                  2,
                  t.sent().map(function (t, e) {
                    return Uf(n[e], t)
                  }),
                ]
            }
          })
        })
      }),
      (Am.prototype.withFaceExpressions = function () {
        return new im(this, this.input)
      }),
      (Am.prototype.withAgeAndGender = function () {
        return new bm(this, this.input)
      }),
      Am)
  function Am() {
    return (null !== Rm && Rm.apply(this, arguments)) || this
  }
  var Nm,
    km =
      (hp(Tm, (Nm = Le)),
      (Tm.prototype.run = function () {
        return dp(this, void 0, void 0, function () {
          var e, n
          return fp(this, function (t) {
            switch (t.label) {
              case 0:
                return [4, this.parentTask]
              case 1:
                return (e = t.sent())
                  ? [
                      4,
                      Iv(
                        e,
                        this.input,
                        function (t) {
                          return Yv.faceRecognitionNet.computeFaceDescriptor(t)
                        },
                        null,
                        function (t) {
                          return t.landmarks.align(null, { useDlibAlignment: !0 })
                        },
                      ),
                    ]
                  : [2]
              case 2:
                return (n = t.sent()), [2, Uf(e, n)]
            }
          })
        })
      }),
      (Tm.prototype.withFaceExpressions = function () {
        return new um(this, this.input)
      }),
      (Tm.prototype.withAgeAndGender = function () {
        return new Cm(this, this.input)
      }),
      Tm)
  function Tm() {
    return (null !== Nm && Nm.apply(this, arguments)) || this
  }
  var Dm,
    Le =
      (hp(Om, (Dm = Vi)),
      Object.defineProperty(Om.prototype, 'landmarkNet', {
        get: function () {
          return this.useTinyLandmarkNet ? Yv.faceLandmark68TinyNet : Yv.faceLandmark68Net
        },
        enumerable: !0,
        configurable: !0,
      }),
      Om)
  function Om(t, e, n) {
    var r = Dm.call(this) || this
    return (r.parentTask = t), (r.input = e), (r.useTinyLandmarkNet = n), r
  }
  var Fm,
    Mm =
      (hp(Pm, (Fm = Le)),
      (Pm.prototype.run = function () {
        return dp(this, void 0, void 0, function () {
          var e,
            n,
            r,
            o,
            i,
            a = this
          return fp(this, function (t) {
            switch (t.label) {
              case 0:
                return [4, this.parentTask]
              case 1:
                return (
                  (e = t.sent()),
                  (n = e.map(function (t) {
                    return t.detection
                  })),
                  this.input instanceof bt ? [4, kd(this.input, n)] : [3, 3]
                )
              case 2:
                return (o = t.sent()), [3, 5]
              case 3:
                return [4, Nd(this.input, n)]
              case 4:
                ;(o = t.sent()), (t.label = 5)
              case 5:
                return (
                  (r = o),
                  [
                    4,
                    Promise.all(
                      r.map(function (t) {
                        return a.landmarkNet.detectLandmarks(t)
                      }),
                    ),
                  ]
                )
              case 6:
                return (
                  (i = t.sent()),
                  r.forEach(function (t) {
                    return t instanceof bt && t.dispose()
                  }),
                  [
                    2,
                    e.map(function (t, e) {
                      return lf(t, i[e])
                    }),
                  ]
                )
            }
          })
        })
      }),
      (Pm.prototype.withFaceExpressions = function () {
        return new im(this, this.input)
      }),
      (Pm.prototype.withAgeAndGender = function () {
        return new bm(this, this.input)
      }),
      (Pm.prototype.withFaceDescriptors = function () {
        return new Im(this, this.input)
      }),
      Pm)
  function Pm() {
    return (null !== Fm && Fm.apply(this, arguments)) || this
  }
  var Bm,
    Lm =
      (hp(Wm, (Bm = Le)),
      (Wm.prototype.run = function () {
        return dp(this, void 0, void 0, function () {
          var e, n, r, o
          return fp(this, function (t) {
            switch (t.label) {
              case 0:
                return [4, this.parentTask]
              case 1:
                return (e = t.sent()) ? ((n = e.detection), this.input instanceof bt ? [4, kd(this.input, [n])] : [3, 3]) : [2]
              case 2:
                return (o = t.sent()), [3, 5]
              case 3:
                return [4, Nd(this.input, [n])]
              case 4:
                ;(o = t.sent()), (t.label = 5)
              case 5:
                return (r = o), [4, this.landmarkNet.detectLandmarks(r[0])]
              case 6:
                return (
                  (o = t.sent()),
                  r.forEach(function (t) {
                    return t instanceof bt && t.dispose()
                  }),
                  [2, lf(e, o)]
                )
            }
          })
        })
      }),
      (Wm.prototype.withFaceExpressions = function () {
        return new um(this, this.input)
      }),
      (Wm.prototype.withAgeAndGender = function () {
        return new Cm(this, this.input)
      }),
      (Wm.prototype.withFaceDescriptor = function () {
        return new km(this, this.input)
      }),
      Wm)
  function Wm() {
    return (null !== Bm && Bm.apply(this, arguments)) || this
  }
  var zm,
    Vi = (hp(Gm, (zm = Vi)), Gm)
  function Gm(t, e) {
    void 0 === e && (e = new ev())
    var n = zm.call(this) || this
    return (n.input = t), (n.options = e), n
  }
  var Um,
    Vm =
      (hp(Hm, (Um = Vi)),
      (Hm.prototype.run = function () {
        return dp(this, void 0, void 0, function () {
          var e, n, r
          return fp(this, function (t) {
            switch (t.label) {
              case 0:
                return (e = (r = this).input), (n = r.options) instanceof jf ? [4, Yv.mtcnn.forward(e, n)] : [3, 2]
              case 1:
                return [
                  2,
                  t.sent().map(function (t) {
                    return t.detection
                  }),
                ]
              case 2:
                if (
                  !(r =
                    n instanceof Ev
                      ? function (t) {
                          return Yv.tinyFaceDetector.locateFaces(t, n)
                        }
                      : n instanceof ev
                      ? function (t) {
                          return Yv.ssdMobilenetv1.locateFaces(t, n)
                        }
                      : n instanceof mv
                      ? function (t) {
                          return Yv.tinyYolov2.locateFaces(t, n)
                        }
                      : null)
                )
                  throw new Error(
                    'detectFaces - expected options to be instance of TinyFaceDetectorOptions | SsdMobilenetv1Options | MtcnnOptions | TinyYolov2Options',
                  )
                return [2, r(e)]
            }
          })
        })
      }),
      (Hm.prototype.runAndExtendWithFaceDetections = function () {
        var t = this
        return new Promise(function (n) {
          return dp(t, void 0, void 0, function () {
            var e
            return fp(this, function (t) {
              switch (t.label) {
                case 0:
                  return [4, this.run()]
                case 1:
                  return (
                    (e = t.sent()),
                    [
                      2,
                      n(
                        e.map(function (t) {
                          return ld({}, t)
                        }),
                      ),
                    ]
                  )
              }
            })
          })
        })
      }),
      (Hm.prototype.withFaceLandmarks = function (t) {
        return void 0 === t && (t = !1), new Mm(this.runAndExtendWithFaceDetections(), this.input, t)
      }),
      (Hm.prototype.withFaceExpressions = function () {
        return new Zv(this.runAndExtendWithFaceDetections(), this.input)
      }),
      (Hm.prototype.withAgeAndGender = function () {
        return new dm(this.runAndExtendWithFaceDetections(), this.input)
      }),
      Hm)
  function Hm() {
    return (null !== Um && Um.apply(this, arguments)) || this
  }
  var jm,
    qm =
      (hp(Km, (jm = Vi)),
      (Km.prototype.run = function () {
        return dp(this, void 0, void 0, function () {
          var e, n
          return fp(this, function (t) {
            switch (t.label) {
              case 0:
                return [4, new Vm(this.input, this.options)]
              case 1:
                return (
                  (e = t.sent()),
                  (n = e[0]),
                  e.forEach(function (t) {
                    t.score > n.score && (n = t)
                  }),
                  [2, n]
                )
            }
          })
        })
      }),
      (Km.prototype.runAndExtendWithFaceDetection = function () {
        var t = this
        return new Promise(function (n) {
          return dp(t, void 0, void 0, function () {
            var e
            return fp(this, function (t) {
              switch (t.label) {
                case 0:
                  return [4, this.run()]
                case 1:
                  return (e = t.sent()), [2, n(e ? ld({}, e) : void 0)]
              }
            })
          })
        })
      }),
      (Km.prototype.withFaceLandmarks = function (t) {
        return void 0 === t && (t = !1), new Lm(this.runAndExtendWithFaceDetection(), this.input, t)
      }),
      (Km.prototype.withFaceExpressions = function () {
        return new nm(this.runAndExtendWithFaceDetection(), this.input)
      }),
      (Km.prototype.withAgeAndGender = function () {
        return new mm(this.runAndExtendWithFaceDetection(), this.input)
      }),
      Km)
  function Km() {
    return (null !== jm && jm.apply(this, arguments)) || this
  }
  function Xm(t, e) {
    void 0 === e && (e = 0.6), (this._distanceThreshold = e)
    t = Array.isArray(t) ? t : [t]
    if (!t.length) throw new Error('FaceRecognizer.constructor - expected atleast one input')
    function n() {
      return 'person ' + r++
    }
    var r = 1
    this._labeledDescriptors = t.map(function (t) {
      if (t instanceof ad) return t
      if (t instanceof Float32Array) return new ad(n(), [t])
      if (t.descriptor && t.descriptor instanceof Float32Array) return new ad(n(), [t.descriptor])
      throw new Error(
        'FaceRecognizer.constructor - expected inputs to be of type LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array | Array<LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array>',
      )
    })
  }
  function $m() {
    return !!(
      navigator.userAgent.match(/Android/i) ||
      navigator.userAgent.match(/webOS/i) ||
      navigator.userAgent.match(/iPhone/i) ||
      navigator.userAgent.match(/iPad/i) ||
      navigator.userAgent.match(/iPod/i) ||
      navigator.userAgent.match(/BlackBerry/i) ||
      navigator.userAgent.match(/Windows Phone/i)
    )
  }
  function Ym() {
    return !!(
      navigator.userAgent.match(/webOS/i) ||
      navigator.userAgent.match(/iPhone/i) ||
      navigator.userAgent.match(/iPad/i) ||
      navigator.userAgent.match(/iPod/i) ||
      navigator.userAgent.match(/Mac OS/i)
    )
  }
  function Jm() {
    return !!navigator.userAgent.match(/Android/i)
  }
  function Qm() {
    var t = -1 < i.description.toLowerCase().indexOf('chrome'),
      e = -1 < i.description.toLowerCase().indexOf('firefox'),
      n = -1 < i.description.toLowerCase().indexOf('safari'),
      r = -1 < i.description.toLowerCase().indexOf('edge'),
      o = -1 < i.description.toLowerCase().indexOf('opera')
    return $m()
      ? Jm()
        ? t || e || r || e
        : Ym() && !(!n || t || o || r || e)
      : Ym()
      ? Ym() && !(!n || t || o || r || e)
      : t || o || r || e
  }
  Object.defineProperty(Xm.prototype, 'labeledDescriptors', {
    get: function () {
      return this._labeledDescriptors
    },
    enumerable: !0,
    configurable: !0,
  }),
    Object.defineProperty(Xm.prototype, 'distanceThreshold', {
      get: function () {
        return this._distanceThreshold
      },
      enumerable: !0,
      configurable: !0,
    }),
    (Xm.prototype.computeMeanDistance = function (e, t) {
      return (
        t
          .map(function (t) {
            return (function (t, e) {
              if (t.length !== e.length) throw new Error('euclideanDistance: arr1.length !== arr2.length')
              var t = Array.from(t),
                n = Array.from(e)
              return Math.sqrt(
                t
                  .map(function (t, e) {
                    return t - n[e]
                  })
                  .reduce(function (t, e) {
                    return t + Math.pow(e, 2)
                  }, 0),
              )
            })(t, e)
          })
          .reduce(function (t, e) {
            return t + e
          }, 0) / (t.length || 1)
      )
    }),
    (Xm.prototype.matchDescriptor = function (n) {
      var r = this
      return this.labeledDescriptors
        .map(function (t) {
          var e = t.descriptors,
            t = t.label
          return new Zp(t, r.computeMeanDistance(n, e))
        })
        .reduce(function (t, e) {
          return t.distance < e.distance ? t : e
        })
    }),
    (Xm.prototype.findBestMatch = function (t) {
      t = this.matchDescriptor(t)
      return t.distance < this.distanceThreshold ? t : new Zp('unknown', t.distance)
    }),
    (Xm.prototype.toJSON = function () {
      return {
        distanceThreshold: this.distanceThreshold,
        labeledDescriptors: this.labeledDescriptors.map(function (t) {
          return t.toJSON()
        }),
      }
    }),
    (Xm.fromJSON = function (t) {
      return new Xm(
        t.labeledDescriptors.map(function (t) {
          return ad.fromJSON(t)
        }),
        t.distanceThreshold,
      )
    }),
    (window.opr && opr.addons) || window.opera || navigator.userAgent.indexOf(' OPR/')
  const Zm = 'undefined' != typeof InstallTrigger
  window.chrome && (window.chrome.webstore || window.chrome.runtime)
  let tg = '',
    eg = null,
    ng = null,
    rg = null,
    og = null
  function ig() {
    eg && (eg.style.display = 'block')
  }
  function ag() {
    eg && (eg.style.display = 'none')
  }
  function sg() {
    ng && ((ng.style.visibility = 'hidden'), (ng.style.opacity = 0), (ng.style.display = 'none'))
  }
  function ug(t) {
    tg && tg.innerHTML !== t && ((tg.innerHTML = t), (tg.style.visibility = 'visible'), (tg.style.opacity = 1))
  }
  function cg() {
    ;(tg.innerHTML = ''), (tg.style.visibility = 'hidden'), (tg.style.opacity = 0)
  }
  function lg(t, e) {
    tg.style.top = `${t.offsetHeight / 2 - e / 2 - 25}px`
  }
  function hg(t) {
    ;(eg = t.querySelector('#box--loading')),
      (tg = t.querySelector('#camera--message')),
      (ng = t.querySelector('#box--orientation')),
      (eg.innerHTML = og),
      (ng.innerHTML = rg)
  }
  let pg = !1
  function dg() {
    return new Ev({ inputSize: 224, scoreThreshold: 0.5 })
  }
  function fg() {
    return !!Yv.tinyFaceDetector.params
  }
  Vi = Object.freeze({
    __proto__: null,
    get isfaceApiLoaded() {
      return pg
    },
    loadModelsCameraInteligence: async function (t) {
      return pg
        ? Promise.resolve()
        : await Promise.all([Yv.tinyFaceDetector.loadFromUri(t), Yv.faceLandmark68Net.loadFromUri(t)])
            .then(() => ((pg = !0), Promise.resolve()))
            .catch(() =>
              Promise.reject(
                new Error(
                  'Não foi possível baixar os modelos, pode ser erro de diretório ou arquivos do face-api não carregados anteriormente.',
                ),
              ),
            )
    },
    getFaceDetectorOptions: dg,
    isFaceDetectionModelLoaded: fg,
    isFaceLandmark68NetLoaded: function () {
      return !!Yv.faceLandmark68Net.params
    },
    getHostUrlBase: function (t) {
      return window.location.protocol + '//' + window.location.host + '/' + t
    },
  })
  var vg, mg, gg, yg
  ;(vg =
    'body,html{margin:0;padding:0;border:0;font-size:100%;vertical-align:baseline}#box-camera{position:absolute;overflow:hidden;background-color:transparent;width:100%;height:100%;object-fit:cover;display:block;justify-content:center;align-items:center;padding:0;margin:0;box-sizing:border-box}#box-camera .canvas{z-index:50;margin:0 auto;top:0;bottom:0;position:absolute;left:50%;top:50%;transform:translate(-50%,-50%) scaleX(-1)}#box-camera #camera--canvas{display:none}#box-camera #svgMask{position:absolute;bottom:0}#box-camera #camera--canvas,#box-camera #camera--video{transform:scaleX(-1);filter:FlipH;width:100%;height:100%}#box-camera #camera--overlay{transform:scaleX(-1);position:absolute;top:0;left:0;width:100%;height:100%}#box-camera #camera--trigger{width:60px;height:60px;font-size:16px;border-radius:30px;border:none;text-align:center;box-shadow:0 5px 10px 0 rgba(0,0,0,.2);position:absolute;left:0;right:0;z-index:10;margin:0 auto;display:none;cursor:pointer}#box-camera audio,#box-camera canvas,#box-camera video{display:inline-block;*display:inline;*zoom:1;max-width:100%}#box-camera #camera--message{position:absolute;left:0;right:0;margin:0 auto;width:250px;height:30px;border-radius:2px;text-align:center;line-height:30px;z-index:61;font-size:15px;visibility:hidden;opacity:0;transition:visibility 0s,opacity .5s linear;font-weight:700}#box-camera #box--document-info{position:absolute;left:0;bottom:0;z-index:9}#box-camera #box--document-info #label--document{text-align:center;vertical-align:middle;display:inline-block;position:absolute;left:0;right:0}#box-camera #svgMask .cls-text{font-size:20px;font-family:inherit}#box-camera #svgMask .cls-text-medium{font-size:25px}#box-camera #svgMask .cls-text-big{font-size:29px;font-family:inherit}#box-camera ::-webkit-media-controls-panel,#box-camera ::-webkit-media-controls-start-playback-button{display:none!important;-webkit-appearance:none}#box-camera ::--webkit-media-controls-play-button,#box-camera video::-webkit-media-controls-panel{display:none!important;-webkit-appearance:none}#box-camera video::--webkit-media-controls-play-button,#box-camera video::-webkit-media-controls-start-playback-button{display:none!important;-webkit-appearance:none}#box-camera #box--orientation{display:inline-block;z-index:63;visibility:hidden;opacity:0;transition:visibility 0s,opacity .5s linear}#box-camera #box--loading,#box-camera #box--orientation{position:absolute;width:100%;height:100%;left:0;top:0;background-color:#fff}#box-camera #box--loading{z-index:62;right:0;margin:0 auto}'),
    (yg = (mg = void 0 === mg ? {} : mg).insertAt),
    vg &&
      'undefined' != typeof document &&
      ((gg = document.head || document.getElementsByTagName('head')[0]),
      ((mg = document.createElement('style')).type = 'text/css'),
      'top' === yg && gg.firstChild ? gg.insertBefore(mg, gg.firstChild) : gg.appendChild(mg),
      mg.styleSheet ? (mg.styleSheet.cssText = vg) : mg.appendChild(document.createTextNode(vg)))
  const bg = { CLOSE: { WIDTH: $m() ? 285 : 307.8, HEIGHT: $m() ? 456 : 492.48 } },
    xg = '0.0.6'
  let wg = {},
    Cg = { video: { facingMode: 'user' }, audio: !1 },
    Eg = null,
    Sg = null,
    _g = null,
    Rg = null,
    Ig = null,
    Ag = null,
    Ng = null,
    kg = null,
    Tg = null,
    Dg = null,
    Og = null,
    Fg = null,
    Mg = null,
    Pg = null,
    Bg = null,
    Lg = null,
    Wg = 1280 / 720,
    zg = 0,
    Gg = 0,
    Ug = 0,
    Vg = 0,
    Hg = 1280,
    jg = 720,
    qg = !1,
    Kg = [],
    Xg = !1,
    $g = !1,
    Yg = !1,
    Jg = 0,
    Qg = null,
    Zg = null,
    ty = null
  const ey = { CAMERA_NORMAL: 1, CAMERA_INTELIGENCE: 2 }
  let ny = null
  const ry = { CNH: 1, RG: 2, CPF: 3, NEW_RG: 4, OTHERS: 5, RG_FRONT: 6, RG_BACK: 7, NEW_RG_FRONT: 8, NEW_RG_BACK: 9 }
  let oy = null
  const iy = { FRONT: 1, BACK: 2 }
  let ay = null
  const sy = { FRONT: 1, BACK: 2 }
  let uy = null,
    cy = null,
    ly = !1,
    hy = !1,
    py = null
  const dy = { PRIMARY: '#297fff', SECONDARY: '#fff', NEUTRAL: '#fff' }
  let fy = { BACKGROUND: '#297fff', COLOR: '#fff' },
    vy = { BACKGROUND: '#297fff', COLOR: '#fff' },
    my = { BACKGROUND: '#fff', COLOR: '#000' },
    gy = 0,
    yy = !1,
    by = {
      silhoutteWidth: null,
      topSILHOUETTEThresholdVertical: null,
      bottomSILHOUETTEThresholdVertical: null,
      inSILHOUETTEThresholdHorizontal: null,
      overSILHOUETTEThresholdHorizontal: null,
      faceTurnedSILHOUETTEThresholdHorizontal: null,
      CSPWidthLeft: null,
      CSPWidthRight: null,
      CSPHeightTop: null,
      CSPHeightBottom: null,
      distanceLeftByNose: null,
      distanceRightByNose: null,
      differenceInDistance: null,
      differenceLeftY: null,
      differenceRightY: null,
      differenceNoseYThreshold: null,
    },
    xy = {
      topSilhouetteThresholdVertical: 0,
      bottomSilhouetteThresholdVertical: 0,
      inSilhouetteThresholdHorizontal: 0,
      overSilhouetteThresholdHorizontal: 0,
      faceTurnedSilhouetteThresholdHorizontal: 0,
      differenceNoseYThreshold: 0,
    },
    wy = null,
    Cy = null,
    Ey = null,
    Sy = null,
    _y = null,
    Ry = null
  const Iy = { PORTRAIT: 1, LANDSCAPE: 2 },
    Ay = { video: { width: { min: 640, ideal: 1280, max: 1920 }, height: { min: 480, ideal: 720, max: 1080 } } }
  function Ny() {
    Sy && (Sy.onclick = tb)
  }
  function ky(t) {
    t && ((window.stream = t), Ty((wy.srcObject = t)))
  }
  function Ty(t) {
    t &&
      ((Sg = t.getVideoTracks()[0]),
      Sg.getSettings() && (qg || ((qg = !0), (Hg = Sg.getSettings().width), (jg = Sg.getSettings().height))),
      Dy(Sg.getConstraints()))
  }
  function Dy(t) {
    var e
    t && ((e = {}), Object.assign(e, wg), Object.assign(e, t), (wg = e), Oy(wg))
  }
  function Oy(t) {
    let e = Hg,
      n = jg
    t && t.video && t.video.width && t.video.width.exact && (e = t.video.width.exact),
      t && t.video && t.video.height && t.video.height.exact && (n = t.video.height.exact),
      e && n && (Wg = e > n ? e / n : n / e)
  }
  function Fy(t) {
    t
      ? Qg.on.error(`navigator.MediaDevices.getUserMedia error: ${t.message}, ${t.name}`)
      : Qg.on.error('Ooopss algo deu errado na abertura da câmera')
  }
  function My() {
    wy && ($m() ? (wy.style['object-fit'] = 'cover') : (wy.style['object-fit'] = ''))
  }
  function Py() {
    window.stream &&
      window.stream.getTracks().forEach((t) => {
        t.stop()
      }),
      (wg &&
        wg.video &&
        wg.video.width &&
        wg.video.height &&
        wg.video.width.min &&
        wg.video.width.ideal &&
        wg.video.width.max &&
        wg.video.height.min &&
        wg.video.height.ideal &&
        wg.video.height.max) ||
        ($m() &&
          (ny === ry.CNH ||
            ny === ry.RG ||
            ny === ry.CPF ||
            ny === ry.NEW_RG ||
            ny === ry.OTHERS ||
            ny === ry.RG_FRONT ||
            ny === ry.RG_BACK ||
            ny === ry.NEW_RG_FRONT ||
            ny === ry.NEW_RG_BACK ||
            (Zg === ey.CAMERA_NORMAL && ay === sy.BACK)) &&
          ((Cg.video.facingMode = 'environment'),
          (Ay.video.facingMode = 'environment'),
          (wy.style.webkitTransform = 'none'),
          (Cy.style.webkitTransform = 'none')),
        Object.assign(wg, Cg),
        Zm &&
          $m() &&
          ((Zg === ey.CAMERA_NORMAL && ay === sy.FRONT) || Zg === ey.CAMERA_INTELIGENCE) &&
          (Ay.video.facingMode = 'user'),
        Object.assign(wg, Ay),
        Dy(wg)),
      navigator.mediaDevices
        .getUserMedia(wg)
        .then(function (t) {
          ky(t), My(), ab(), zy(), Gy(), Zg === ey.CAMERA_INTELIGENCE ? (Ky(), gb()) : $g && (ag(), cg(), ($g = !1))
        })
        .catch(function (t) {
          Fy(t)
        })
  }
  function By() {
    Sg && Sg.stop(), Wy(), cg(), db(), (_g = !1)
  }
  function Ly() {
    ;(Rg.style.display = 'unset'), (wy.style.display = 'unset'), ag()
  }
  function Wy() {
    ;(Rg.style.display = 'none'), (wy.style.display = 'none')
  }
  function zy() {
    Zg === ey.CAMERA_NORMAL
      ? ((Sy.style.top = ''),
        (Sy.style.bottom = (wy.offsetHeight - Vg) / 2 / 2 / 2 + 'px'),
        (Sy.style.display = 'inline-block'))
      : ny === ry.CNH ||
        ny === ry.RG ||
        ny === ry.CPF ||
        ny === ry.NEW_RG ||
        ny === ry.RG_FRONT ||
        ny === ry.RG_BACK ||
        ny === ry.NEW_RG_FRONT ||
        ny === ry.NEW_RG_BACK ||
        ny === ry.OTHERS
      ? ((Sy.style.bottom = ''), (Sy.style.top = Fg + 10 + 'px'), (Sy.style.display = 'inline-block'), pb())
      : Zg === ey.CAMERA_INTELIGENCE && (Sy.style.display = 'none')
  }
  function Gy() {
    var t = _y.offsetHeight - Gg,
      e = _y.offsetWidth - zg,
      t = 0 < t ? t / 2 : 0,
      e = 0 < e ? e / 2 : 0
    Ey.style.padding = `${t}px ${e}px`
  }
  function Uy() {
    document.fullscreenElement && document.exitFullscreen && document.exitFullscreen()
  }
  function Vy() {
    bb(), window.scrollTo(0, document.body.scrollHeight), Hy(), Uy()
  }
  function Hy() {
    _g && ((Zg === ey.CAMERA_NORMAL || Zg === ey.CAMERA_INTELIGENCE ? ib : sb)(), zy(), Gy(), My(), lg(wy, Vg))
  }
  async function jy() {
    window.addEventListener('resize', (t) => {
      bb(), Hy(), Uy()
    })
  }
  function qy(t) {
    ;(Kg = [t].concat(Kg).slice(0, 30)), Kg.reduce((t, e) => t + e), Kg.length
  }
  function Ky() {
    Yg ||
      (8 <= Jg
        ? ((Zg = ey.CAMERA_NORMAL), ib(), zy(), ag(), cg(), ($g = !1), $y())
        : setTimeout(() => {
            Jg++, Ky()
          }, 1e3))
  }
  function Xy() {
    yy &&
      setTimeout(() => {
        gy++, Xy()
      }, 1e3)
  }
  async function $y() {
    try {
      if (
        Zg === ey.CAMERA_NORMAL ||
        ny === ry.CNH ||
        ny === ry.RG ||
        ny === ry.CPF ||
        ny === ry.NEW_RG ||
        ny === ry.RG_FRONT ||
        ny === ry.RG_BACK ||
        ny === ry.NEW_RG_FRONT ||
        ny === ry.NEW_RG_BACK ||
        ny === ry.OTHERS
      ) {
        if (wy.paused || wy.ended || Xg)
          return setTimeout(() => {
            $y()
          })
        yy || ((yy = !0), Xy())
        var e = Date.now()
        qy(Date.now() - e)
      } else if (Zg === ey.CAMERA_INTELIGENCE) {
        if (wy.paused || wy.ended || !fg() || ($m() && Eg === Iy.LANDSCAPE) || Xg)
          return setTimeout(() => {
            $y()
          })
        var n = dg(),
          r = Date.now(),
          n = ((o = wy), void 0 === (e = n) && (e = new ev()), await new qm(o, e).withFaceLandmarks())
        if ((qy(Date.now() - r), $g && n)) (Yg = !0), ag(), (yy = !0), Xy(), ($g = !1)
        else if (n) {
          if (Xg)
            return setTimeout(() => {
              $y()
            })
          let t =
            ((o = Ey),
            (e = wy),
            (r = (r = void 0 === (r = !0) ? !1 : r) ? Cd(e) : e),
            (e = r.width),
            (r = r.height),
            { width: (o.width = e), height: (o.height = r) })
          ;(t.height = wy.offsetHeight), (t.width = wy.offsetWidth)
          n = (function e(t, n) {
            var r = new mp(n.width, n.height),
              o = r.width,
              i = r.height
            if (o <= 0 || i <= 0)
              throw new Error('resizeResults - invalid dimensions: ' + JSON.stringify({ width: o, height: i }))
            if (Array.isArray(t))
              return t.map(function (t) {
                return e(t, { width: o, height: i })
              })
            if (cf(t))
              return (
                (n = t.detection.forSize(o, i)), (r = t.unshiftedLandmarks.forSize(n.box.width, n.box.height)), lf(ld(t, n), r)
              )
            return cd(t) ? ld(t, t.detection.forSize(o, i)) : t instanceof jp || t instanceof Bp ? t.forSize(o, i) : t
          })(n, t)
          rb(
            n.landmarks.positions[0]._x,
            n.landmarks.positions[0]._y,
            n.landmarks.positions[16]._x,
            n.landmarks.positions[16]._y,
            n.landmarks.positions[27]._x,
            n.landmarks.positions[27]._y,
          ) &&
            (hy || Qy(1700))
        } else Yy(dy.NEUTRAL), cg()
      }
      return setTimeout(() => {
        $y()
      })
    } catch (t) {
      window.console.error(t)
    }
    var o
  }
  function Yy(t) {
    ;(Ry = Ry || _y.querySelector('#focus-silhouette')),
      Ry.getAttribute('style') !== `stroke: ${t};` && Ry.setAttribute('style', `stroke: ${t};`)
  }
  function Jy() {
    ig(), (Sy.style.display = 'none')
  }
  function Qy(t) {
    ;(hy = !0),
      (py = setTimeout(() => {
        ly ? (clearTimeout(py), tb()) : ((hy = !1), clearTimeout(py))
      }, t))
  }
  function Zy(t) {
    var e = t.split(':'),
      n = $m() ? 'mobile' : 'desktop',
      t = Ym() ? 'ios' : Jm() ? 'android' : 'windows'
    return `${e[0]}:js-npm-${n}-${t}|${xg}/${e[1]}`
  }
  function tb() {
    var t
    _g
      ? Zg === ey.CAMERA_NORMAL ||
        Zg === ey.CAMERA_INTELIGENCE ||
        ny === ry.CNH ||
        ny === ry.CPF ||
        ny === ry.OTHERS ||
        ny === ry.RG_FRONT ||
        ny === ry.RG_BACK ||
        ny === ry.NEW_RG_FRONT ||
        ny === ry.NEW_RG_BACK
        ? ((t = nb()), (Xg = !0), Jy(), By(), ag(), Qg.on.success({ base64: Zy(t), Log: eb() }))
        : (ny !== ry.RG && ny !== ry.NEW_RG) ||
          (oy === iy.FRONT
            ? ((cy = nb()),
              (oy = iy.BACK),
              (Xg = !1),
              fb(),
              ig(),
              sb(),
              setTimeout(() => {
                ag()
              }, 1e3))
            : oy === iy.BACK &&
              ((t = nb()), (Xg = !0), Jy(), By(), ag(), Qg.on.success({ base64: Zy(cy), base64Back: Zy(t), Log: eb() })))
      : (Ly(), Py())
  }
  function eb() {
    return null !== Zg
      ? {
          TYPE_PROCESS_INITIAL: ty,
          TYPE_PROCESS: Zg,
          TOTAL_SECONDS: gy,
          Device: i.ua,
          SILHOUETTE: { width: Ug, height: Vg },
          video: { width: wy.offsetWidth, height: wy.offsetHeight },
          radio: Wg,
          screen: { width: screen.width, height: screen.height },
        }
      : null !== ny
      ? {
          TYPE_PROCESS_DOCUMENT: ny,
          TOTAL_SECONDS: gy,
          Device: i.ua,
          SILHOUETTE: { width: Ug, height: Vg },
          video: { width: wy.offsetWidth, height: wy.offsetHeight },
          radio: Wg,
          screen: { width: screen.width, height: screen.height },
        }
      : void 0
  }
  function nb() {
    return (
      (Cy.width = wy.videoWidth),
      (Cy.height = wy.videoHeight),
      Cy.getContext('2d').drawImage(wy, 0, 0),
      Cy.toDataURL('image/jpeg')
    )
  }
  function rb(t, e, n, r, o, i) {
    return (
      (by.silhoutteWidth = Ug),
      $m()
        ? ((xy.topSilhouetteThresholdVertical = 8),
          (xy.bottomSilhouetteThresholdVertical = 3.47),
          (xy.inSilhouetteThresholdHorizontal = 10),
          (xy.overSilhouetteThresholdHorizontal = 4),
          (xy.faceTurnedSilhouetteThresholdHorizontal = 15),
          (xy.differenceNoseYThreshold = 7))
        : 640 === Hg && 480 === jg
        ? 1500 < wy.offsetWidth
          ? ((xy.topSilhouetteThresholdVertical = 6),
            (xy.bottomSilhouetteThresholdVertical = 5),
            (xy.inSilhouetteThresholdHorizontal = 4),
            (xy.overSilhouetteThresholdHorizontal = 14),
            (xy.faceTurnedSilhouetteThresholdHorizontal = 9),
            (xy.differenceNoseYThreshold = 9))
          : wy.offsetWidth < 1499 && 850 < wy.offsetWidth
          ? ((xy.topSilhouetteThresholdVertical = 6),
            (xy.bottomSilhouetteThresholdVertical = 2),
            (xy.inSilhouetteThresholdHorizontal = -1.5),
            (xy.overSilhouetteThresholdHorizontal = 6),
            (xy.faceTurnedSilhouetteThresholdHorizontal = 9),
            (xy.differenceNoseYThreshold = 9))
          : ((xy.topSilhouetteThresholdVertical = 5),
            (xy.bottomSilhouetteThresholdVertical = 4),
            (xy.inSilhouetteThresholdHorizontal = 2),
            (xy.overSilhouetteThresholdHorizontal = 6),
            (xy.faceTurnedSilhouetteThresholdHorizontal = 15),
            (xy.differenceNoseYThreshold = 10))
        : 1500 < wy.offsetWidth
        ? ((xy.topSilhouetteThresholdVertical = 4),
          (xy.bottomSilhouetteThresholdVertical = 3),
          (xy.inSilhouetteThresholdHorizontal = 1),
          (xy.overSilhouetteThresholdHorizontal = 4),
          (xy.faceTurnedSilhouetteThresholdHorizontal = 9),
          (xy.differenceNoseYThreshold = 7))
        : wy.offsetWidth < 1499 && 600 < wy.offsetWidth
        ? ((xy.topSilhouetteThresholdVertical = 8),
          (xy.bottomSilhouetteThresholdVertical = 6),
          (xy.inSilhouetteThresholdHorizontal = 3),
          (xy.overSilhouetteThresholdHorizontal = 8),
          (xy.faceTurnedSilhouetteThresholdHorizontal = 18),
          (xy.differenceNoseYThreshold = 14))
        : ((xy.topSilhouetteThresholdVertical = 10),
          (xy.bottomSilhouetteThresholdVertical = 8),
          (xy.inSilhouetteThresholdHorizontal = 5),
          (xy.overSilhouetteThresholdHorizontal = 10),
          (xy.faceTurnedSilhouetteThresholdHorizontal = 20),
          (xy.differenceNoseYThreshold = 16)),
      (by.topSilhouetteThresholdVertical = (xy.topSilhouetteThresholdVertical / 100) * wy.offsetHeight),
      (by.bottomSilhouetteThresholdVertical = (xy.bottomSilhouetteThresholdVertical / 100) * wy.offsetHeight),
      (by.inSilhouetteThresholdHorizontal = (xy.inSilhouetteThresholdHorizontal / 100) * wy.offsetWidth),
      (by.overSilhouetteThresholdHorizontal = (xy.overSilhouetteThresholdHorizontal / 100) * wy.offsetWidth),
      (by.faceTurnedSilhouetteThresholdHorizontal = (xy.faceTurnedSilhouetteThresholdHorizontal / 100) * wy.offsetWidth),
      (by.differenceNoseYThreshold = (xy.differenceNoseYThreshold / 100) * wy.offsetHeight),
      (by.differenceLeftY = e - i),
      (by.differenceRightY = r - i),
      (by.CSPWidthLeft = wy.offsetWidth / 2 - by.silhoutteWidth / 2),
      (by.CSPWidthRight = wy.offsetWidth / 2 + by.silhoutteWidth / 2),
      (by.CSPHeightTop = wy.offsetHeight / 2 - by.topSilhouetteThresholdVertical),
      (by.CSPHeightBottom = wy.offsetHeight / 2 + by.bottomSilhouetteThresholdVertical),
      (by.distanceLeftByNose = o - t),
      (by.distanceRightByNose = n - o),
      by.distanceLeftByNose >= by.distanceRightByNose
        ? (by.differenceInDistance = by.distanceLeftByNose - by.distanceRightByNose)
        : (by.differenceInDistance = by.distanceRightByNose - by.distanceLeftByNose),
      t >= by.CSPWidthLeft - by.overSilhouetteThresholdHorizontal &&
      t <= by.CSPWidthLeft + by.inSilhouetteThresholdHorizontal &&
      n <= by.CSPWidthRight + by.overSilhouetteThresholdHorizontal &&
      n >= by.CSPWidthRight - by.inSilhouetteThresholdHorizontal &&
      i >= by.CSPHeightTop &&
      i <= by.CSPHeightBottom &&
      by.differenceInDistance < by.faceTurnedSilhouetteThresholdHorizontal &&
      by.differenceLeftY < by.differenceNoseYThreshold &&
      by.differenceRightY < by.differenceNoseYThreshold &&
      by.differenceLeftY > -by.differenceNoseYThreshold &&
      by.differenceRightY > -by.differenceNoseYThreshold
        ? (Yy(dy.PRIMARY), ug('Não se mexa...'), (ly = !0))
        : (Yy(dy.SECONDARY),
          (n - t > by.silhoutteWidth ||
            n - t < by.silhoutteWidth - by.inSilhouetteThresholdHorizontal ||
            i <= by.CSPHeightTop ||
            i >= by.CSPHeightBottom ||
            t <= by.CSPWidthLeft - by.overSilhouetteThresholdHorizontal ||
            n >= by.CSPWidthRight + by.overSilhouetteThresholdHorizontal ||
            (by.differenceLeftY > by.differenceNoseYThreshold && by.differenceRightY > by.differenceNoseYThreshold) ||
            (by.differenceLeftY < -by.differenceNoseYThreshold && by.differenceRightY < -by.differenceNoseYThreshold) ||
            by.distanceLeftByNose > by.distanceRightByNose ||
            by.distanceLeftByNose < by.distanceRightByNose) &&
            ug('Enquadre o rosto no contorno'),
          (ly = !1),
          (hy = !1),
          clearTimeout(py),
          !1)
    )
  }
  function ob() {
    wy.addEventListener('play', () => {
      ;(_g = !0), $y()
    })
  }
  function ib() {
    var t = wy.offsetWidth,
      e = wy.offsetHeight,
      n = dy.NEUTRAL
    e < t && (Eg = Iy.LANDSCAPE),
      $m()
        ? ((zg = wy.offsetWidth), (Gg = wy.offsetHeight))
        : ((l = wy.offsetWidth / wy.offsetHeight),
          (zg = Wg > l ? ((Gg = wy.offsetWidth / Wg), wy.offsetWidth) : ((Gg = wy.offsetHeight), wy.offsetHeight * Wg))),
      $m() && jg > Hg && ((p = jg), (h = Hg), (jg = h), (Hg = p))
    var r = (zg / Hg) * bg.CLOSE.WIDTH,
      o = (Gg / jg) * bg.CLOSE.HEIGHT
    Vg = $m()
      ? ((Ug = Eg === Iy.PORTRAIT ? o / (bg.CLOSE.HEIGHT / bg.CLOSE.WIDTH) : r), o)
      : 640 === Hg && 480 === jg
      ? ((Ug = 0.65 * Gg * 0.7), 0.65 * Gg)
      : ((Ug = r), o)
    var i = null !== _y.querySelector('#svgMask'),
      a = t / 2,
      s = e / 2,
      u = Ug / 2,
      c = Vg / 2,
      l = Vg / 4,
      h = 0.15 * u,
      p = a - u,
      r = s - c,
      o = u - h,
      s = `M0,0${'V' + e}${'H' + t}V0Z${`M${a + u},${s + l}`}${`A${o},${o},0,0,1,${a + h},${s + c}`}${`H${
        a - 2 * h
      }`}${`A${o},${o},0,0,1,${p},${s + l}`}${`V${s - l}`}${`A${o},${o},0,0,1,${a - h},${r}`}${`h${
        2 * h
      }`}${`A${o},${o},0,0,1,${a + u},${s - l}`}Z`,
      l = 'http://www.w3.org/2000/svg'
    ;(Rg = Rg || document.createElementNS(l, 'svg')),
      Rg.setAttributeNS(null, 'viewBox', '0 0 ' + t + ' ' + e),
      Rg.setAttributeNS(null, 'width', t),
      (Rg.style.display = 'block'),
      Rg.setAttributeNS(null, 'id', 'svgMask'),
      (Ig = Ig || document.createElementNS(l, 'defs')),
      (Ag = Ag || document.createElementNS(l, 'style')),
      (Ag.textContent = `.cls-background{opacity:0.7;}.cls-focus{fill:none;stroke:${n};stroke-miterlimit:10;stroke-width:5px;}`),
      (Ng = Ng || document.createElementNS(l, 'g')),
      Ng.setAttributeNS(null, 'id', 'main'),
      Ng.setAttributeNS(null, 'data-name', 'main'),
      (kg = kg || document.createElementNS(l, 'g')),
      kg.setAttributeNS(null, 'id', 'mask'),
      (Tg = Tg || document.createElementNS(l, 'path')),
      Tg.setAttributeNS(null, 'id', 'background'),
      Tg.setAttributeNS(null, 'class', 'cls-background'),
      Tg.setAttributeNS(null, 'd', s),
      (Og = Og || document.createElementNS(l, 'rect')),
      Og.setAttributeNS(null, 'id', 'focus-silhouette'),
      Og.setAttributeNS(null, 'class', 'cls-focus'),
      Og.setAttributeNS(null, 'x', p),
      Og.setAttributeNS(null, 'y', r),
      Og.setAttributeNS(null, 'width', Ug),
      Og.setAttributeNS(null, 'height', Vg),
      Og.setAttributeNS(null, 'rx', o),
      Og.setAttributeNS(null, 'style', `stroke: ${n};`),
      i ||
        (kg.appendChild(Tg),
        kg.appendChild(Og),
        Ng.appendChild(kg),
        Ig.appendChild(Ag),
        Rg.appendChild(Ig),
        Rg.appendChild(Ng),
        _y.appendChild(Rg))
  }
  function ab() {
    Zg === ey.CAMERA_NORMAL || Zg === ey.CAMERA_INTELIGENCE
      ? ib()
      : (ny !== ry.CNH &&
          ny !== ry.RG &&
          ny !== ry.CPF &&
          ny !== ry.NEW_RG &&
          ny !== ry.OTHERS &&
          ny !== ry.RG_FRONT &&
          ny !== ry.RG_BACK &&
          ny !== ry.NEW_RG_FRONT &&
          ny !== ry.NEW_RG_BACK) ||
        sb()
  }
  function sb() {
    var t = wy.offsetWidth,
      e = wy.offsetHeight,
      n = dy.NEUTRAL
    e < t && (Eg = Iy.LANDSCAPE),
      $m()
        ? ((zg = wy.offsetWidth), (Gg = wy.offsetHeight))
        : ((v = wy.offsetWidth / wy.offsetHeight),
          (zg = Wg > v ? ((Gg = wy.offsetWidth / Wg), wy.offsetWidth) : ((Gg = wy.offsetHeight), wy.offsetHeight * Wg))),
      $m() && Ym() && jg > Hg && ((b = jg), (m = Hg), (jg = m), (Hg = b))
    let r, o
    ;(o = $m() ? ((r = 0.95 * zg), 0.75 * Gg) : ((r = 0.7 * Gg * 0.75), 0.7 * Gg)),
      (Vg = ((Ug = $m() && Eg === Iy.PORTRAIT ? o / ((0.75 * Gg) / (0.95 * zg)) : r), o)),
      (Vg = ($m(), (Ug = r), o))
    var i = null !== _y.querySelector('#svgMask'),
      a = t / 2,
      s = e / 2 - Math.round(0.09 * e),
      u = Ug / 2,
      c = Vg / 2,
      l = 0.15 * u,
      h = a + u
    let p = s + c
    var d = a + l
    let f = s + c
    var v = a - 2 * l,
      m = a - u
    let g = s + c,
      y = s - c
    var b = a - l
    let x = s - c
    ;(l *= 2), (u = a + u)
    let w = s - c
    $m() && ((x /= 2), (w /= 2), (f -= x), (g -= x), (p -= x), (y /= 2))
    var C,
      E,
      l = `M0,0${'V' + e}${
        'H' + t
      }V0Z${`M${h},${p}`}${`A0,0,0,0,1,${d},${f}`}${`H${v}`}${`A0,0,0,0,1,${m},${g}`}${`V${y}`}${`A0,0,0,0,1,${b},${x}`}${`h${l}`}${`A0,0,0,0,1,${u},${w}`}Z`,
      u = 'http://www.w3.org/2000/svg'
    ;(Fg = x + Vg),
      (Rg = Rg || document.createElementNS(u, 'svg')),
      Rg.setAttributeNS(null, 'viewBox', '0 0 ' + t + ' ' + e),
      Rg.setAttributeNS(null, 'width', t),
      Rg.setAttributeNS(null, 'height', e),
      (Rg.style.display = 'block'),
      Rg.setAttributeNS(null, 'id', 'svgMask'),
      (Ig = Ig || document.createElementNS(u, 'defs')),
      (Ag = Ag || document.createElementNS(u, 'style')),
      (Ag.textContent = `.cls-background{opacity:0.7;}.cls-focus{fill:none;stroke:${n};stroke-miterlimit:10;stroke-width:3px;}`),
      (Ng = Ng || document.createElementNS(u, 'g')),
      Ng.setAttributeNS(null, 'id', 'main'),
      Ng.setAttributeNS(null, 'data-name', 'main'),
      (kg = kg || document.createElementNS(u, 'g')),
      kg.setAttributeNS(null, 'id', 'mask'),
      (Tg = Tg || document.createElementNS(u, 'path')),
      Tg.setAttributeNS(null, 'id', 'background'),
      Tg.setAttributeNS(null, 'class', 'cls-background'),
      Tg.setAttributeNS(null, 'd', l),
      (Og = Og || document.createElementNS(u, 'rect')),
      Og.setAttributeNS(null, 'id', 'focus-silhouette'),
      Og.setAttributeNS(null, 'class', 'cls-focus'),
      Og.setAttributeNS(null, 'x', m),
      Og.setAttributeNS(null, 'y', x),
      Og.setAttributeNS(null, 'width', Ug),
      Og.setAttributeNS(null, 'height', Vg),
      Og.setAttributeNS(null, 'rx', 0),
      ny === ry.CNH
        ? ((Dg = Dg || document.createElementNS(u, 'path')),
          Dg.setAttributeNS(null, 'id', 'line'),
          Dg.setAttributeNS(null, 'd', `M ${m} ${$m() ? s - x : s} l ${h - m} 0`),
          Dg.setAttributeNS(null, 'fill', 'none'),
          Dg.setAttributeNS(null, 'stroke', n),
          Dg.setAttributeNS(null, 'stroke-width', '3'),
          (Mg = Mg || document.createElementNS(u, 'rect')),
          Mg.setAttributeNS(null, 'id', 'rect-top-cnh'),
          Mg.setAttributeNS(null, 'class', 'cls-focus'),
          Mg.setAttributeNS(null, 'x', m + 0.19 * Ug),
          Mg.setAttributeNS(null, 'y', ($m() ? s - x : s) - (0.13 * c + 0.57 * c)),
          Mg.setAttributeNS(null, 'width', 0.3 * Ug),
          Mg.setAttributeNS(null, 'height', 0.57 * c),
          Mg.setAttributeNS(null, 'stroke-width', 3),
          Mg.setAttributeNS(null, 'fill', 'none'),
          Mg.setAttributeNS(null, 'stroke', n),
          (Pg = Pg || document.createElementNS(u, 'rect')),
          Pg.setAttributeNS(null, 'id', 'rect-bottom-cnh'),
          Pg.setAttributeNS(null, 'class', 'cls-focus'),
          Pg.setAttributeNS(null, 'x', m + 0.16 * Ug),
          Pg.setAttributeNS(null, 'y', ($m() ? s - x : s) + 0.05 * c),
          Pg.setAttributeNS(null, 'width', 0.77 * Ug),
          Pg.setAttributeNS(null, 'height', 0.4 * c),
          Pg.setAttributeNS(null, 'stroke-width', 3),
          Pg.setAttributeNS(null, 'fill', 'none'),
          Pg.setAttributeNS(null, 'stroke', n),
          (Bg = Bg || document.createElementNS(u, 'text')),
          Bg.setAttributeNS(null, 'id', 'text1'),
          Bg.setAttributeNS(null, 'class', 'cls-text'),
          Bg.setAttributeNS(null, 'x', m + 0.19 * Ug),
          Bg.setAttributeNS(null, 'y', ($m() ? s - x : s) - (0.13 * c + 0.57 * c) - 10),
          Bg.setAttributeNS(null, 'fill', n),
          Bg.setAttributeNS(null, 'stroke', n),
          (Bg.innerHTML = ''),
          (c = document.createTextNode('FOTO')),
          Bg.appendChild(c))
        : (ny === ry.RG && oy === iy.FRONT) || ny === ry.RG_FRONT
        ? ((Mg = Mg || document.createElementNS(u, 'rect')),
          Mg.setAttributeNS(null, 'id', 'rect1'),
          Mg.setAttributeNS(null, 'class', 'cls-focus'),
          Mg.setAttributeNS(null, 'x', m + (Ug - 0.45 * Ug) / 2),
          Mg.setAttributeNS(null, 'y', ($m() ? s - x : s) - 0.4 * Vg),
          Mg.setAttributeNS(null, 'width', 0.45 * Ug),
          Mg.setAttributeNS(null, 'height', 0.4 * Vg),
          Mg.setAttributeNS(null, 'stroke-width', 3),
          Mg.setAttributeNS(null, 'fill', 'none'),
          Mg.setAttributeNS(null, 'stroke', n),
          (Pg = Pg || document.createElementNS(u, 'rect')),
          Pg.setAttributeNS(null, 'id', 'rect2'),
          Pg.setAttributeNS(null, 'class', 'cls-focus'),
          Pg.setAttributeNS(null, 'x', m + (Ug - 0.45 * Ug) / 2),
          Pg.setAttributeNS(null, 'y', ($m() ? s - x : s) + 0.05 * Vg),
          Pg.setAttributeNS(null, 'width', 0.45 * Ug),
          Pg.setAttributeNS(null, 'height', 0.38 * Vg),
          Pg.setAttributeNS(null, 'stroke-width', 3),
          Pg.setAttributeNS(null, 'fill', 'none'),
          Pg.setAttributeNS(null, 'stroke', n),
          (Bg = Bg || document.createElementNS(u, 'text')),
          Bg.setAttributeNS(null, 'id', 'text1'),
          Bg.setAttributeNS(null, 'class', 'cls-text'),
          Bg.setAttributeNS(null, 'x', a - 25),
          Bg.setAttributeNS(null, 'y', ($m() ? s - x : s) - 0.42 * Vg),
          Bg.setAttributeNS(null, 'fill', n),
          Bg.setAttributeNS(null, 'stroke', n),
          (Bg.innerHTML = ''),
          (a = document.createTextNode('FOTO')),
          Bg.appendChild(a))
        : (ny === ry.RG && oy === iy.BACK) || ny === ry.RG_BACK
        ? ((Mg = Mg || document.createElementNS(u, 'rect')),
          Mg.setAttributeNS(null, 'id', 'rect1'),
          Mg.setAttributeNS(null, 'class', 'cls-focus'),
          Mg.setAttributeNS(null, 'x', m + (Ug - 0.15 * Ug)),
          Mg.setAttributeNS(null, 'y', ($m() ? s - x : s) - 0.28 * Vg),
          Mg.setAttributeNS(null, 'width', 0.0735 * Ug),
          Mg.setAttributeNS(null, 'height', 0.198 * Vg),
          Mg.setAttributeNS(null, 'stroke-width', 3),
          Mg.setAttributeNS(null, 'fill', 'none'),
          Mg.setAttributeNS(null, 'stroke', n),
          (Pg = Pg || document.createElementNS(u, 'rect')),
          Pg.setAttributeNS(null, 'id', 'rect2'),
          Pg.setAttributeNS(null, 'class', 'cls-focus'),
          Pg.setAttributeNS(null, 'x', m + (Ug - 0.3 * Ug)),
          Pg.setAttributeNS(null, 'y', ($m() ? s - x : s) - 0.28 * Vg),
          Pg.setAttributeNS(null, 'width', 0.0735 * Ug),
          Pg.setAttributeNS(null, 'height', 0.49 * Vg),
          Pg.setAttributeNS(null, 'stroke-width', 3),
          Pg.setAttributeNS(null, 'fill', 'none'),
          Pg.setAttributeNS(null, 'stroke', n),
          (Bg = Bg || document.createElementNS(u, 'text')),
          Bg.setAttributeNS(null, 'id', 'text1'),
          Bg.setAttributeNS(null, 'class', 'cls-text'),
          Bg.setAttributeNS(null, 'x', m + (Ug - (0.3 * Ug - (0.0735 * Ug) / 2))),
          Bg.setAttributeNS(null, 'y', ($m() ? s - x : s) - 0.45 * Vg),
          Bg.setAttributeNS(null, 'stroke', n),
          Bg.setAttributeNS(null, 'fill', n),
          Bg.setAttributeNS(null, 'style', 'writing-mode: tb;'),
          (Bg.innerHTML = ''),
          (C = document.createTextNode('NOME')),
          Bg.appendChild(C))
        : (ny === ry.NEW_RG && oy === iy.FRONT) || ny === ry.NEW_RG_FRONT
        ? ((Mg = Mg || document.createElementNS(u, 'rect')),
          Mg.setAttributeNS(null, 'id', 'rect1'),
          Mg.setAttributeNS(null, 'class', 'cls-focus'),
          Mg.setAttributeNS(null, 'x', m + (Ug - 0.58 * Ug - 0.09 * Ug)),
          Mg.setAttributeNS(null, 'y', ($m() ? s - x : s) - 0.4 * Vg),
          Mg.setAttributeNS(null, 'width', 0.58 * Ug),
          Mg.setAttributeNS(null, 'height', 0.3 * Vg),
          Mg.setAttributeNS(null, 'stroke-width', 3),
          Mg.setAttributeNS(null, 'fill', 'none'),
          Mg.setAttributeNS(null, 'stroke', n),
          (Bg = Bg || document.createElementNS(u, 'text')),
          Bg.setAttributeNS(null, 'id', 'text1'),
          Bg.setAttributeNS(null, 'class', 'cls-text'),
          Bg.setAttributeNS(null, 'x', m + (Ug - 0.58 * Ug - 0.09 * Ug)),
          Bg.setAttributeNS(null, 'y', ($m() ? s - x : s) - 0.42 * Vg),
          Bg.setAttributeNS(null, 'fill', n),
          Bg.setAttributeNS(null, 'stroke', n),
          (Bg.innerHTML = ''),
          (C = document.createTextNode('FOTO')),
          Bg.appendChild(C))
        : (ny === ry.NEW_RG && oy === iy.BACK) || ny === ry.NEW_RG_BACK
        ? ((Mg = Mg || document.createElementNS(u, 'rect')),
          Mg.setAttributeNS(null, 'id', 'rect1'),
          Mg.setAttributeNS(null, 'class', 'cls-focus'),
          Mg.setAttributeNS(null, 'x', m + 0.09 * Ug),
          Mg.setAttributeNS(null, 'y', ($m() ? s - x : s) + (0.25 * Vg) / 2),
          Mg.setAttributeNS(null, 'width', 0.62 * Ug),
          Mg.setAttributeNS(null, 'height', 0.3 * Vg),
          Mg.setAttributeNS(null, 'stroke-width', 3),
          Mg.setAttributeNS(null, 'fill', 'none'),
          Mg.setAttributeNS(null, 'stroke', n),
          (Bg = Bg || document.createElementNS(u, 'text')),
          Bg.setAttributeNS(null, 'id', 'text1'),
          Bg.setAttributeNS(null, 'class', 'cls-text'),
          Bg.setAttributeNS(null, 'x', m + 0.09 * Ug),
          Bg.setAttributeNS(null, 'y', ($m() ? s - x : s) + (0.25 * Vg) / 2 - 10),
          Bg.setAttributeNS(null, 'fill', n),
          Bg.setAttributeNS(null, 'stroke', n),
          (Bg.innerHTML = ''),
          (E = document.createTextNode('DIGITAL')),
          Bg.appendChild(E))
        : ny === ry.CPF &&
          ((Bg = Bg || document.createElementNS(u, 'text')),
          Bg.setAttributeNS(null, 'id', 'text1'),
          Bg.setAttributeNS(null, 'class', 'cls-text-medium'),
          Bg.setAttributeNS(null, 'x', m + 0.4 * Ug),
          Bg.setAttributeNS(null, 'y', ($m() ? s - x : s) - 0.45 * Vg),
          Bg.setAttributeNS(null, 'stroke', n),
          Bg.setAttributeNS(null, 'fill', n),
          Bg.setAttributeNS(null, 'style', 'writing-mode: tb;'),
          (Bg.innerHTML = ''),
          (E = document.createTextNode('000.000.000-00')),
          Bg.appendChild(E),
          (Lg = Lg || document.createElementNS(u, 'text')),
          Lg.setAttributeNS(null, 'id', 'text2'),
          Lg.setAttributeNS(null, 'class', 'cls-text-big'),
          Lg.setAttributeNS(null, 'x', m + (Ug - (0.3 * Ug - (0.09 * Ug) / 2))),
          Lg.setAttributeNS(null, 'y', ($m() ? s - x : s) - 0.3 * Vg),
          Lg.setAttributeNS(null, 'stroke', n),
          Lg.setAttributeNS(null, 'fill', n),
          Lg.setAttributeNS(null, 'style', 'writing-mode: tb;'),
          (Lg.innerHTML = ''),
          (n = document.createTextNode('CPF')),
          Lg.appendChild(n)),
      i ||
        (kg.appendChild(Tg),
        kg.appendChild(Og),
        ny === ry.CNH && kg.appendChild(Dg),
        (ny !== ry.CNH &&
          ny !== ry.RG &&
          ny !== ry.NEW_RG &&
          ny !== ry.RG_FRONT &&
          ny !== ry.RG_BACK &&
          ny !== ry.NEW_RG_FRONT &&
          ny !== ry.NEW_RG_BACK) ||
          kg.appendChild(Mg),
        (ny !== ry.CNH && ny !== ry.RG && ny !== ry.RG_FRONT && ny !== ry.RG_BACK) || kg.appendChild(Pg),
        (ny !== ry.CNH &&
          ny !== ry.RG &&
          ny !== ry.NEW_RG &&
          ny !== ry.RG_FRONT &&
          ny !== ry.RG_BACK &&
          ny !== ry.NEW_RG_FRONT &&
          ny !== ry.NEW_RG_BACK &&
          ny !== ry.CPF) ||
          kg.appendChild(Bg),
        ny === ry.CPF && kg.appendChild(Lg),
        Ng.appendChild(kg),
        Ig.appendChild(Ag),
        Rg.appendChild(Ig),
        Rg.appendChild(Ng),
        _y.appendChild(Rg))
  }
  function ub() {
    var t = $m()
      ? Jm()
        ? { message: 'Navegadores permitidos:', listBrowsersSupport: ['Chrome', 'Firefox', 'Edge', 'Opera'] }
        : Ym()
        ? { message: 'Navegadores permitidos:', listBrowsersSupport: ['Safari'] }
        : void 0
      : Ym()
      ? { message: 'Navegadores permitidos:', listBrowsersSupport: ['Safari'] }
      : { message: 'Navegadores permitidos:', listBrowsersSupport: ['Chrome', 'Firefox', 'Edge', 'Opera'] }
    return Qg.on.support(t)
  }
  function cb() {
    ;(Zg = null), (ty = null), (ny = null)
  }
  function lb() {
    ;(wg = {}),
      (Cg = { video: { facingMode: 'user' }, audio: !1 }),
      (Wg = 1280 / 720),
      (Hg = 1280),
      (jg = 720),
      (qg = !1),
      (Kg = []),
      (Xg = !1),
      (Yg = !1),
      (Jg = 0),
      (oy = null),
      (cy = null),
      (ly = !1),
      (hy = !1),
      (py = null),
      (gy = 0),
      (yy = !1),
      (Eg = null),
      (Sg = null),
      (_g = null),
      (Rg = null),
      (Ig = null),
      (Ag = null),
      (Ng = null),
      (kg = null),
      (Tg = null),
      (Dg = null),
      (Og = null),
      (Fg = null),
      (Mg = null),
      (Pg = null),
      (Bg = null),
      (Lg = null),
      (Wg = 1280 / 720),
      (zg = 0),
      (Gg = 0),
      (Ug = 0),
      (Vg = 0),
      (Hg = 1280),
      (jg = 720),
      (qg = !1),
      (Kg = []),
      (Ry = null),
      (Xg = !1),
      (Yg = !1),
      (Jg = 0),
      _y.querySelector('#svgMask') && _y.querySelector('#svgMask').remove(),
      _y.querySelector('#box--document-info') && _y.querySelector('#box--document-info').remove()
  }
  function hb() {
    _y.innerHTML = ''
    let t = document.createElement('canvas')
    t.id = 'camera--canvas'
    let e = document.createElement('canvas')
    e.id = 'camera--overlay'
    let n = document.createElement('video')
    ;(n.id = 'camera--video'), (n.autoplay = !0), n.setAttribute('playsinline', ''), n.setAttribute('webkit-playsinline', '')
    let r = document.createElement('span')
    r.id = 'camera--message'
    let o = document.createElement('div')
    ;(o.id = 'camera--trigger'),
      (o.innerHTML = `<svg viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="m511.914062 256c0-141.386719-114.59375-256-255.957031-256-141.359375 0-255.957031 114.613281-255.957031 256s114.597656 256 255.957031 256c141.363281 0 255.957031-114.613281 255.957031-256zm0 0" fill="${fy.BACKGROUND}"/><path d="m420.035156 59.527344c33.199219 43.175781 52.953125 97.234375 52.953125 155.910156 0 141.386719-114.597656 256-255.957031 256-62.441406 0-119.652344-22.371094-164.078125-59.527344 46.792969 60.859375 120.3125 100.089844 203.003906 100.089844 141.363281 0 255.957031-114.613281 255.957031-256 0-78.933594-35.726562-149.511719-91.878906-196.472656zm0 0" fill="${fy.BACKGROUND}"/><path d="m369.839844 177.828125h-41.277344c-8.878906 0-16.699219-5.839844-19.222656-14.351563l-.523438-1.769531c-3.582031-12.074219-14.671875-20.355469-27.265625-20.355469h-51.308593c-12.667969 0-23.808594 8.378907-27.324219 20.550782l-.414063 1.4375c-2.476562 8.582031-10.332031 14.488281-19.261718 14.488281h-41.167969c-10.300781 0-18.648438 8.351563-18.648438 18.652344v148.265625c0 10.300781 8.347657 18.652344 18.648438 18.652344h227.765625c10.300781 0 18.652344-8.351563 18.652344-18.652344v-148.265625c0-10.300781-8.351563-18.652344-18.652344-18.652344zm0 0" fill="${fy.COLOR}"/><path d="m369.839844 177.828125h-41.277344c-8.878906 0-16.699219-5.839844-19.222656-14.351563l-.523438-1.769531c-3.582031-12.074219-14.671875-20.355469-27.265625-20.355469h-25.59375c12.59375 0 23.683594 8.28125 27.265625 20.355469l.523438 1.769531c2.523437 8.511719 10.34375 14.351563 19.222656 14.351563h37.1875c10.304688 0 18.652344 8.351563 18.652344 18.652344v148.265625c0 10.300781-8.347656 18.652344-18.652344 18.652344h29.683594c10.300781 0 18.652344-8.351563 18.652344-18.652344v-148.265625c0-10.300781-8.351563-18.652344-18.652344-18.652344zm0 0" fill="${fy.COLOR}"/><path d="m313.4375 266.28125c0-29.632812-24.019531-53.652344-53.644531-53.652344s-53.644531 24.019532-53.644531 53.652344 24.019531 53.652344 53.644531 53.652344 53.644531-24.019532 53.644531-53.652344zm0 0" fill="${fy.BACKGROUND}"/><path d="m295.304688 266.28125c0-19.613281-15.898438-35.515625-35.511719-35.515625s-35.511719 15.902344-35.511719 35.515625c0 19.617188 15.898438 35.515625 35.511719 35.515625s35.511719-15.898437 35.511719-35.515625zm0 0" fill="${fy.BACKGROUND}"/><path d="m366.574219 207.671875c0 4.289063-3.476563 7.765625-7.765625 7.765625-4.289063 0-7.765625-3.476562-7.765625-7.765625s3.476562-7.765625 7.765625-7.765625c4.289062 0 7.765625 3.476562 7.765625 7.765625zm0 0" fill="${fy.BACKGROUND}"/></svg>`)
    let i = document.createElement('div')
    ;(i.id = 'box--loading'), (i.style.display = 'none')
    let a = document.createElement('div')
    ;(a.id = 'box--orientation'),
      (a.style.display = 'none'),
      _y.appendChild(t),
      _y.appendChild(n),
      _y.appendChild(e),
      _y.appendChild(r),
      _y.appendChild(o),
      _y.appendChild(i),
      _y.appendChild(a)
  }
  function pb() {
    let t = _y.querySelector('#box--document-info')
    if (t) {
      var e = wy.offsetHeight - parseFloat(Sy.style.top.replace('px', '')) - Sy.offsetHeight / 2
      ;(t.style.height = e + 'px'),
        (boxInfo.style.backgroundColor = my.BACKGROUND),
        (t.innerHTML = `<span id="label--document" style="top: ${e / 2}px; color: ${my.COLOR};">${yb()}</span>`)
    } else {
      let t = document.createElement('div')
      ;(t.id = 'box--document-info'), (t.style.width = '100%')
      e = wy.offsetHeight - parseFloat(Sy.style.top.replace('px', '')) - Sy.offsetHeight / 2
      ;(t.style.height = e + 'px'),
        (t.style.backgroundColor = my.BACKGROUND),
        (t.innerHTML = `<span id="label--document" style="top: ${e / 2}px; color: ${my.COLOR};">${yb()}</span>`),
        _y.appendChild(t)
    }
  }
  function db() {
    let t = _y.querySelector('#box--document-info')
    t && (t.style.display = 'none')
  }
  function fb() {
    _y.querySelector('#label--document').innerHTML = yb()
  }
  function vb() {
    var t, e
    ;(_y = document.querySelector('#box-camera')),
      hb(),
      (wy = _y.querySelector('#camera--video')),
      (Cy = _y.querySelector('#camera--canvas')),
      (Ey = _y.querySelector('#camera--overlay')),
      (Sy = _y.querySelector('#camera--trigger')),
      hg(_y),
      (t = vy.BACKGROUND),
      (e = vy.COLOR),
      (tg.style.backgroundColor = t),
      (tg.style.color = e)
  }
  function mb() {
    Cb(), Ny(), bb(), ob(), jy(), Py(), gb()
  }
  function gb() {
    Zg === ey.CAMERA_INTELIGENCE && lg(wy, Vg)
  }
  function yb() {
    return ny === ry.CNH
      ? 'CNH Aberta'
      : ny === ry.CPF
      ? 'CPF'
      : ny === ry.RG || ny === ry.NEW_RG
      ? oy === iy.FRONT
        ? 'RG Frente'
        : 'RG Verso'
      : ny === ry.RG_FRONT || ny === ry.NEW_RG_FRONT
      ? 'RG Frente'
      : ny === ry.RG_BACK || ny === ry.NEW_RG_BACK
      ? 'RG Verso'
      : ny === ry.OTHERS
      ? uy
      : void 0
  }
  function bb() {
    var t = (screen.orientation || {}).type || screen.mozOrientation || screen.msOrientation
    ;(Eg = t
      ? 'landscape-primary' == t || 'landscape-secondary' == t
        ? Iy.LANDSCAPE
        : Iy.PORTRAIT
      : _y.offsetWidth > _y.offsetHeight
      ? Iy.LANDSCAPE
      : Iy.PORTRAIT),
      $m() &&
        (Eg === Iy.LANDSCAPE
          ? ng && ((ng.style.display = 'block'), (ng.style.visibility = 'visible'), (ng.style.opacity = 1))
          : sg())
  }
  function xb() {
    return wg
  }
  function wb() {
    document.hidden ? ((yy = !1), wy.pause()) : Xg || (wy.play(), (yy = !0), Xy())
  }
  function Cb() {
    navigator.mediaDevices.enumerateDevices().catch(Fy),
      window.addEventListener('orientationchange', Vy),
      (navigator.mediaDevices.ondevicechange = Vy),
      document.addEventListener('visibilitychange', wb, !1)
  }
  function Eb(t) {
    var e
    null != t &&
      (t.silhouette &&
        (t.silhouette.primaryColor && Sb(t.silhouette.primaryColor) && (dy.PRIMARY = t.silhouette.primaryColor),
        t.silhouette.secondaryColor && Sb(t.silhouette.secondaryColor) && (dy.SECONDARY = t.silhouette.secondaryColor),
        t.silhouette.neutralColor && Sb(t.silhouette.neutralColor) && (dy.NEUTRAL = t.silhouette.neutralColor)),
      t.buttonCapture &&
        (t.buttonCapture.backgroundColor &&
          Sb(t.buttonCapture.backgroundColor) &&
          (fy.BACKGROUND = t.buttonCapture.backgroundColor),
        t.buttonCapture.iconColor && Sb(t.buttonCapture.iconColor) && (fy.COLOR = t.buttonCapture.iconColor)),
      t.boxMessage &&
        (t.boxMessage.backgroundColor && Sb(t.boxMessage.backgroundColor) && (vy.BACKGROUND = t.boxMessage.backgroundColor),
        t.boxMessage.fontColor && Sb(t.boxMessage.fontColor) && (vy.COLOR = t.boxMessage.fontColor)),
      t.boxDocument &&
        (t.boxDocument.backgroundColor && Sb(t.boxDocument.backgroundColor) && (my.BACKGROUND = t.boxDocument.backgroundColor),
        t.boxDocument.fontColor && Sb(t.boxDocument.fontColor) && (my.COLOR = t.boxDocument.fontColor)),
      (e = t.popupLoadingHtml || ''),
      (t = t.popupOrientationHtml || ''),
      (og = void 0 !== e || null !== e ? e : ''),
      (rg = void 0 !== t || null !== t ? t : ''))
  }
  function Sb(t) {
    return /^#([0-9A-F]{3}){1,2}$/i.test(t)
  }
  function _b() {
    return null !== document.querySelector('#box-camera')
  }
  function Rb(t) {
    return (
      null != t &&
      t.on &&
      'function' == typeof t.on.success &&
      1 === t.on.success.length &&
      'function' == typeof t.on.error &&
      1 === t.on.error.length &&
      'function' == typeof t.on.support &&
      1 === t.on.support.length
    )
  }
  function Ib(t) {
    var e
    t.TYPE === ey.CAMERA_NORMAL
      ? ((Zg = ey.CAMERA_NORMAL),
        (ty = ey.CAMERA_NORMAL),
        (e = t),
        (ay = e.optional ? ((e = parseInt(e.optional.FACE_MODE)) === sy.FRONT || e === sy.BACK ? e : sy.FRONT) : sy.FRONT))
      : t.TYPE === ey.CAMERA_INTELIGENCE && ((Zg = ey.CAMERA_INTELIGENCE), (ty = ey.CAMERA_INTELIGENCE))
  }
  ;(t.addClickEvent = Ny),
    (t.addEventPlay = ob),
    (t.addEventResize = jy),
    (t.addEventsGlobal = Cb),
    (t.browserNotSupportCallback = ub),
    (t.calcBtnCapturePos = zy),
    (t.calcMarginMask = Gy),
    (t.callAllMethodsInit = mb),
    (t.changeColorMask = Yy),
    (t.closeCamera = function () {
      ;(Xg = !0), By(), ag(), sg()
    }),
    (t.createBoxDocumentInfo = pb),
    (t.createElements = hb),
    (t.getAndroidVersion = function (t) {
      return (t = (t = (t || navigator.userAgent).toLowerCase()).match(/android\s([0-9\.]*)/i)) ? t[1] : void 0
    }),
    (t.getBase64Canvas = nb),
    (t.getConstraints = xb),
    (t.getLabelDocument = yb),
    (t.getLog = eb),
    (t.gotDevices = function (e) {
      for (let t = 0; t !== e.length; ++t) {
        var n = e[t]
        if ('videoinput' === n.kind && (n.deviceId, !isFirefox)) break
      }
    }),
    (t.gotStream = ky),
    (t.handleError = Fy),
    (t.hideBoxDocumentInfo = db),
    (t.initCamera = function (t, e, n) {
      Rb(e)
        ? ((Qg = e),
          Qm()
            ? _b()
              ? null == (e = t) || !e.TYPE || (e.TYPE !== ey.CAMERA_NORMAL && e.TYPE !== ey.CAMERA_INTELIGENCE)
                ? Qg.on.error('Tipo de câmera inválido')
                : t.TYPE !== ey.CAMERA_INTELIGENCE || pg
                ? (Eb(n), cb(), Ib(t), vb(), ($g = !0), ig(), lb(), mb())
                : Qg.on.error('Modelos do face api não carregados')
              : Qg.on.error('O elemento com id #box-camera não foi encontrado!')
            : ub())
        : window.console.error('Métodos de Callback não implementados corretamente!')
    }),
    (t.initDocument = function (t, e, n) {
      Rb(e)
        ? ((Qg = e),
          Qm()
            ? _b()
              ? (function (t) {
                  if (null == t) return !1
                  return !(
                    !t.TYPE ||
                    (t.TYPE !== ry.CNH &&
                      t.TYPE !== ry.CPF &&
                      t.TYPE !== ry.RG &&
                      t.TYPE !== ry.NEW_RG &&
                      t.TYPE !== ry.RG_FRONT &&
                      t.TYPE !== ry.RG_BACK &&
                      t.TYPE !== ry.NEW_RG_FRONT &&
                      t.TYPE !== ry.NEW_RG_BACK &&
                      t.TYPE !== ry.OTHERS)
                  )
                })(t)
                ? (Eb(n),
                  cb(),
                  vb(),
                  ($g = !0),
                  ig(),
                  lb(),
                  ((t = t).TYPE !== ry.CNH &&
                    t.TYPE !== ry.CPF &&
                    t.TYPE !== ry.RG &&
                    t.TYPE !== ry.NEW_RG &&
                    t.TYPE !== ry.RG_FRONT &&
                    t.TYPE !== ry.RG_BACK &&
                    t.TYPE !== ry.NEW_RG_FRONT &&
                    t.TYPE !== ry.NEW_RG_BACK &&
                    t.TYPE !== ry.OTHERS) ||
                    ((ny = t.TYPE),
                    (oy = iy.FRONT),
                    ny === ry.OTHERS &&
                      (function (t) {
                        uy =
                          t.optional &&
                          '' !== t.optional.LABEL_DOCUMENT_TYPE_OTHERS &&
                          void 0 !== t.optional.LABEL_DOCUMENT_TYPE_OTHERS &&
                          null !== t.optional.LABEL_DOCUMENT_TYPE_OTHERS
                            ? t.optional.LABEL_DOCUMENT_TYPE_OTHERS
                            : 'Outros'
                      })(t)),
                  mb())
                : Qg.on.error('Tipo de documento inválido.')
              : Qg.on.error('O elemento com id #box-camera não foi encontrado!')
            : ub())
        : window.console.error('Métodos de Callback não implementados corretamente!')
    }),
    (t.initTimerTake = Qy),
    (t.isCentralizedFace = rb),
    (t.loadMask = ib),
    (t.loadMaskDocument = sb),
    (t.onPlay = $y),
    (t.orientationChange = Vy),
    (t.resetProcessVariables = cb),
    (t.resetVariables = lb),
    (t.setAspectRatio = Oy),
    (t.setConfiguration = gb),
    (t.setConstraint = Dy),
    (t.setControls = vb),
    (t.setLabelDocumentInfo = fb),
    (t.setLoading = Jy),
    (t.setMobileStyle = My),
    (t.setOrientation = bb),
    (t.setTrack = Ty),
    (t.setTypeSilhouette = ab),
    (t.setVisibilityAfterTake = Wy),
    (t.setVisibilityOpenCamera = Ly),
    (t.startCamera = Py),
    (t.startTimerSession = Xy),
    (t.stopStuffsAfterTake = By),
    (t.takePicture = tb),
    (t.toggleFullScreen = Uy),
    (t.updateTimeStats = qy),
    (t.updateView = Hy),
    (t.verifyBoxCamera = _b),
    (t.verifyFaceApiIsRunning = Ky),
    (t.visibilityChange = wb),
    (t.webFrameModel = Vi),
    Object.defineProperty(t, '__esModule', { value: !0 })
})
//# sourceMappingURL=unico-webframe.umd.js.map
